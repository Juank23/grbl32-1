ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 2
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"planner.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.global	__aeabi_fadd
  16              		.global	__aeabi_fmul
  17              		.global	__aeabi_fcmplt
  18              		.global	__aeabi_fcmpeq
  19              		.global	__aeabi_fcmpgt
  20              		.section	.text.planner_recalculate,"ax",%progbits
  21              		.align	1
  22              		.p2align 2,,3
  23              		.syntax unified
  24              		.thumb
  25              		.thumb_func
  26              		.fpu softvfp
  28              	planner_recalculate:
  29              	.LFB705:
  30              		.file 1 "grbl/planner.c"
   1:grbl/planner.c **** /*
   2:grbl/planner.c ****   planner.c - buffers movement commands and manages the acceleration profile plan
   3:grbl/planner.c ****   Part of Grbl
   4:grbl/planner.c **** 
   5:grbl/planner.c ****   Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
   6:grbl/planner.c ****   Copyright (c) 2009-2011 Simen Svale Skogsrud
   7:grbl/planner.c ****   Copyright (c) 2011 Jens Geisler
   8:grbl/planner.c ****   Copyright (c) 2018-2019 Thomas Truong
   9:grbl/planner.c **** 
  10:grbl/planner.c ****   Grbl is free software: you can redistribute it and/or modify
  11:grbl/planner.c ****   it under the terms of the GNU General Public License as published by
  12:grbl/planner.c ****   the Free Software Foundation, either version 3 of the License, or
  13:grbl/planner.c ****   (at your option) any later version.
  14:grbl/planner.c **** 
  15:grbl/planner.c ****   Grbl is distributed in the hope that it will be useful,
  16:grbl/planner.c ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  17:grbl/planner.c ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  18:grbl/planner.c ****   GNU General Public License for more details.
  19:grbl/planner.c **** 
  20:grbl/planner.c ****   You should have received a copy of the GNU General Public License
  21:grbl/planner.c ****   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  22:grbl/planner.c **** */
  23:grbl/planner.c **** 
  24:grbl/planner.c **** #include "grbl.h"
  25:grbl/planner.c **** 
  26:grbl/planner.c **** 
  27:grbl/planner.c **** static plan_block_t block_buffer[BLOCK_BUFFER_SIZE];  // A ring buffer for motion instructions
  28:grbl/planner.c **** static uint8_t block_buffer_tail;     // Index of the block to process now
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 2


  29:grbl/planner.c **** static uint8_t block_buffer_head;     // Index of the next block to be pushed
  30:grbl/planner.c **** static uint8_t next_buffer_head;      // Index of the next buffer head
  31:grbl/planner.c **** static uint8_t block_buffer_planned;  // Index of the optimally planned block
  32:grbl/planner.c **** 
  33:grbl/planner.c **** // Define planner variables
  34:grbl/planner.c **** typedef struct {
  35:grbl/planner.c ****   int32_t position[N_AXIS];          // The planner position of the tool in absolute steps. Kept se
  36:grbl/planner.c ****                                      // from g-code position for movements requiring multiple line 
  37:grbl/planner.c ****                                      // i.e. arcs, canned cycles, and backlash compensation.
  38:grbl/planner.c ****   float previous_unit_vec[N_AXIS];   // Unit vector of previous path line segment
  39:grbl/planner.c ****   float previous_nominal_speed;  // Nominal speed of previous path line segment
  40:grbl/planner.c **** } planner_t;
  41:grbl/planner.c **** static planner_t pl;
  42:grbl/planner.c **** 
  43:grbl/planner.c **** 
  44:grbl/planner.c **** // Returns the index of the next block in the ring buffer. Also called by stepper segment buffer.
  45:grbl/planner.c **** uint8_t plan_next_block_index(uint8_t block_index)
  46:grbl/planner.c **** {
  47:grbl/planner.c ****   block_index++;
  48:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
  49:grbl/planner.c ****   return(block_index);
  50:grbl/planner.c **** }
  51:grbl/planner.c **** 
  52:grbl/planner.c **** 
  53:grbl/planner.c **** // Returns the index of the previous block in the ring buffer
  54:grbl/planner.c **** static uint8_t plan_prev_block_index(uint8_t block_index)
  55:grbl/planner.c **** {
  56:grbl/planner.c ****   if (block_index == 0) { block_index = BLOCK_BUFFER_SIZE; }
  57:grbl/planner.c ****   block_index--;
  58:grbl/planner.c ****   return(block_index);
  59:grbl/planner.c **** }
  60:grbl/planner.c **** 
  61:grbl/planner.c **** 
  62:grbl/planner.c **** /*                            PLANNER SPEED DEFINITION
  63:grbl/planner.c ****                                      +--------+   <- current->nominal_speed
  64:grbl/planner.c ****                                     /          \
  65:grbl/planner.c ****          current->entry_speed ->   +            \
  66:grbl/planner.c ****                                    |             + <- next->entry_speed (aka exit speed)
  67:grbl/planner.c ****                                    +-------------+
  68:grbl/planner.c ****                                        time -->
  69:grbl/planner.c **** 
  70:grbl/planner.c ****   Recalculates the motion plan according to the following basic guidelines:
  71:grbl/planner.c **** 
  72:grbl/planner.c ****     1. Go over every feasible block sequentially in reverse order and calculate the junction speeds
  73:grbl/planner.c ****         (i.e. current->entry_speed) such that:
  74:grbl/planner.c ****       a. No junction speed exceeds the pre-computed maximum junction speed limit or nominal speeds 
  75:grbl/planner.c ****          neighboring blocks.
  76:grbl/planner.c ****       b. A block entry speed cannot exceed one reverse-computed from its exit speed (next->entry_sp
  77:grbl/planner.c ****          with a maximum allowable deceleration over the block travel distance.
  78:grbl/planner.c ****       c. The last (or newest appended) block is planned from a complete stop (an exit speed of zero
  79:grbl/planner.c ****     2. Go over every block in chronological (forward) order and dial down junction speed values if
  80:grbl/planner.c ****       a. The exit speed exceeds the one forward-computed from its entry speed with the maximum allo
  81:grbl/planner.c ****          acceleration over the block travel distance.
  82:grbl/planner.c **** 
  83:grbl/planner.c ****   When these stages are complete, the planner will have maximized the velocity profiles throughout 
  84:grbl/planner.c ****   of the planner blocks, where every block is operating at its maximum allowable acceleration limit
  85:grbl/planner.c ****   other words, for all of the blocks in the planner, the plan is optimal and no further speed impro
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 3


  86:grbl/planner.c ****   are possible. If a new block is added to the buffer, the plan is recomputed according to the said
  87:grbl/planner.c ****   guidelines for a new optimal plan.
  88:grbl/planner.c **** 
  89:grbl/planner.c ****   To increase computational efficiency of these guidelines, a set of planner block pointers have be
  90:grbl/planner.c ****   created to indicate stop-compute points for when the planner guidelines cannot logically make any
  91:grbl/planner.c ****   changes or improvements to the plan when in normal operation and new blocks are streamed and adde
  92:grbl/planner.c ****   planner buffer. For example, if a subset of sequential blocks in the planner have been planned an
  93:grbl/planner.c ****   bracketed by junction velocities at their maximums (or by the first planner block as well), no ne
  94:grbl/planner.c ****   added to the planner buffer will alter the velocity profiles within them. So we no longer have to
  95:grbl/planner.c ****   them. Or, if a set of sequential blocks from the first block in the planner (or a optimal stop-co
  96:grbl/planner.c ****   point) are all accelerating, they are all optimal and can not be altered by a new block added to 
  97:grbl/planner.c ****   planner buffer, as this will only further increase the plan speed to chronological blocks until a
  98:grbl/planner.c ****   junction velocity is reached. However, if the operational conditions of the plan changes from inf
  99:grbl/planner.c ****   used feed holds or feedrate overrides, the stop-compute pointers will be reset and the entire pla
 100:grbl/planner.c ****   recomputed as stated in the general guidelines.
 101:grbl/planner.c **** 
 102:grbl/planner.c ****   Planner buffer index mapping:
 103:grbl/planner.c ****   - block_buffer_tail: Points to the beginning of the planner buffer. First to be executed or being
 104:grbl/planner.c ****   - block_buffer_head: Points to the buffer block after the last block in the buffer. Used to indic
 105:grbl/planner.c ****       the buffer is full or empty. As described for standard ring buffers, this block is always emp
 106:grbl/planner.c ****   - next_buffer_head: Points to next planner buffer block after the buffer head block. When equal t
 107:grbl/planner.c ****       buffer tail, this indicates the buffer is full.
 108:grbl/planner.c ****   - block_buffer_planned: Points to the first buffer block after the last optimally planned block f
 109:grbl/planner.c ****       streaming operating conditions. Use for planning optimizations by avoiding recomputing parts 
 110:grbl/planner.c ****       planner buffer that don't change with the addition of a new block, as describe above. In addi
 111:grbl/planner.c ****       this block can never be less than block_buffer_tail and will always be pushed forward and mai
 112:grbl/planner.c ****       this requirement when encountered by the plan_discard_current_block() routine during a cycle.
 113:grbl/planner.c **** 
 114:grbl/planner.c ****   NOTE: Since the planner only computes on what's in the planner buffer, some motions with lots of 
 115:grbl/planner.c ****   line segments, like G2/3 arcs or complex curves, may seem to move slow. This is because there sim
 116:grbl/planner.c ****   enough combined distance traveled in the entire buffer to accelerate up to the nominal speed and 
 117:grbl/planner.c ****   decelerate to a complete stop at the end of the buffer, as stated by the guidelines. If this happ
 118:grbl/planner.c ****   becomes an annoyance, there are a few simple solutions: (1) Maximize the machine acceleration. Th
 119:grbl/planner.c ****   will be able to compute higher velocity profiles within the same combined distance. (2) Maximize 
 120:grbl/planner.c ****   motion(s) distance per block to a desired tolerance. The more combined distance the planner has t
 121:grbl/planner.c ****   the faster it can go. (3) Maximize the planner buffer size. This also will increase the combined 
 122:grbl/planner.c ****   for the planner to compute over. It also increases the number of computations the planner has to 
 123:grbl/planner.c ****   to compute an optimal plan, so select carefully. The Arduino 328p memory is already maxed out, bu
 124:grbl/planner.c ****   ARM versions should have enough memory and speed for look-ahead blocks numbering up to a hundred 
 125:grbl/planner.c **** 
 126:grbl/planner.c **** */
 127:grbl/planner.c **** static void planner_recalculate()
 128:grbl/planner.c **** {
  31              		.loc 1 128 0
  32              		.cfi_startproc
  33              		@ args = 0, pretend = 0, frame = 8
  34              		@ frame_needed = 0, uses_anonymous_args = 0
  35 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
  36              	.LCFI0:
  37              		.cfi_def_cfa_offset 36
  38              		.cfi_offset 4, -36
  39              		.cfi_offset 5, -32
  40              		.cfi_offset 6, -28
  41              		.cfi_offset 7, -24
  42              		.cfi_offset 8, -20
  43              		.cfi_offset 9, -16
  44              		.cfi_offset 10, -12
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 4


  45              		.cfi_offset 11, -8
  46              		.cfi_offset 14, -4
 129:grbl/planner.c ****   // Initialize block index to the last block in the planner buffer.
 130:grbl/planner.c ****   uint8_t block_index = plan_prev_block_index(block_buffer_head);
  47              		.loc 1 130 0
  48 0004 6B4B     		ldr	r3, .L48
 128:grbl/planner.c ****   // Initialize block index to the last block in the planner buffer.
  49              		.loc 1 128 0
  50 0006 83B0     		sub	sp, sp, #12
  51              	.LCFI1:
  52              		.cfi_def_cfa_offset 48
  53              		.loc 1 130 0
  54 0008 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  55 000a 0193     		str	r3, [sp, #4]
  56              	.LVL0:
  57              	.LBB30:
  58              	.LBB31:
  56:grbl/planner.c ****   block_index--;
  59              		.loc 1 56 0
  60 000c 002B     		cmp	r3, #0
  61 000e 00F0BA80 		beq	.L27
  62 0012 5C1E     		subs	r4, r3, #1
  63 0014 E4B2     		uxtb	r4, r4
  64              	.L2:
  65              	.LVL1:
  66              	.LBE31:
  67              	.LBE30:
 131:grbl/planner.c **** 
 132:grbl/planner.c ****   // Bail. Can't do anything with one only one plan-able block.
 133:grbl/planner.c ****   if (block_index == block_buffer_planned) { return; }
  68              		.loc 1 133 0
  69 0016 684B     		ldr	r3, .L48+4
  70 0018 93F80080 		ldrb	r8, [r3]	@ zero_extendqisi2
  71 001c A045     		cmp	r8, r4
  72 001e 00F0AF80 		beq	.L1
  73              	.LVL2:
 134:grbl/planner.c **** 
 135:grbl/planner.c ****   // Reverse Pass: Coarsely maximize all possible deceleration curves back-planning from the last
 136:grbl/planner.c ****   // block in buffer. Cease planning when the last optimal planned or tail pointer is reached.
 137:grbl/planner.c ****   // NOTE: Forward pass will later refine and correct the reverse pass to create an optimal plan.
 138:grbl/planner.c ****   float entry_speed_sqr;
 139:grbl/planner.c ****   plan_block_t *next;
 140:grbl/planner.c ****   plan_block_t *current = &block_buffer[block_index];
 141:grbl/planner.c **** 
 142:grbl/planner.c ****   // Calculate maximum entry speed for last block in buffer, where the exit speed is always zero.
 143:grbl/planner.c ****   current->entry_speed_sqr = min( current->max_entry_speed_sqr, 2*current->pbacceleration*current->
  74              		.loc 1 143 0
  75 0022 3426     		movs	r6, #52
  76 0024 654D     		ldr	r5, .L48+8
  77 0026 06FB0456 		mla	r6, r6, r4, r5
  78 002a F169     		ldr	r1, [r6, #28]	@ float
  79 002c B769     		ldr	r7, [r6, #24]	@ float
  80 002e 0846     		mov	r0, r1
  81 0030 FFF7FEFF 		bl	__aeabi_fadd
  82              	.LVL3:
  83 0034 316A     		ldr	r1, [r6, #32]	@ float
  84 0036 FFF7FEFF 		bl	__aeabi_fmul
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 5


  85              	.LVL4:
  86 003a 0646     		mov	r6, r0
  87 003c 0146     		mov	r1, r0
  88 003e 3846     		mov	r0, r7
  89 0040 FFF7FEFF 		bl	__aeabi_fcmplt
  90              	.LVL5:
  91 0044 00B1     		cbz	r0, .L5
  92 0046 3E46     		mov	r6, r7
  93              	.L5:
  94              		.loc 1 143 0 is_stmt 0 discriminator 4
  95 0048 3423     		movs	r3, #52
  96 004a 03FB0453 		mla	r3, r3, r4, r5
  97 004e 5E61     		str	r6, [r3, #20]	@ float
  98              	.LVL6:
  99              	.LBB33:
 100              	.LBB34:
  56:grbl/planner.c ****   block_index--;
 101              		.loc 1 56 0 is_stmt 1 discriminator 4
 102 0050 002C     		cmp	r4, #0
 103 0052 00F09A80 		beq	.L28
 104 0056 631E     		subs	r3, r4, #1
 105 0058 5FFA83FB 		uxtb	fp, r3
 106 005c 584B     		ldr	r3, .L48+12
 107              	.LBE34:
 108              	.LBE33:
 144:grbl/planner.c **** 
 145:grbl/planner.c ****   block_index = plan_prev_block_index(block_index);
 146:grbl/planner.c ****   if (block_index == block_buffer_planned) { // Only two plannable blocks in buffer. Reverse pass c
 109              		.loc 1 146 0
 110 005e D845     		cmp	r8, fp
 111 0060 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 112 0062 00F09980 		beq	.L8
 113              	.L47:
 140:grbl/planner.c **** 
 114              		.loc 1 140 0
 115 0066 3427     		movs	r7, #52
 116 0068 5E46     		mov	r6, fp
 117 006a 07FB0454 		mla	r4, r7, r4, r5
 118              	.LVL7:
 119 006e 27E0     		b	.L9
 120              	.LVL8:
 121              	.L46:
 122 0070 013E     		subs	r6, r6, #1
 123              	.LVL9:
 124 0072 F6B2     		uxtb	r6, r6
 147:grbl/planner.c ****     // Check if the first block is the tail. If so, notify stepper to update its current parameters
 148:grbl/planner.c ****     if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 149:grbl/planner.c ****   } else { // Three or more plan-able blocks
 150:grbl/planner.c ****     while (block_index != block_buffer_planned) {
 151:grbl/planner.c ****       next = current;
 152:grbl/planner.c ****       current = &block_buffer[block_index];
 153:grbl/planner.c ****       block_index = plan_prev_block_index(block_index);
 154:grbl/planner.c **** 
 155:grbl/planner.c ****       // Check if next block is the tail block(=planned block). If so, update current stepper param
 156:grbl/planner.c ****       if (block_index == block_buffer_tail) { st_update_plan_block_parameters(); }
 125              		.loc 1 156 0
 126 0074 B142     		cmp	r1, r6
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 6


 127 0076 2BD0     		beq	.L44
 128              	.L12:
 157:grbl/planner.c **** 
 158:grbl/planner.c ****       // Compute maximum entry speed decelerating over the current block from its exit speed.
 159:grbl/planner.c ****       if (current->entry_speed_sqr != current->max_entry_speed_sqr) {
 129              		.loc 1 159 0
 130 0078 07FB0959 		mla	r9, r7, r9, r5
 131 007c D9F818B0 		ldr	fp, [r9, #24]	@ float
 132 0080 D9F81400 		ldr	r0, [r9, #20]	@ float
 133 0084 5946     		mov	r1, fp
 134 0086 FFF7FEFF 		bl	__aeabi_fcmpeq
 135              	.LVL10:
 136 008a A0B9     		cbnz	r0, .L13
 160:grbl/planner.c ****         entry_speed_sqr = next->entry_speed_sqr + 2*current->pbacceleration*current->millimeters;
 137              		.loc 1 160 0
 138 008c D9F81C10 		ldr	r1, [r9, #28]	@ float
 139 0090 0846     		mov	r0, r1
 140 0092 FFF7FEFF 		bl	__aeabi_fadd
 141              	.LVL11:
 142 0096 D9F82010 		ldr	r1, [r9, #32]	@ float
 143 009a FFF7FEFF 		bl	__aeabi_fmul
 144              	.LVL12:
 145 009e 6169     		ldr	r1, [r4, #20]	@ float
 146 00a0 FFF7FEFF 		bl	__aeabi_fadd
 147              	.LVL13:
 148 00a4 0446     		mov	r4, r0
 149              	.LVL14:
 161:grbl/planner.c ****         if (entry_speed_sqr < current->max_entry_speed_sqr) {
 150              		.loc 1 161 0
 151 00a6 0146     		mov	r1, r0
 152 00a8 5846     		mov	r0, fp
 153              	.LVL15:
 154 00aa FFF7FEFF 		bl	__aeabi_fcmpgt
 155              	.LVL16:
 156 00ae 0028     		cmp	r0, #0
 157 00b0 7DD0     		beq	.L41
 162:grbl/planner.c ****           current->entry_speed_sqr = entry_speed_sqr;
 158              		.loc 1 162 0
 159 00b2 C9F81440 		str	r4, [r9, #20]	@ float
 160              	.LVL17:
 161              	.L13:
 150:grbl/planner.c ****       next = current;
 162              		.loc 1 150 0
 163 00b6 4645     		cmp	r6, r8
 164 00b8 10D0     		beq	.L45
 165 00ba 5446     		mov	r4, r10
 166 00bc 404B     		ldr	r3, .L48+12
 167 00be 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 168              	.LVL18:
 169              	.L9:
 152:grbl/planner.c ****       block_index = plan_prev_block_index(block_index);
 170              		.loc 1 152 0
 171 00c0 B146     		mov	r9, r6
 172 00c2 07FB065A 		mla	r10, r7, r6, r5
 173              	.LVL19:
 174              	.LBB36:
 175              	.LBB37:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 7


  56:grbl/planner.c ****   block_index--;
 176              		.loc 1 56 0
 177 00c6 002E     		cmp	r6, #0
 178 00c8 D2D1     		bne	.L46
 179 00ca C726     		movs	r6, #199
 180              	.LVL20:
 181              	.LBE37:
 182              	.LBE36:
 156:grbl/planner.c **** 
 183              		.loc 1 156 0
 184 00cc B142     		cmp	r1, r6
 185 00ce D3D1     		bne	.L12
 186              	.L44:
 156:grbl/planner.c **** 
 187              		.loc 1 156 0 is_stmt 0 discriminator 1
 188 00d0 FFF7FEFF 		bl	st_update_plan_block_parameters
 189              	.LVL21:
 190 00d4 384B     		ldr	r3, .L48+4
 191 00d6 93F80080 		ldrb	r8, [r3]	@ zero_extendqisi2
 192 00da CDE7     		b	.L12
 193              	.LVL22:
 194              	.L45:
 195 00dc B346     		mov	fp, r6
 196 00de 354B     		ldr	r3, .L48
 197 00e0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 198 00e2 0193     		str	r3, [sp, #4]
 199              	.LVL23:
 200              	.L10:
 163:grbl/planner.c ****         } else {
 164:grbl/planner.c ****           current->entry_speed_sqr = current->max_entry_speed_sqr;
 165:grbl/planner.c ****         }
 166:grbl/planner.c ****       }
 167:grbl/planner.c ****     }
 168:grbl/planner.c ****   }
 169:grbl/planner.c **** 
 170:grbl/planner.c ****   // Forward Pass: Forward plan the acceleration curve from the planned pointer onward.
 171:grbl/planner.c ****   // Also scans for optimal plan breakpoints and appropriately updates the planned pointer.
 172:grbl/planner.c ****   next = &block_buffer[block_buffer_planned]; // Begin at buffer planned pointer
 201              		.loc 1 172 0 is_stmt 1
 202 00e4 4FF03408 		mov	r8, #52
 203              	.LBB38:
 204              	.LBB39:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 205              		.loc 1 47 0
 206 00e8 0BF10104 		add	r4, fp, #1
 207 00ec E4B2     		uxtb	r4, r4
  48:grbl/planner.c ****   return(block_index);
 208              		.loc 1 48 0
 209 00ee C82C     		cmp	r4, #200
 210 00f0 08BF     		it	eq
 211 00f2 0024     		moveq	r4, #0
 212              	.LBE39:
 213              	.LBE38:
 214              		.loc 1 172 0
 215 00f4 08FB0B5A 		mla	r10, r8, fp, r5
 216              	.LVL24:
 173:grbl/planner.c ****   block_index = plan_next_block_index(block_buffer_planned);
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 8


 174:grbl/planner.c ****   while (block_index != block_buffer_head) {
 175:grbl/planner.c ****     current = next;
 176:grbl/planner.c ****     next = &block_buffer[block_index];
 217              		.loc 1 176 0
 218 00f8 CDF80080 		str	r8, [sp]
 219              	.LBB40:
 220              	.LBB41:
  48:grbl/planner.c ****   return(block_index);
 221              		.loc 1 48 0
 222 00fc 4FF00009 		mov	r9, #0
 223 0100 35E0     		b	.L19
 224              	.LVL25:
 225              	.L25:
 226              	.LBE41:
 227              	.LBE40:
 228              		.loc 1 176 0
 229 0102 009B     		ldr	r3, [sp]
 177:grbl/planner.c **** 
 178:grbl/planner.c ****     // Any acceleration detected in the forward pass automatically moves the optimal planned
 179:grbl/planner.c ****     // pointer forward, since everything before this is all optimal. In other words, nothing
 180:grbl/planner.c ****     // can improve the plan from the buffer tail to the planned pointer by logic.
 181:grbl/planner.c ****     if (current->entry_speed_sqr < next->entry_speed_sqr) {
 230              		.loc 1 181 0
 231 0104 DAF81480 		ldr	r8, [r10, #20]	@ float
 176:grbl/planner.c **** 
 232              		.loc 1 176 0
 233 0108 03FB0457 		mla	r7, r3, r4, r5
 234              	.LVL26:
 235              		.loc 1 181 0
 236 010c 7E69     		ldr	r6, [r7, #20]	@ float
 237 010e 4046     		mov	r0, r8
 238 0110 3146     		mov	r1, r6
 239 0112 FFF7FEFF 		bl	__aeabi_fcmplt
 240              	.LVL27:
 241 0116 B8B1     		cbz	r0, .L20
 182:grbl/planner.c ****       entry_speed_sqr = current->entry_speed_sqr + 2*current->pbacceleration*current->millimeters;
 242              		.loc 1 182 0
 243 0118 DAF81C10 		ldr	r1, [r10, #28]	@ float
 244 011c 0846     		mov	r0, r1
 245 011e FFF7FEFF 		bl	__aeabi_fadd
 246              	.LVL28:
 247 0122 DAF82010 		ldr	r1, [r10, #32]	@ float
 248 0126 FFF7FEFF 		bl	__aeabi_fmul
 249              	.LVL29:
 250 012a 4146     		mov	r1, r8
 251 012c FFF7FEFF 		bl	__aeabi_fadd
 252              	.LVL30:
 253 0130 8046     		mov	r8, r0
 254              	.LVL31:
 183:grbl/planner.c ****       // If true, current block is full-acceleration and we can move the planned pointer forward.
 184:grbl/planner.c ****       if (entry_speed_sqr < next->entry_speed_sqr) {
 255              		.loc 1 184 0
 256 0132 0146     		mov	r1, r0
 257 0134 3046     		mov	r0, r6
 258              	.LVL32:
 259 0136 FFF7FEFF 		bl	__aeabi_fcmpgt
 260              	.LVL33:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 9


 261 013a 28B1     		cbz	r0, .L20
 185:grbl/planner.c ****         next->entry_speed_sqr = entry_speed_sqr; // Always <= max_entry_speed_sqr. Backward pass se
 262              		.loc 1 185 0
 263 013c 4646     		mov	r6, r8
 264 013e A346     		mov	fp, r4
 265 0140 4FF00109 		mov	r9, #1
 266 0144 C7F81480 		str	r8, [r7, #20]	@ float
 267              	.LVL34:
 268              	.L20:
 186:grbl/planner.c ****         block_buffer_planned = block_index; // Set optimal plan pointer.
 187:grbl/planner.c ****       }
 188:grbl/planner.c ****     }
 189:grbl/planner.c **** 
 190:grbl/planner.c ****     // Any block set at its maximum entry speed also creates an optimal plan up to this
 191:grbl/planner.c ****     // point in the buffer. When the plan is bracketed by either the beginning of the
 192:grbl/planner.c ****     // buffer and a maximum entry speed or two maximum entry speeds, every block in between
 193:grbl/planner.c ****     // cannot logically be further improved. Hence, we don't have to recompute them anymore.
 194:grbl/planner.c ****     if (next->entry_speed_sqr == next->max_entry_speed_sqr) { block_buffer_planned = block_index; }
 269              		.loc 1 194 0
 270 0148 009B     		ldr	r3, [sp]
 271 014a 3146     		mov	r1, r6
 272 014c 03FB0453 		mla	r3, r3, r4, r5
 273 0150 9869     		ldr	r0, [r3, #24]	@ float
 274 0152 FFF7FEFF 		bl	__aeabi_fcmpeq
 275              	.LVL35:
 276              	.LBB45:
 277              	.LBB42:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 278              		.loc 1 47 0
 279 0156 631C     		adds	r3, r4, #1
 280              	.LBE42:
 281              	.LBE45:
 282 0158 0028     		cmp	r0, #0
 283 015a 18BF     		it	ne
 284 015c A346     		movne	fp, r4
 285              	.LBB46:
 286              	.LBB43:
 287 015e DCB2     		uxtb	r4, r3
 288              	.LVL36:
 289              	.LBE43:
 290              	.LBE46:
 291 0160 18BF     		it	ne
 292 0162 4FF00109 		movne	r9, #1
 293              	.LVL37:
 294              	.LBB47:
 295              	.LBB44:
  48:grbl/planner.c ****   return(block_index);
 296              		.loc 1 48 0
 297 0166 C82C     		cmp	r4, #200
 298 0168 BA46     		mov	r10, r7
 299              	.LVL38:
 300 016a 08BF     		it	eq
 301 016c 0024     		moveq	r4, #0
 302              	.LVL39:
 303              	.L19:
 304              	.LBE44:
 305              	.LBE47:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 10


 174:grbl/planner.c ****     current = next;
 306              		.loc 1 174 0
 307 016e 019B     		ldr	r3, [sp, #4]
 308 0170 9C42     		cmp	r4, r3
 309 0172 C6D1     		bne	.L25
 310 0174 B9F1000F 		cmp	r9, #0
 311 0178 02D0     		beq	.L1
 312 017a 0F4B     		ldr	r3, .L48+4
 313 017c 83F800B0 		strb	fp, [r3]
 314              	.LVL40:
 315              	.L1:
 195:grbl/planner.c ****     block_index = plan_next_block_index( block_index );
 196:grbl/planner.c ****   }
 197:grbl/planner.c **** }
 316              		.loc 1 197 0
 317 0180 03B0     		add	sp, sp, #12
 318              	.LCFI2:
 319              		.cfi_remember_state
 320              		.cfi_def_cfa_offset 36
 321              		@ sp needed
 322 0182 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 323              	.LVL41:
 324              	.L27:
 325              	.LCFI3:
 326              		.cfi_restore_state
 327              	.LBB48:
 328              	.LBB32:
  56:grbl/planner.c ****   block_index--;
 329              		.loc 1 56 0
 330 0186 C724     		movs	r4, #199
 331 0188 45E7     		b	.L2
 332              	.LVL42:
 333              	.L28:
 334              	.LBE32:
 335              	.LBE48:
 336              	.LBB49:
 337              	.LBB35:
 338 018a 4FF0C70B 		mov	fp, #199
 339 018e 0C4B     		ldr	r3, .L48+12
 340              	.LBE35:
 341              	.LBE49:
 146:grbl/planner.c ****     // Check if the first block is the tail. If so, notify stepper to update its current parameters
 342              		.loc 1 146 0
 343 0190 D845     		cmp	r8, fp
 344 0192 1978     		ldrb	r1, [r3]	@ zero_extendqisi2
 345 0194 7FF467AF 		bne	.L47
 346              	.L8:
 148:grbl/planner.c ****   } else { // Three or more plan-able blocks
 347              		.loc 1 148 0
 348 0198 8B45     		cmp	fp, r1
 349 019a A3D1     		bne	.L10
 148:grbl/planner.c ****   } else { // Three or more plan-able blocks
 350              		.loc 1 148 0 is_stmt 0 discriminator 1
 351 019c FFF7FEFF 		bl	st_update_plan_block_parameters
 352              	.LVL43:
 353 01a0 044B     		ldr	r3, .L48
 354 01a2 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 11


 355 01a4 0193     		str	r3, [sp, #4]
 356 01a6 044B     		ldr	r3, .L48+4
 357 01a8 93F800B0 		ldrb	fp, [r3]	@ zero_extendqisi2
 358 01ac 9AE7     		b	.L10
 359              	.LVL44:
 360              	.L41:
 164:grbl/planner.c ****         }
 361              		.loc 1 164 0 is_stmt 1
 362 01ae C9F814B0 		str	fp, [r9, #20]	@ float
 363 01b2 80E7     		b	.L13
 364              	.L49:
 365              		.align	2
 366              	.L48:
 367 01b4 00000000 		.word	.LANCHOR0
 368 01b8 00000000 		.word	.LANCHOR1
 369 01bc 00000000 		.word	block_buffer
 370 01c0 00000000 		.word	.LANCHOR2
 371              		.cfi_endproc
 372              	.LFE705:
 374              		.section	.text.plan_next_block_index,"ax",%progbits
 375              		.align	1
 376              		.p2align 2,,3
 377              		.global	plan_next_block_index
 378              		.syntax unified
 379              		.thumb
 380              		.thumb_func
 381              		.fpu softvfp
 383              	plan_next_block_index:
 384              	.LFB703:
  46:grbl/planner.c ****   block_index++;
 385              		.loc 1 46 0
 386              		.cfi_startproc
 387              		@ args = 0, pretend = 0, frame = 0
 388              		@ frame_needed = 0, uses_anonymous_args = 0
 389              		@ link register save eliminated.
 390              	.LVL45:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 391              		.loc 1 47 0
 392 0000 0130     		adds	r0, r0, #1
 393              	.LVL46:
 394 0002 C0B2     		uxtb	r0, r0
 395              	.LVL47:
  48:grbl/planner.c ****   return(block_index);
 396              		.loc 1 48 0
 397 0004 C828     		cmp	r0, #200
 398              	.LVL48:
  50:grbl/planner.c **** 
 399              		.loc 1 50 0
 400 0006 08BF     		it	eq
 401 0008 0020     		moveq	r0, #0
 402              	.LVL49:
 403 000a 7047     		bx	lr
 404              		.cfi_endproc
 405              	.LFE703:
 407              		.section	.text.plan_reset,"ax",%progbits
 408              		.align	1
 409              		.p2align 2,,3
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 12


 410              		.global	plan_reset
 411              		.syntax unified
 412              		.thumb
 413              		.thumb_func
 414              		.fpu softvfp
 416              	plan_reset:
 417              	.LFB706:
 198:grbl/planner.c **** 
 199:grbl/planner.c **** 
 200:grbl/planner.c **** void plan_reset()
 201:grbl/planner.c **** {
 418              		.loc 1 201 0
 419              		.cfi_startproc
 420              		@ args = 0, pretend = 0, frame = 0
 421              		@ frame_needed = 0, uses_anonymous_args = 0
 422              		@ link register save eliminated.
 202:grbl/planner.c ****   memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 423              		.loc 1 202 0
 424 0000 0023     		movs	r3, #0
 425              	.LBB50:
 426              	.LBB51:
 203:grbl/planner.c ****   plan_reset_buffer();
 204:grbl/planner.c **** }
 205:grbl/planner.c **** 
 206:grbl/planner.c **** 
 207:grbl/planner.c **** void plan_reset_buffer()
 208:grbl/planner.c **** {
 209:grbl/planner.c ****   block_buffer_tail = 0;
 210:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
 211:grbl/planner.c ****   next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 427              		.loc 1 211 0
 428 0002 0120     		movs	r0, #1
 429              	.LBE51:
 430              	.LBE50:
 201:grbl/planner.c ****   memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 431              		.loc 1 201 0
 432 0004 30B4     		push	{r4, r5}
 433              	.LCFI4:
 434              		.cfi_def_cfa_offset 8
 435              		.cfi_offset 4, -8
 436              		.cfi_offset 5, -4
 202:grbl/planner.c ****   memset(&pl, 0, sizeof(planner_t)); // Clear planner struct
 437              		.loc 1 202 0
 438 0006 094A     		ldr	r2, .L54
 439              	.LBB57:
 440              	.LBB52:
 209:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
 441              		.loc 1 209 0
 442 0008 0949     		ldr	r1, .L54+4
 443              	.LBE52:
 444              	.LBE57:
 202:grbl/planner.c ****   plan_reset_buffer();
 445              		.loc 1 202 0
 446 000a C2E90033 		strd	r3, r3, [r2]
 447              	.LBB58:
 448              	.LBB53:
 209:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 13


 449              		.loc 1 209 0
 450 000e 0B70     		strb	r3, [r1]
 451              	.LBE53:
 452              	.LBE58:
 202:grbl/planner.c ****   plan_reset_buffer();
 453              		.loc 1 202 0
 454 0010 C2E90233 		strd	r3, r3, [r2, #8]
 455              	.LBB59:
 456              	.LBB54:
 457              		.loc 1 211 0
 458 0014 0749     		ldr	r1, .L54+8
 459              	.LBE54:
 460              	.LBE59:
 202:grbl/planner.c ****   plan_reset_buffer();
 461              		.loc 1 202 0
 462 0016 C2E90433 		strd	r3, r3, [r2, #16]
 463              	.LBB60:
 464              	.LBB55:
 210:grbl/planner.c ****   next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 465              		.loc 1 210 0
 466 001a 074D     		ldr	r5, .L54+12
 212:grbl/planner.c ****   block_buffer_planned = 0; // = block_buffer_tail;
 467              		.loc 1 212 0
 468 001c 074C     		ldr	r4, .L54+16
 469              	.LBE55:
 470              	.LBE60:
 202:grbl/planner.c ****   plan_reset_buffer();
 471              		.loc 1 202 0
 472 001e 9361     		str	r3, [r2, #24]
 473              	.LBB61:
 474              	.LBB56:
 211:grbl/planner.c ****   block_buffer_planned = 0; // = block_buffer_tail;
 475              		.loc 1 211 0
 476 0020 0870     		strb	r0, [r1]
 210:grbl/planner.c ****   next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 477              		.loc 1 210 0
 478 0022 2B70     		strb	r3, [r5]
 479              		.loc 1 212 0
 480 0024 2370     		strb	r3, [r4]
 481              	.LBE56:
 482              	.LBE61:
 204:grbl/planner.c **** 
 483              		.loc 1 204 0
 484 0026 30BC     		pop	{r4, r5}
 485              	.LCFI5:
 486              		.cfi_restore 5
 487              		.cfi_restore 4
 488              		.cfi_def_cfa_offset 0
 489 0028 7047     		bx	lr
 490              	.L55:
 491 002a 00BF     		.align	2
 492              	.L54:
 493 002c 00000000 		.word	.LANCHOR3
 494 0030 00000000 		.word	.LANCHOR2
 495 0034 00000000 		.word	.LANCHOR4
 496 0038 00000000 		.word	.LANCHOR0
 497 003c 00000000 		.word	.LANCHOR1
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 14


 498              		.cfi_endproc
 499              	.LFE706:
 501              		.section	.text.plan_reset_buffer,"ax",%progbits
 502              		.align	1
 503              		.p2align 2,,3
 504              		.global	plan_reset_buffer
 505              		.syntax unified
 506              		.thumb
 507              		.thumb_func
 508              		.fpu softvfp
 510              	plan_reset_buffer:
 511              	.LFB707:
 208:grbl/planner.c ****   block_buffer_tail = 0;
 512              		.loc 1 208 0
 513              		.cfi_startproc
 514              		@ args = 0, pretend = 0, frame = 0
 515              		@ frame_needed = 0, uses_anonymous_args = 0
 516              		@ link register save eliminated.
 209:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
 517              		.loc 1 209 0
 518 0000 0023     		movs	r3, #0
 211:grbl/planner.c ****   block_buffer_planned = 0; // = block_buffer_tail;
 519              		.loc 1 211 0
 520 0002 0121     		movs	r1, #1
 208:grbl/planner.c ****   block_buffer_tail = 0;
 521              		.loc 1 208 0
 522 0004 30B4     		push	{r4, r5}
 523              	.LCFI6:
 524              		.cfi_def_cfa_offset 8
 525              		.cfi_offset 4, -8
 526              		.cfi_offset 5, -4
 527              		.loc 1 212 0
 528 0006 0548     		ldr	r0, .L58
 211:grbl/planner.c ****   block_buffer_planned = 0; // = block_buffer_tail;
 529              		.loc 1 211 0
 530 0008 054A     		ldr	r2, .L58+4
 209:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
 531              		.loc 1 209 0
 532 000a 064D     		ldr	r5, .L58+8
 210:grbl/planner.c ****   next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 533              		.loc 1 210 0
 534 000c 064C     		ldr	r4, .L58+12
 535              		.loc 1 212 0
 536 000e 0370     		strb	r3, [r0]
 211:grbl/planner.c ****   block_buffer_planned = 0; // = block_buffer_tail;
 537              		.loc 1 211 0
 538 0010 1170     		strb	r1, [r2]
 209:grbl/planner.c ****   block_buffer_head = 0; // Empty = tail
 539              		.loc 1 209 0
 540 0012 2B70     		strb	r3, [r5]
 210:grbl/planner.c ****   next_buffer_head = 1; // plan_next_block_index(block_buffer_head)
 541              		.loc 1 210 0
 542 0014 2370     		strb	r3, [r4]
 213:grbl/planner.c **** }
 543              		.loc 1 213 0
 544 0016 30BC     		pop	{r4, r5}
 545              	.LCFI7:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 15


 546              		.cfi_restore 5
 547              		.cfi_restore 4
 548              		.cfi_def_cfa_offset 0
 549 0018 7047     		bx	lr
 550              	.L59:
 551 001a 00BF     		.align	2
 552              	.L58:
 553 001c 00000000 		.word	.LANCHOR1
 554 0020 00000000 		.word	.LANCHOR4
 555 0024 00000000 		.word	.LANCHOR2
 556 0028 00000000 		.word	.LANCHOR0
 557              		.cfi_endproc
 558              	.LFE707:
 560              		.section	.text.plan_discard_current_block,"ax",%progbits
 561              		.align	1
 562              		.p2align 2,,3
 563              		.global	plan_discard_current_block
 564              		.syntax unified
 565              		.thumb
 566              		.thumb_func
 567              		.fpu softvfp
 569              	plan_discard_current_block:
 570              	.LFB708:
 214:grbl/planner.c **** 
 215:grbl/planner.c **** 
 216:grbl/planner.c **** void plan_discard_current_block()
 217:grbl/planner.c **** {
 571              		.loc 1 217 0
 572              		.cfi_startproc
 573              		@ args = 0, pretend = 0, frame = 0
 574              		@ frame_needed = 0, uses_anonymous_args = 0
 575              		@ link register save eliminated.
 218:grbl/planner.c ****   if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
 576              		.loc 1 218 0
 577 0000 0A49     		ldr	r1, .L68
 578 0002 0B4B     		ldr	r3, .L68+4
 579 0004 0A78     		ldrb	r2, [r1]	@ zero_extendqisi2
 580 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 581 0008 9342     		cmp	r3, r2
 582 000a 0DD0     		beq	.L65
 583              	.LVL50:
 584              	.LBB62:
 585              	.LBB63:
 586              	.LBB64:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 587              		.loc 1 47 0
 588 000c 531C     		adds	r3, r2, #1
 589 000e DBB2     		uxtb	r3, r3
 590              	.LVL51:
  48:grbl/planner.c ****   return(block_index);
 591              		.loc 1 48 0
 592 0010 C82B     		cmp	r3, #200
 593 0012 08BF     		it	eq
 594 0014 0023     		moveq	r3, #0
 595              	.LVL52:
 596              	.LBE64:
 597              	.LBE63:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 16


 598              	.LBE62:
 217:grbl/planner.c ****   if (block_buffer_head != block_buffer_tail) { // Discard non-empty buffer.
 599              		.loc 1 217 0
 600 0016 10B4     		push	{r4}
 601              	.LCFI8:
 602              		.cfi_def_cfa_offset 4
 603              		.cfi_offset 4, -4
 604              	.LBB65:
 219:grbl/planner.c ****     uint8_t block_index = plan_next_block_index( block_buffer_tail );
 220:grbl/planner.c ****     // Push block_buffer_planned pointer, if encountered.
 221:grbl/planner.c ****     if (block_buffer_tail == block_buffer_planned) { block_buffer_planned = block_index; }
 605              		.loc 1 221 0
 606 0018 0648     		ldr	r0, .L68+8
 222:grbl/planner.c ****     block_buffer_tail = block_index;
 607              		.loc 1 222 0
 608 001a 0B70     		strb	r3, [r1]
 221:grbl/planner.c ****     block_buffer_tail = block_index;
 609              		.loc 1 221 0
 610 001c 0478     		ldrb	r4, [r0]	@ zero_extendqisi2
 611 001e 9442     		cmp	r4, r2
 612 0020 08BF     		it	eq
 613 0022 0370     		strbeq	r3, [r0]
 614              	.LBE65:
 223:grbl/planner.c ****   }
 224:grbl/planner.c **** }
 615              		.loc 1 224 0
 616 0024 10BC     		pop	{r4}
 617              	.LCFI9:
 618              		.cfi_restore 4
 619              		.cfi_def_cfa_offset 0
 620 0026 7047     		bx	lr
 621              	.L65:
 622 0028 7047     		bx	lr
 623              	.L69:
 624 002a 00BF     		.align	2
 625              	.L68:
 626 002c 00000000 		.word	.LANCHOR2
 627 0030 00000000 		.word	.LANCHOR0
 628 0034 00000000 		.word	.LANCHOR1
 629              		.cfi_endproc
 630              	.LFE708:
 632              		.section	.text.plan_get_system_motion_block,"ax",%progbits
 633              		.align	1
 634              		.p2align 2,,3
 635              		.global	plan_get_system_motion_block
 636              		.syntax unified
 637              		.thumb
 638              		.thumb_func
 639              		.fpu softvfp
 641              	plan_get_system_motion_block:
 642              	.LFB709:
 225:grbl/planner.c **** 
 226:grbl/planner.c **** 
 227:grbl/planner.c **** // Returns address of planner buffer block used by system motions. Called by segment generator.
 228:grbl/planner.c **** plan_block_t *plan_get_system_motion_block()
 229:grbl/planner.c **** {
 643              		.loc 1 229 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 17


 644              		.cfi_startproc
 645              		@ args = 0, pretend = 0, frame = 0
 646              		@ frame_needed = 0, uses_anonymous_args = 0
 647              		@ link register save eliminated.
 230:grbl/planner.c ****   return(&block_buffer[block_buffer_head]);
 648              		.loc 1 230 0
 649 0000 3420     		movs	r0, #52
 650 0002 034A     		ldr	r2, .L71
 651 0004 034B     		ldr	r3, .L71+4
 652 0006 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 231:grbl/planner.c **** }
 653              		.loc 1 231 0
 654 0008 00FB0230 		mla	r0, r0, r2, r3
 655 000c 7047     		bx	lr
 656              	.L72:
 657 000e 00BF     		.align	2
 658              	.L71:
 659 0010 00000000 		.word	.LANCHOR0
 660 0014 00000000 		.word	block_buffer
 661              		.cfi_endproc
 662              	.LFE709:
 664              		.section	.text.plan_get_current_block,"ax",%progbits
 665              		.align	1
 666              		.p2align 2,,3
 667              		.global	plan_get_current_block
 668              		.syntax unified
 669              		.thumb
 670              		.thumb_func
 671              		.fpu softvfp
 673              	plan_get_current_block:
 674              	.LFB710:
 232:grbl/planner.c **** 
 233:grbl/planner.c **** 
 234:grbl/planner.c **** // Returns address of first planner block, if available. Called by various main program functions.
 235:grbl/planner.c **** plan_block_t *plan_get_current_block()
 236:grbl/planner.c **** {
 675              		.loc 1 236 0
 676              		.cfi_startproc
 677              		@ args = 0, pretend = 0, frame = 0
 678              		@ frame_needed = 0, uses_anonymous_args = 0
 679              		@ link register save eliminated.
 237:grbl/planner.c ****   if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty
 680              		.loc 1 237 0
 681 0000 054B     		ldr	r3, .L76
 682 0002 064A     		ldr	r2, .L76+4
 683 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 684 0006 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 685 0008 9A42     		cmp	r2, r3
 238:grbl/planner.c ****   return(&block_buffer[block_buffer_tail]);
 686              		.loc 1 238 0
 687 000a 1DBF     		ittte	ne
 688 000c 3422     		movne	r2, #52
 689 000e 0448     		ldrne	r0, .L76+8
 690 0010 02FB0300 		mlane	r0, r2, r3, r0
 237:grbl/planner.c ****   if (block_buffer_head == block_buffer_tail) { return(NULL); } // Buffer empty
 691              		.loc 1 237 0
 692 0014 0020     		moveq	r0, #0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 18


 239:grbl/planner.c **** }
 693              		.loc 1 239 0
 694 0016 7047     		bx	lr
 695              	.L77:
 696              		.align	2
 697              	.L76:
 698 0018 00000000 		.word	.LANCHOR2
 699 001c 00000000 		.word	.LANCHOR0
 700 0020 00000000 		.word	block_buffer
 701              		.cfi_endproc
 702              	.LFE710:
 704              		.section	.text.plan_get_exec_block_exit_speed_sqr,"ax",%progbits
 705              		.align	1
 706              		.p2align 2,,3
 707              		.global	plan_get_exec_block_exit_speed_sqr
 708              		.syntax unified
 709              		.thumb
 710              		.thumb_func
 711              		.fpu softvfp
 713              	plan_get_exec_block_exit_speed_sqr:
 714              	.LFB711:
 240:grbl/planner.c **** 
 241:grbl/planner.c **** 
 242:grbl/planner.c **** float plan_get_exec_block_exit_speed_sqr()
 243:grbl/planner.c **** {
 715              		.loc 1 243 0
 716              		.cfi_startproc
 717              		@ args = 0, pretend = 0, frame = 0
 718              		@ frame_needed = 0, uses_anonymous_args = 0
 719              		@ link register save eliminated.
 720              	.LVL53:
 244:grbl/planner.c ****   uint8_t block_index = plan_next_block_index(block_buffer_tail);
 721              		.loc 1 244 0
 722 0000 094B     		ldr	r3, .L82
 245:grbl/planner.c ****   if (block_index == block_buffer_head) { return( 0.0 ); }
 723              		.loc 1 245 0
 724 0002 0A4A     		ldr	r2, .L82+4
 725              	.LBB66:
 726              	.LBB67:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 727              		.loc 1 47 0
 728 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 729              	.LBE67:
 730              	.LBE66:
 731              		.loc 1 245 0
 732 0006 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 733              	.LBB69:
 734              	.LBB68:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 735              		.loc 1 47 0
 736 0008 0133     		adds	r3, r3, #1
 737 000a DBB2     		uxtb	r3, r3
 738              	.LVL54:
  48:grbl/planner.c ****   return(block_index);
 739              		.loc 1 48 0
 740 000c C82B     		cmp	r3, #200
 741 000e 08BF     		it	eq
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 19


 742 0010 0023     		moveq	r3, #0
 743              	.LVL55:
 744              	.LBE68:
 745              	.LBE69:
 746              		.loc 1 245 0
 747 0012 9A42     		cmp	r2, r3
 748 0014 05D0     		beq	.L81
 246:grbl/planner.c ****   return( block_buffer[block_index].entry_speed_sqr );
 749              		.loc 1 246 0
 750 0016 3421     		movs	r1, #52
 751 0018 054A     		ldr	r2, .L82+8
 752 001a 01FB0323 		mla	r3, r1, r3, r2
 753 001e 5869     		ldr	r0, [r3, #20]	@ float
 754 0020 7047     		bx	lr
 755              	.L81:
 245:grbl/planner.c ****   return( block_buffer[block_index].entry_speed_sqr );
 756              		.loc 1 245 0
 757 0022 0020     		movs	r0, #0
 247:grbl/planner.c **** }
 758              		.loc 1 247 0
 759 0024 7047     		bx	lr
 760              	.L83:
 761 0026 00BF     		.align	2
 762              	.L82:
 763 0028 00000000 		.word	.LANCHOR2
 764 002c 00000000 		.word	.LANCHOR0
 765 0030 00000000 		.word	block_buffer
 766              		.cfi_endproc
 767              	.LFE711:
 769              		.section	.text.plan_check_full_buffer,"ax",%progbits
 770              		.align	1
 771              		.p2align 2,,3
 772              		.global	plan_check_full_buffer
 773              		.syntax unified
 774              		.thumb
 775              		.thumb_func
 776              		.fpu softvfp
 778              	plan_check_full_buffer:
 779              	.LFB712:
 248:grbl/planner.c **** 
 249:grbl/planner.c **** 
 250:grbl/planner.c **** // Returns the availability status of the block ring buffer. True, if full.
 251:grbl/planner.c **** uint8_t plan_check_full_buffer()
 252:grbl/planner.c **** {
 780              		.loc 1 252 0
 781              		.cfi_startproc
 782              		@ args = 0, pretend = 0, frame = 0
 783              		@ frame_needed = 0, uses_anonymous_args = 0
 784              		@ link register save eliminated.
 253:grbl/planner.c ****   if (block_buffer_tail == next_buffer_head) { return(true); }
 785              		.loc 1 253 0
 786 0000 044A     		ldr	r2, .L85
 787 0002 054B     		ldr	r3, .L85+4
 788 0004 1078     		ldrb	r0, [r2]	@ zero_extendqisi2
 789 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 254:grbl/planner.c ****   return(false);
 255:grbl/planner.c **** }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 20


 790              		.loc 1 255 0
 791 0008 C01A     		subs	r0, r0, r3
 792 000a B0FA80F0 		clz	r0, r0
 793 000e 4009     		lsrs	r0, r0, #5
 794 0010 7047     		bx	lr
 795              	.L86:
 796 0012 00BF     		.align	2
 797              	.L85:
 798 0014 00000000 		.word	.LANCHOR2
 799 0018 00000000 		.word	.LANCHOR4
 800              		.cfi_endproc
 801              	.LFE712:
 803              		.global	__aeabi_i2d
 804              		.global	__aeabi_dmul
 805              		.global	__aeabi_f2d
 806              		.global	__aeabi_d2f
 807              		.section	.text.plan_compute_profile_nominal_speed,"ax",%progbits
 808              		.align	1
 809              		.p2align 2,,3
 810              		.global	plan_compute_profile_nominal_speed
 811              		.syntax unified
 812              		.thumb
 813              		.thumb_func
 814              		.fpu softvfp
 816              	plan_compute_profile_nominal_speed:
 817              	.LFB713:
 256:grbl/planner.c **** 
 257:grbl/planner.c **** 
 258:grbl/planner.c **** // Computes and returns block nominal speed based on running condition and override values.
 259:grbl/planner.c **** // NOTE: All system motion commands, such as homing/parking, are not subject to overrides.
 260:grbl/planner.c **** float plan_compute_profile_nominal_speed(plan_block_t *block)
 261:grbl/planner.c **** {
 818              		.loc 1 261 0
 819              		.cfi_startproc
 820              		@ args = 0, pretend = 0, frame = 0
 821              		@ frame_needed = 0, uses_anonymous_args = 0
 822              	.LVL56:
 823 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 824              	.LCFI10:
 825              		.cfi_def_cfa_offset 24
 826              		.cfi_offset 3, -24
 827              		.cfi_offset 4, -20
 828              		.cfi_offset 5, -16
 829              		.cfi_offset 6, -12
 830              		.cfi_offset 7, -8
 831              		.cfi_offset 14, -4
 262:grbl/planner.c ****   float nominal_speed = block->programmed_rate;
 263:grbl/planner.c ****   if (block->condition & PL_COND_FLAG_RAPID_MOTION) { nominal_speed *= (0.01*sys.r_override); }
 832              		.loc 1 263 0
 833 0002 437C     		ldrb	r3, [r0, #17]	@ zero_extendqisi2
 262:grbl/planner.c ****   float nominal_speed = block->programmed_rate;
 834              		.loc 1 262 0
 835 0004 C46A     		ldr	r4, [r0, #44]	@ float
 836              	.LVL57:
 837              		.loc 1 263 0
 838 0006 DA07     		lsls	r2, r3, #31
 839 0008 20D5     		bpl	.L88
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 21


 840              		.loc 1 263 0 is_stmt 0 discriminator 1
 841 000a 254B     		ldr	r3, .L95+8
 842 000c 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 843              	.LVL58:
 844 000e FFF7FEFF 		bl	__aeabi_i2d
 845              	.LVL59:
 846 0012 21A3     		adr	r3, .L95
 847 0014 D3E90023 		ldrd	r2, [r3]
 848 0018 FFF7FEFF 		bl	__aeabi_dmul
 849              	.LVL60:
 850 001c 0646     		mov	r6, r0
 851 001e 2046     		mov	r0, r4
 852 0020 0F46     		mov	r7, r1
 853 0022 FFF7FEFF 		bl	__aeabi_f2d
 854              	.LVL61:
 855 0026 0246     		mov	r2, r0
 856 0028 0B46     		mov	r3, r1
 857 002a 3046     		mov	r0, r6
 858 002c 3946     		mov	r1, r7
 859 002e FFF7FEFF 		bl	__aeabi_dmul
 860              	.LVL62:
 861 0032 FFF7FEFF 		bl	__aeabi_d2f
 862              	.LVL63:
 863 0036 0446     		mov	r4, r0
 864              	.LVL64:
 865              	.L89:
 264:grbl/planner.c ****   else {
 265:grbl/planner.c ****     if (!(block->condition & PL_COND_FLAG_NO_FEED_OVERRIDE)) { nominal_speed *= (0.01*sys.f_overrid
 266:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 267:grbl/planner.c ****   }
 268:grbl/planner.c ****   if (nominal_speed > MINIMUM_FEED_RATE) { return(nominal_speed); }
 866              		.loc 1 268 0 is_stmt 1
 867 0038 4FF07E51 		mov	r1, #1065353216
 868 003c 2046     		mov	r0, r4
 869 003e FFF7FEFF 		bl	__aeabi_fcmpgt
 870              	.LVL65:
 871 0042 08B9     		cbnz	r0, .L87
 269:grbl/planner.c ****   return(MINIMUM_FEED_RATE);
 872              		.loc 1 269 0
 873 0044 4FF07E54 		mov	r4, #1065353216
 874              	.LVL66:
 875              	.L87:
 270:grbl/planner.c **** }
 876              		.loc 1 270 0
 877 0048 2046     		mov	r0, r4
 878 004a F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 879              	.LVL67:
 880              	.L88:
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 881              		.loc 1 265 0
 882 004c 5B07     		lsls	r3, r3, #29
 883 004e 0546     		mov	r5, r0
 884 0050 16D4     		bmi	.L90
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 885              		.loc 1 265 0 is_stmt 0 discriminator 1
 886 0052 134B     		ldr	r3, .L95+8
 887 0054 187A     		ldrb	r0, [r3, #8]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 22


 888              	.LVL68:
 889 0056 FFF7FEFF 		bl	__aeabi_i2d
 890              	.LVL69:
 891 005a 0FA3     		adr	r3, .L95
 892 005c D3E90023 		ldrd	r2, [r3]
 893 0060 FFF7FEFF 		bl	__aeabi_dmul
 894              	.LVL70:
 895 0064 0646     		mov	r6, r0
 896 0066 2046     		mov	r0, r4
 897 0068 0F46     		mov	r7, r1
 898 006a FFF7FEFF 		bl	__aeabi_f2d
 899              	.LVL71:
 900 006e 0246     		mov	r2, r0
 901 0070 0B46     		mov	r3, r1
 902 0072 3046     		mov	r0, r6
 903 0074 3946     		mov	r1, r7
 904 0076 FFF7FEFF 		bl	__aeabi_dmul
 905              	.LVL72:
 906 007a FFF7FEFF 		bl	__aeabi_d2f
 907              	.LVL73:
 908 007e 0446     		mov	r4, r0
 909              	.LVL74:
 910              	.L90:
 266:grbl/planner.c ****   }
 911              		.loc 1 266 0 is_stmt 1
 912 0080 AD6A     		ldr	r5, [r5, #40]	@ float
 913              	.LVL75:
 914 0082 2146     		mov	r1, r4
 915 0084 2846     		mov	r0, r5
 916 0086 FFF7FEFF 		bl	__aeabi_fcmplt
 917              	.LVL76:
 918 008a 0028     		cmp	r0, #0
 919 008c D4D0     		beq	.L89
 920 008e 2C46     		mov	r4, r5
 921              	.LVL77:
 922 0090 D2E7     		b	.L89
 923              	.L96:
 924 0092 00BFAFF3 		.align	3
 924      0080
 925              	.L95:
 926 0098 7B14AE47 		.word	1202590843
 927 009c E17A843F 		.word	1065646817
 928 00a0 00000000 		.word	sys
 929              		.cfi_endproc
 930              	.LFE713:
 932              		.section	.text.plan_update_velocity_profile_parameters,"ax",%progbits
 933              		.align	1
 934              		.p2align 2,,3
 935              		.global	plan_update_velocity_profile_parameters
 936              		.syntax unified
 937              		.thumb
 938              		.thumb_func
 939              		.fpu softvfp
 941              	plan_update_velocity_profile_parameters:
 942              	.LFB715:
 271:grbl/planner.c **** 
 272:grbl/planner.c **** 
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 23


 273:grbl/planner.c **** // Computes and updates the max entry speed (sqr) of the block, based on the minimum of the junctio
 274:grbl/planner.c **** // previous and current nominal speeds and max junction speed.
 275:grbl/planner.c **** static void plan_compute_profile_parameters(plan_block_t *block, float nominal_speed, float prev_no
 276:grbl/planner.c **** {
 277:grbl/planner.c ****   // Compute the junction maximum entry based on the minimum of the junction speed and neighboring 
 278:grbl/planner.c ****   if (nominal_speed > prev_nominal_speed) { block->max_entry_speed_sqr = prev_nominal_speed*prev_no
 279:grbl/planner.c ****   else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 280:grbl/planner.c ****   if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = bl
 281:grbl/planner.c **** }
 282:grbl/planner.c **** 
 283:grbl/planner.c **** 
 284:grbl/planner.c **** // Re-calculates buffered motions profile parameters upon a motion-based override change.
 285:grbl/planner.c **** void plan_update_velocity_profile_parameters()
 286:grbl/planner.c **** {
 943              		.loc 1 286 0
 944              		.cfi_startproc
 945              		@ args = 0, pretend = 0, frame = 24
 946              		@ frame_needed = 0, uses_anonymous_args = 0
 947 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 948              	.LCFI11:
 949              		.cfi_def_cfa_offset 36
 950              		.cfi_offset 4, -36
 951              		.cfi_offset 5, -32
 952              		.cfi_offset 6, -28
 953              		.cfi_offset 7, -24
 954              		.cfi_offset 8, -20
 955              		.cfi_offset 9, -16
 956              		.cfi_offset 10, -12
 957              		.cfi_offset 11, -8
 958              		.cfi_offset 14, -4
 287:grbl/planner.c ****   uint8_t block_index = block_buffer_tail;
 288:grbl/planner.c ****   plan_block_t *block;
 289:grbl/planner.c ****   float nominal_speed;
 290:grbl/planner.c ****   float prev_nominal_speed = SOME_LARGE_VALUE; // Set high for first block nominal speed calculatio
 291:grbl/planner.c ****   while (block_index != block_buffer_head) {
 959              		.loc 1 291 0
 960 0004 424A     		ldr	r2, .L115+8
 961              	.LBB76:
 962              	.LBB77:
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 963              		.loc 1 265 0
 964 0006 434B     		ldr	r3, .L115+12
 965              	.LBE77:
 966              	.LBE76:
 967              		.loc 1 291 0
 968 0008 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 286:grbl/planner.c ****   uint8_t block_index = block_buffer_tail;
 969              		.loc 1 286 0
 970 000a 87B0     		sub	sp, sp, #28
 971              	.LCFI12:
 972              		.cfi_def_cfa_offset 64
 287:grbl/planner.c ****   uint8_t block_index = block_buffer_tail;
 973              		.loc 1 287 0
 974 000c 4249     		ldr	r1, .L115+16
 975              		.loc 1 291 0
 976 000e 0192     		str	r2, [sp, #4]
 977              	.LBB83:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 24


 978              	.LBB78:
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 979              		.loc 1 265 0
 980 0010 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 263:grbl/planner.c ****   else {
 981              		.loc 1 263 0
 982 0012 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 983              	.LBE78:
 984              	.LBE83:
 287:grbl/planner.c ****   plan_block_t *block;
 985              		.loc 1 287 0
 986 0014 0C78     		ldrb	r4, [r1]	@ zero_extendqisi2
 987              	.LVL78:
 988              	.LBB84:
 989              	.LBB79:
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 990              		.loc 1 265 0
 991 0016 0592     		str	r2, [sp, #20]
 263:grbl/planner.c ****   else {
 992              		.loc 1 263 0
 993 0018 0493     		str	r3, [sp, #16]
 994              	.LBE79:
 995              	.LBE84:
 290:grbl/planner.c ****   while (block_index != block_buffer_head) {
 996              		.loc 1 290 0
 997 001a 404E     		ldr	r6, .L115+20
 292:grbl/planner.c ****     block = &block_buffer[block_index];
 998              		.loc 1 292 0
 999 001c 4FF0340A 		mov	r10, #52
 1000 0020 DFF800B1 		ldr	fp, .L115+28
 1001              	.LBB85:
 1002              	.LBB80:
 268:grbl/planner.c ****   return(MINIMUM_FEED_RATE);
 1003              		.loc 1 268 0
 1004 0024 4FF07E59 		mov	r9, #1065353216
 1005              	.LBE80:
 1006              	.LBE85:
 291:grbl/planner.c ****     block = &block_buffer[block_index];
 1007              		.loc 1 291 0
 1008 0028 34E0     		b	.L98
 1009              	.LVL79:
 1010              	.L114:
 1011              	.LBB86:
 1012              	.LBB81:
 263:grbl/planner.c ****   else {
 1013              		.loc 1 263 0
 1014 002a 0498     		ldr	r0, [sp, #16]
 1015 002c FFF7FEFF 		bl	__aeabi_i2d
 1016              	.LVL80:
 1017 0030 35A3     		adr	r3, .L115
 1018 0032 D3E90023 		ldrd	r2, [r3]
 1019 0036 FFF7FEFF 		bl	__aeabi_dmul
 1020              	.LVL81:
 1021 003a CDE90201 		strd	r0, [sp, #8]
 1022 003e 3846     		mov	r0, r7
 1023 0040 FFF7FEFF 		bl	__aeabi_f2d
 1024              	.LVL82:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 25


 1025 0044 0246     		mov	r2, r0
 1026 0046 0B46     		mov	r3, r1
 1027 0048 DDE90201 		ldrd	r0, [sp, #8]
 1028 004c FFF7FEFF 		bl	__aeabi_dmul
 1029              	.LVL83:
 1030 0050 FFF7FEFF 		bl	__aeabi_d2f
 1031              	.LVL84:
 1032 0054 8046     		mov	r8, r0
 1033              	.LVL85:
 1034              	.L100:
 268:grbl/planner.c ****   return(MINIMUM_FEED_RATE);
 1035              		.loc 1 268 0
 1036 0056 4946     		mov	r1, r9
 1037 0058 4046     		mov	r0, r8
 1038 005a FFF7FEFF 		bl	__aeabi_fcmpgt
 1039              	.LVL86:
 1040 005e 00B9     		cbnz	r0, .L102
 269:grbl/planner.c **** }
 1041              		.loc 1 269 0
 1042 0060 C846     		mov	r8, r9
 1043              	.LVL87:
 1044              	.L102:
 1045              	.LBE81:
 1046              	.LBE86:
 1047              	.LBB87:
 1048              	.LBB88:
 278:grbl/planner.c ****   else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 1049              		.loc 1 278 0
 1050 0062 4146     		mov	r1, r8
 1051 0064 3046     		mov	r0, r6
 1052              	.LBE88:
 1053              	.LBE87:
 293:grbl/planner.c ****     nominal_speed = plan_compute_profile_nominal_speed(block);
 294:grbl/planner.c ****     plan_compute_profile_parameters(block, nominal_speed, prev_nominal_speed);
 1054              		.loc 1 294 0
 1055 0066 6F6A     		ldr	r7, [r5, #36]	@ float
 1056              	.LVL88:
 1057              	.LBB91:
 1058              	.LBB89:
 278:grbl/planner.c ****   else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 1059              		.loc 1 278 0
 1060 0068 FFF7FEFF 		bl	__aeabi_fcmplt
 1061              	.LVL89:
 1062 006c 0028     		cmp	r0, #0
 1063 006e 40D0     		beq	.L111
 1064 0070 3146     		mov	r1, r6
 1065 0072 3046     		mov	r0, r6
 1066 0074 FFF7FEFF 		bl	__aeabi_fmul
 1067              	.LVL90:
 1068 0078 0646     		mov	r6, r0
 1069              	.LVL91:
 1070              	.L105:
 280:grbl/planner.c **** }
 1071              		.loc 1 280 0
 1072 007a 3146     		mov	r1, r6
 1073 007c 3846     		mov	r0, r7
 1074 007e FFF7FEFF 		bl	__aeabi_fcmplt
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 26


 1075              	.LVL92:
 1076 0082 0028     		cmp	r0, #0
 1077 0084 33D1     		bne	.L106
 1078 0086 AE61     		str	r6, [r5, #24]	@ float
 1079              	.L107:
 1080              	.LVL93:
 1081              	.LBE89:
 1082              	.LBE91:
 1083              	.LBB92:
 1084              	.LBB93:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 1085              		.loc 1 47 0
 1086 0088 0134     		adds	r4, r4, #1
 1087              	.LVL94:
 1088 008a E4B2     		uxtb	r4, r4
 1089              	.LVL95:
  48:grbl/planner.c ****   return(block_index);
 1090              		.loc 1 48 0
 1091 008c C82C     		cmp	r4, #200
 1092 008e 08BF     		it	eq
 1093 0090 0024     		moveq	r4, #0
 1094              	.LVL96:
 1095 0092 4646     		mov	r6, r8
 1096              	.LVL97:
 1097              	.L98:
 1098              	.LBE93:
 1099              	.LBE92:
 291:grbl/planner.c ****     block = &block_buffer[block_index];
 1100              		.loc 1 291 0
 1101 0094 019B     		ldr	r3, [sp, #4]
 1102 0096 A342     		cmp	r3, r4
 1103 0098 31D0     		beq	.L113
 292:grbl/planner.c ****     nominal_speed = plan_compute_profile_nominal_speed(block);
 1104              		.loc 1 292 0
 1105 009a 0AFB04B5 		mla	r5, r10, r4, fp
 1106              	.LVL98:
 1107              	.LBB94:
 1108              	.LBB82:
 263:grbl/planner.c ****   else {
 1109              		.loc 1 263 0
 1110 009e 6B7C     		ldrb	r3, [r5, #17]	@ zero_extendqisi2
 262:grbl/planner.c ****   if (block->condition & PL_COND_FLAG_RAPID_MOTION) { nominal_speed *= (0.01*sys.r_override); }
 1111              		.loc 1 262 0
 1112 00a0 EF6A     		ldr	r7, [r5, #44]	@ float
 1113              	.LVL99:
 263:grbl/planner.c ****   else {
 1114              		.loc 1 263 0
 1115 00a2 DA07     		lsls	r2, r3, #31
 1116 00a4 C1D4     		bmi	.L114
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 1117              		.loc 1 265 0
 1118 00a6 5B07     		lsls	r3, r3, #29
 1119 00a8 15D4     		bmi	.L101
 1120 00aa 0598     		ldr	r0, [sp, #20]
 1121 00ac FFF7FEFF 		bl	__aeabi_i2d
 1122              	.LVL100:
 1123 00b0 15A3     		adr	r3, .L115
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 27


 1124 00b2 D3E90023 		ldrd	r2, [r3]
 1125 00b6 FFF7FEFF 		bl	__aeabi_dmul
 1126              	.LVL101:
 1127 00ba CDE90201 		strd	r0, [sp, #8]
 1128 00be 3846     		mov	r0, r7
 1129 00c0 FFF7FEFF 		bl	__aeabi_f2d
 1130              	.LVL102:
 1131 00c4 0246     		mov	r2, r0
 1132 00c6 0B46     		mov	r3, r1
 1133 00c8 DDE90201 		ldrd	r0, [sp, #8]
 1134 00cc FFF7FEFF 		bl	__aeabi_dmul
 1135              	.LVL103:
 1136 00d0 FFF7FEFF 		bl	__aeabi_d2f
 1137              	.LVL104:
 1138 00d4 0746     		mov	r7, r0
 1139              	.LVL105:
 1140              	.L101:
 266:grbl/planner.c ****   }
 1141              		.loc 1 266 0
 1142 00d6 0AFB04B3 		mla	r3, r10, r4, fp
 1143 00da D3F82880 		ldr	r8, [r3, #40]	@ float
 1144 00de 3946     		mov	r1, r7
 1145 00e0 4046     		mov	r0, r8
 1146 00e2 FFF7FEFF 		bl	__aeabi_fcmplt
 1147              	.LVL106:
 1148 00e6 0028     		cmp	r0, #0
 1149 00e8 B5D1     		bne	.L100
 1150 00ea B846     		mov	r8, r7
 1151 00ec B3E7     		b	.L100
 1152              	.LVL107:
 1153              	.L106:
 1154              	.LBE82:
 1155              	.LBE94:
 1156              	.LBB95:
 1157              	.LBB90:
 280:grbl/planner.c **** }
 1158              		.loc 1 280 0
 1159 00ee AF61     		str	r7, [r5, #24]	@ float
 1160 00f0 CAE7     		b	.L107
 1161              	.LVL108:
 1162              	.L111:
 279:grbl/planner.c ****   if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = bl
 1163              		.loc 1 279 0
 1164 00f2 4146     		mov	r1, r8
 1165 00f4 4046     		mov	r0, r8
 1166 00f6 FFF7FEFF 		bl	__aeabi_fmul
 1167              	.LVL109:
 1168 00fa 0646     		mov	r6, r0
 1169              	.LVL110:
 1170 00fc BDE7     		b	.L105
 1171              	.LVL111:
 1172              	.L113:
 1173              	.LBE90:
 1174              	.LBE95:
 295:grbl/planner.c ****     prev_nominal_speed = nominal_speed;
 296:grbl/planner.c ****     block_index = plan_next_block_index(block_index);
 297:grbl/planner.c ****   }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 28


 298:grbl/planner.c ****   pl.previous_nominal_speed = prev_nominal_speed; // Update prev nominal speed for next incoming bl
 1175              		.loc 1 298 0
 1176 00fe 084B     		ldr	r3, .L115+24
 1177 0100 9E61     		str	r6, [r3, #24]	@ float
 299:grbl/planner.c **** }
 1178              		.loc 1 299 0
 1179 0102 07B0     		add	sp, sp, #28
 1180              	.LCFI13:
 1181              		.cfi_def_cfa_offset 36
 1182              		@ sp needed
 1183 0104 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1184              	.LVL112:
 1185              	.L116:
 1186              		.align	3
 1187              	.L115:
 1188 0108 7B14AE47 		.word	1202590843
 1189 010c E17A843F 		.word	1065646817
 1190 0110 00000000 		.word	.LANCHOR0
 1191 0114 00000000 		.word	sys
 1192 0118 00000000 		.word	.LANCHOR2
 1193 011c FFFF7F7F 		.word	2139095039
 1194 0120 00000000 		.word	.LANCHOR3
 1195 0124 00000000 		.word	block_buffer
 1196              		.cfi_endproc
 1197              	.LFE715:
 1199              		.global	__aeabi_i2f
 1200              		.global	__aeabi_fdiv
 1201              		.global	__aeabi_fsub
 1202              		.global	__aeabi_dcmpgt
 1203              		.global	__aeabi_dcmplt
 1204              		.global	__aeabi_dsub
 1205              		.global	__aeabi_ddiv
 1206              		.section	.text.plan_buffer_line,"ax",%progbits
 1207              		.align	1
 1208              		.p2align 2,,3
 1209              		.global	plan_buffer_line
 1210              		.syntax unified
 1211              		.thumb
 1212              		.thumb_func
 1213              		.fpu softvfp
 1215              	plan_buffer_line:
 1216              	.LFB716:
 300:grbl/planner.c **** 
 301:grbl/planner.c **** 
 302:grbl/planner.c **** /* Add a new linear movement to the buffer. target[N_AXIS] is the signed, absolute target position
 303:grbl/planner.c ****    in millimeters. Feed rate specifies the speed of the motion. If feed rate is inverted, the feed
 304:grbl/planner.c ****    rate is taken to mean "frequency" and would complete the operation in 1/feed_rate minutes.
 305:grbl/planner.c ****    All position data passed to the planner must be in terms of machine position to keep the planner
 306:grbl/planner.c ****    independent of any coordinate system changes and offsets, which are handled by the g-code parser
 307:grbl/planner.c ****    NOTE: Assumes buffer is available. Buffer checks are handled at a higher level by motion_control
 308:grbl/planner.c ****    In other words, the buffer head is never equal to the buffer tail.  Also the feed rate input val
 309:grbl/planner.c ****    is used in three ways: as a normal feed rate if invert_feed_rate is false, as inverse time if
 310:grbl/planner.c ****    invert_feed_rate is true, or as seek/rapids rate if the feed_rate value is negative (and
 311:grbl/planner.c ****    invert_feed_rate always false).
 312:grbl/planner.c ****    The system motion condition tells the planner to plan a motion in the always unused block buffer
 313:grbl/planner.c ****    head. It avoids changing the planner state and preserves the buffer to ensure subsequent gcode
 314:grbl/planner.c ****    motions are still planned correctly, while the stepper module only points to the block buffer he
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 29


 315:grbl/planner.c ****    to execute the special system motion. */
 316:grbl/planner.c **** uint8_t plan_buffer_line(float *target, plan_line_data_t *pl_data)
 317:grbl/planner.c **** {
 1217              		.loc 1 317 0
 1218              		.cfi_startproc
 1219              		@ args = 0, pretend = 0, frame = 56
 1220              		@ frame_needed = 0, uses_anonymous_args = 0
 1221              	.LVL113:
 318:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 319:grbl/planner.c ****   plan_block_t *block = &block_buffer[block_buffer_head];
 1222              		.loc 1 319 0
 1223 0000 3422     		movs	r2, #52
 317:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 1224              		.loc 1 317 0
 1225 0002 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 1226              	.LCFI14:
 1227              		.cfi_def_cfa_offset 36
 1228              		.cfi_offset 4, -36
 1229              		.cfi_offset 5, -32
 1230              		.cfi_offset 6, -28
 1231              		.cfi_offset 7, -24
 1232              		.cfi_offset 8, -20
 1233              		.cfi_offset 9, -16
 1234              		.cfi_offset 10, -12
 1235              		.cfi_offset 11, -8
 1236              		.cfi_offset 14, -4
 1237 0006 0C46     		mov	r4, r1
 1238              		.loc 1 319 0
 1239 0008 A14B     		ldr	r3, .L164+16
 317:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 1240              		.loc 1 317 0
 1241 000a 8346     		mov	fp, r0
 1242              		.loc 1 319 0
 1243 000c 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1244 000e A148     		ldr	r0, .L164+20
 1245              	.LVL114:
 317:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 1246              		.loc 1 317 0
 1247 0010 8FB0     		sub	sp, sp, #60
 1248              	.LCFI15:
 1249              		.cfi_def_cfa_offset 96
 1250              		.loc 1 319 0
 1251 0012 02FB030A 		mla	r10, r2, r3, r0
 1252              	.LVL115:
 317:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 1253              		.loc 1 317 0
 1254 0016 0191     		str	r1, [sp, #4]
 320:grbl/planner.c ****   memset(block,0,sizeof(plan_block_t)); // Zero all block values.
 1255              		.loc 1 320 0
 1256 0018 5046     		mov	r0, r10
 1257 001a 0021     		movs	r1, #0
 1258              	.LVL116:
 319:grbl/planner.c ****   memset(block,0,sizeof(plan_block_t)); // Zero all block values.
 1259              		.loc 1 319 0
 1260 001c 0093     		str	r3, [sp]
 1261              		.loc 1 320 0
 1262 001e FFF7FEFF 		bl	memset
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 30


 1263              	.LVL117:
 321:grbl/planner.c ****   block->condition = pl_data->condition;
 1264              		.loc 1 321 0
 1265 0022 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 322:grbl/planner.c ****   #ifdef VARIABLE_SPINDLE
 323:grbl/planner.c ****     block->spindle_speed = pl_data->spindle_speed;
 1266              		.loc 1 323 0
 1267 0024 6268     		ldr	r2, [r4, #4]	@ float
 321:grbl/planner.c ****   block->condition = pl_data->condition;
 1268              		.loc 1 321 0
 1269 0026 8AF81130 		strb	r3, [r10, #17]
 324:grbl/planner.c ****   #endif
 325:grbl/planner.c ****   #ifdef USE_LINE_NUMBERS
 326:grbl/planner.c ****     block->line_number = pl_data->line_number;
 327:grbl/planner.c ****   #endif
 328:grbl/planner.c **** 
 329:grbl/planner.c ****   // Compute and store initial move distance data.
 330:grbl/planner.c ****   int32_t target_steps[N_AXIS], position_steps[N_AXIS];
 331:grbl/planner.c ****   float unit_vec[N_AXIS], delta_mm;
 332:grbl/planner.c ****   uint8_t idx;
 333:grbl/planner.c **** 
 334:grbl/planner.c ****   // Copy position data based on type of motion being planned.
 335:grbl/planner.c ****   if (block->condition & PL_COND_FLAG_SYSTEM_MOTION) { 
 1270              		.loc 1 335 0
 1271 002a 9B07     		lsls	r3, r3, #30
 336:grbl/planner.c ****     #ifdef COREXY
 337:grbl/planner.c ****       position_steps[X_AXIS] = system_convert_corexy_to_x_axis_steps(sys_position);
 338:grbl/planner.c ****       position_steps[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
 339:grbl/planner.c ****       position_steps[Z_AXIS] = sys_position[Z_AXIS];
 340:grbl/planner.c ****     #else
 341:grbl/planner.c ****       memcpy(position_steps, sys_position, sizeof(sys_position)); 
 1272              		.loc 1 341 0
 1273 002c 4CBF     		ite	mi
 1274 002e 9A4B     		ldrmi	r3, .L164+24
 342:grbl/planner.c ****     #endif
 343:grbl/planner.c ****   } else { memcpy(position_steps, pl.position, sizeof(pl.position)); }
 1275              		.loc 1 343 0
 1276 0030 9A4B     		ldrpl	r3, .L164+28
 323:grbl/planner.c ****   #endif
 1277              		.loc 1 323 0
 1278 0032 CAF83020 		str	r2, [r10, #48]	@ float
 1279              		.loc 1 343 0
 1280 0036 0DF11408 		add	r8, sp, #20
 1281 003a 93E80700 		ldm	r3, {r0, r1, r2}
 1282 003e 88E80700 		stm	r8, {r0, r1, r2}
 344:grbl/planner.c **** 
 345:grbl/planner.c ****   #ifdef COREXY
 346:grbl/planner.c ****     target_steps[A_MOTOR] = lround(target[A_MOTOR]*settings.steps_per_mm[A_MOTOR]);
 347:grbl/planner.c ****     target_steps[B_MOTOR] = lround(target[B_MOTOR]*settings.steps_per_mm[B_MOTOR]);
 348:grbl/planner.c ****     block->steps[A_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) + (target_steps[Y_AX
 349:grbl/planner.c ****     block->steps[B_MOTOR] = labs((target_steps[X_AXIS]-position_steps[X_AXIS]) - (target_steps[Y_AX
 350:grbl/planner.c ****   #endif
 351:grbl/planner.c **** 
 352:grbl/planner.c ****   for (idx=0; idx<N_AXIS; idx++) {
 353:grbl/planner.c ****     // Calculate target position in absolute steps, number of steps for each axis, and determine ma
 354:grbl/planner.c ****     // Also, compute individual axes distance for move and prep unit vector calculations.
 355:grbl/planner.c ****     // NOTE: Computes true distance from converted step values.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 31


 356:grbl/planner.c ****     #ifdef COREXY
 357:grbl/planner.c ****       if ( !(idx == A_MOTOR) && !(idx == B_MOTOR) ) {
 358:grbl/planner.c ****         target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
 359:grbl/planner.c ****         block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 360:grbl/planner.c ****       }
 361:grbl/planner.c ****       block->step_event_count = max(block->step_event_count, block->steps[idx]);
 362:grbl/planner.c ****       if (idx == A_MOTOR) {
 363:grbl/planner.c ****         delta_mm = (target_steps[X_AXIS]-position_steps[X_AXIS] + target_steps[Y_AXIS]-position_ste
 364:grbl/planner.c ****       } else if (idx == B_MOTOR) {
 365:grbl/planner.c ****         delta_mm = (target_steps[X_AXIS]-position_steps[X_AXIS] - target_steps[Y_AXIS]+position_ste
 366:grbl/planner.c ****       } else {
 367:grbl/planner.c ****         delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
 368:grbl/planner.c ****       }
 369:grbl/planner.c ****     #else
 370:grbl/planner.c ****       target_steps[idx] = lround(target[idx]*settings.steps_per_mm[idx]);
 371:grbl/planner.c ****       block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 372:grbl/planner.c ****       block->step_event_count = max(block->step_event_count, block->steps[idx]);
 1283              		.loc 1 372 0
 1284 0042 009A     		ldr	r2, [sp]
 1285 0044 3423     		movs	r3, #52
 1286 0046 1146     		mov	r1, r2
 1287 0048 5746     		mov	r7, r10
 317:grbl/planner.c ****   // Prepare and initialize new block. Copy relevant pl_data for block execution.
 1288              		.loc 1 317 0
 1289 004a 0025     		movs	r5, #0
 1290              		.loc 1 372 0
 1291 004c 914A     		ldr	r2, .L164+20
 1292 004e 944E     		ldr	r6, .L164+32
 1293 0050 03FB0129 		mla	r9, r3, r1, r2
 1294 0054 ABF1040B 		sub	fp, fp, #4
 1295              	.LVL118:
 1296              	.L122:
 370:grbl/planner.c ****       block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 1297              		.loc 1 370 0
 1298 0058 5BF8041F 		ldr	r1, [fp, #4]!	@ float
 1299 005c 3068     		ldr	r0, [r6]	@ float
 1300 005e FFF7FEFF 		bl	__aeabi_fmul
 1301              	.LVL119:
 1302 0062 FFF7FEFF 		bl	__aeabi_f2d
 1303              	.LVL120:
 1304 0066 FFF7FEFF 		bl	lround
 1305              	.LVL121:
 371:grbl/planner.c ****       block->step_event_count = max(block->step_event_count, block->steps[idx]);
 1306              		.loc 1 371 0
 1307 006a 58F82530 		ldr	r3, [r8, r5, lsl #2]
 370:grbl/planner.c ****       block->steps[idx] = labs(target_steps[idx]-position_steps[idx]);
 1308              		.loc 1 370 0
 1309 006e 02AA     		add	r2, sp, #8
 1310 0070 42F82500 		str	r0, [r2, r5, lsl #2]
 371:grbl/planner.c ****       block->step_event_count = max(block->step_event_count, block->steps[idx]);
 1311              		.loc 1 371 0
 1312 0074 C01A     		subs	r0, r0, r3
 1313 0076 80EAE074 		eor	r4, r0, r0, asr #31
 1314 007a A4EBE074 		sub	r4, r4, r0, asr #31
 1315 007e 47F8044B 		str	r4, [r7], #4
 1316              		.loc 1 372 0
 1317 0082 D9F80C30 		ldr	r3, [r9, #12]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 32


 1318 0086 9C42     		cmp	r4, r3
 1319 0088 38BF     		it	cc
 1320 008a 1C46     		movcc	r4, r3
 1321 008c C9F80C40 		str	r4, [r9, #12]
 373:grbl/planner.c ****       delta_mm = (target_steps[idx] - position_steps[idx])/settings.steps_per_mm[idx];
 1322              		.loc 1 373 0
 1323 0090 FFF7FEFF 		bl	__aeabi_i2f
 1324              	.LVL122:
 1325 0094 56F8041B 		ldr	r1, [r6], #4	@ float
 1326 0098 FFF7FEFF 		bl	__aeabi_fdiv
 1327              	.LVL123:
 374:grbl/planner.c **** 	  #endif
 375:grbl/planner.c ****     unit_vec[idx] = delta_mm; // Store unit vector numerator
 1328              		.loc 1 375 0
 1329 009c 08AB     		add	r3, sp, #32
 376:grbl/planner.c **** 
 377:grbl/planner.c ****     // Set direction bits. Bit enabled always means direction is negative.
 378:grbl/planner.c ****     if (delta_mm < 0.0 )
 1330              		.loc 1 378 0
 1331 009e 0021     		movs	r1, #0
 375:grbl/planner.c **** 
 1332              		.loc 1 375 0
 1333 00a0 43F82500 		str	r0, [r3, r5, lsl #2]	@ float
 1334              		.loc 1 378 0
 1335 00a4 FFF7FEFF 		bl	__aeabi_fcmplt
 1336              	.LVL124:
 1337 00a8 38B1     		cbz	r0, .L120
 379:grbl/planner.c ****     {
 380:grbl/planner.c ****       #ifdef STM32
 381:grbl/planner.c ****         block->direction_bits |= direction_pin_mask[idx];
 1338              		.loc 1 381 0
 1339 00aa 7E4A     		ldr	r2, .L164+36
 1340 00ac 99F81030 		ldrb	r3, [r9, #16]	@ zero_extendqisi2
 1341 00b0 12F81520 		ldrb	r2, [r2, r5, lsl #1]	@ zero_extendqisi2
 1342 00b4 1343     		orrs	r3, r3, r2
 1343 00b6 89F81030 		strb	r3, [r9, #16]
 1344              	.L120:
 1345 00ba 0135     		adds	r5, r5, #1
 1346              	.LVL125:
 352:grbl/planner.c ****     // Calculate target position in absolute steps, number of steps for each axis, and determine ma
 1347              		.loc 1 352 0 discriminator 2
 1348 00bc 032D     		cmp	r5, #3
 1349 00be CBD1     		bne	.L122
 382:grbl/planner.c ****       #endif
 383:grbl/planner.c ****     }
 384:grbl/planner.c ****   }
 385:grbl/planner.c **** 
 386:grbl/planner.c ****   // Bail if this is a zero-length block. Highly unlikely to occur.
 387:grbl/planner.c ****   if (block->step_event_count == 0) { return(PLAN_EMPTY_BLOCK); }
 1350              		.loc 1 387 0
 1351 00c0 1CB9     		cbnz	r4, .L163
 1352 00c2 2046     		mov	r0, r4
 388:grbl/planner.c **** 
 389:grbl/planner.c ****   // Calculate the unit vector of the line move and the block maximum feed rate and acceleration sc
 390:grbl/planner.c ****   // down such that no individual axes maximum values are exceeded with respect to the line directi
 391:grbl/planner.c ****   // NOTE: This calculation assumes all axes are orthogonal (Cartesian) and works with ABC-axes,
 392:grbl/planner.c ****   // if they are also orthogonal/independent. Operates on the absolute value of the unit vector.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 33


 393:grbl/planner.c ****   block->millimeters = convert_delta_vector_to_unit_vector(unit_vec);
 394:grbl/planner.c **** #ifdef ENABLE_ACCEL_SCALING
 395:grbl/planner.c ****   block->pbacceleration = limit_value_by_axis_maximum(adjustments.accel_adjusted, unit_vec);
 396:grbl/planner.c **** #else
 397:grbl/planner.c ****   block->pbacceleration = limit_value_by_axis_maximum(settings.eeacceleration, unit_vec);
 398:grbl/planner.c **** #endif
 399:grbl/planner.c ****   block->rapid_rate = limit_value_by_axis_maximum(settings.max_rate, unit_vec);
 400:grbl/planner.c **** 
 401:grbl/planner.c ****   // Store programmed rate.
 402:grbl/planner.c ****   if (block->condition & PL_COND_FLAG_RAPID_MOTION) { block->programmed_rate = block->rapid_rate; }
 403:grbl/planner.c ****   else { 
 404:grbl/planner.c ****     block->programmed_rate = pl_data->feed_rate;
 405:grbl/planner.c ****     if (block->condition & PL_COND_FLAG_INVERSE_TIME) { block->programmed_rate *= block->millimeter
 406:grbl/planner.c ****   }
 407:grbl/planner.c **** 
 408:grbl/planner.c ****   // TODO: Need to check this method handling zero junction speeds when starting from rest.
 409:grbl/planner.c ****   if ((block_buffer_head == block_buffer_tail) || (block->condition & PL_COND_FLAG_SYSTEM_MOTION)) 
 410:grbl/planner.c **** 
 411:grbl/planner.c ****     // Initialize block entry speed as zero. Assume it will be starting from rest. Planner will cor
 412:grbl/planner.c ****     // If system motion, the system motion block always is assumed to start from rest and end at a 
 413:grbl/planner.c ****     block->entry_speed_sqr = 0.0;
 414:grbl/planner.c ****     block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
 415:grbl/planner.c **** 
 416:grbl/planner.c ****   } else {
 417:grbl/planner.c ****     // Compute maximum allowable entry speed at junction by centripetal acceleration approximation.
 418:grbl/planner.c ****     // Let a circle be tangent to both previous and current path line segments, where the junction
 419:grbl/planner.c ****     // deviation is defined as the distance from the junction to the closest edge of the circle,
 420:grbl/planner.c ****     // colinear with the circle center. The circular segment joining the two paths represents the
 421:grbl/planner.c ****     // path of centripetal acceleration. Solve for max velocity based on max acceleration about the
 422:grbl/planner.c ****     // radius of the circle, defined indirectly by junction deviation. This may be also viewed as
 423:grbl/planner.c ****     // path width or max_jerk in the previous Grbl version. This approach does not actually deviate
 424:grbl/planner.c ****     // from path, but used as a robust way to compute cornering speeds, as it takes into account th
 425:grbl/planner.c ****     // nonlinearities of both the junction angle and junction velocity.
 426:grbl/planner.c ****     //
 427:grbl/planner.c ****     // NOTE: If the junction deviation value is finite, Grbl executes the motions in an exact path
 428:grbl/planner.c ****     // mode (G61). If the junction deviation value is zero, Grbl will execute the motion in an exac
 429:grbl/planner.c ****     // stop mode (G61.1) manner. In the future, if continuous mode (G64) is desired, the math here
 430:grbl/planner.c ****     // is exactly the same. Instead of motioning all the way to junction point, the machine will
 431:grbl/planner.c ****     // just follow the arc circle defined here. The Arduino doesn't have the CPU cycles to perform
 432:grbl/planner.c ****     // a continuous mode path, but ARM-based microcontrollers most certainly do.
 433:grbl/planner.c ****     //
 434:grbl/planner.c ****     // NOTE: The max junction speed is a fixed value, since machine acceleration limits cannot be
 435:grbl/planner.c ****     // changed dynamically during operation nor can the line move geometry. This must be kept in
 436:grbl/planner.c ****     // memory in the event of a feedrate override changing the nominal speeds of blocks, which can
 437:grbl/planner.c ****     // change the overall maximum entry speed conditions of all blocks.
 438:grbl/planner.c **** 
 439:grbl/planner.c ****     float junction_unit_vec[N_AXIS];
 440:grbl/planner.c ****     float junction_cos_theta = 0.0;
 441:grbl/planner.c ****     for (idx=0; idx<N_AXIS; idx++) {
 442:grbl/planner.c ****       junction_cos_theta -= pl.previous_unit_vec[idx]*unit_vec[idx];
 443:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 444:grbl/planner.c ****     }
 445:grbl/planner.c **** 
 446:grbl/planner.c ****     // NOTE: Computed without any expensive trig, sin() or acos(), by trig half angle identity of c
 447:grbl/planner.c ****     if (junction_cos_theta > 0.999999) {
 448:grbl/planner.c ****       //  For a 0 degree acute junction, just set minimum junction speed.
 449:grbl/planner.c ****       block->max_junction_speed_sqr = MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED;
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 34


 450:grbl/planner.c ****     } else {
 451:grbl/planner.c ****       if (junction_cos_theta < -0.999999) {
 452:grbl/planner.c ****         // Junction is a straight line or 180 degrees. Junction speed is infinite.
 453:grbl/planner.c ****         block->max_junction_speed_sqr = SOME_LARGE_VALUE;
 454:grbl/planner.c ****       } else {
 455:grbl/planner.c ****         convert_delta_vector_to_unit_vector(junction_unit_vec);
 456:grbl/planner.c **** 
 457:grbl/planner.c **** 				#ifdef ENABLE_ACCEL_SCALING
 458:grbl/planner.c ****         	float junction_acceleration = limit_value_by_axis_maximum(adjustments.accel_adjusted, junc
 459:grbl/planner.c **** 				#else
 460:grbl/planner.c ****         	float junction_acceleration = limit_value_by_axis_maximum(settings.eeacceleration, junctio
 461:grbl/planner.c **** 				#endif
 462:grbl/planner.c **** 
 463:grbl/planner.c ****         	float sin_theta_d2 = sqrtf(0.5*(1.0-junction_cos_theta)); // Trig half angle identity. Alw
 464:grbl/planner.c ****         block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
 465:grbl/planner.c ****                        (junction_acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-si
 466:grbl/planner.c ****       }
 467:grbl/planner.c ****     }
 468:grbl/planner.c ****   }
 469:grbl/planner.c **** 
 470:grbl/planner.c ****   // Block system motion from updating this data to ensure next g-code motion is computed correctly
 471:grbl/planner.c ****   if (!(block->condition & PL_COND_FLAG_SYSTEM_MOTION)) {
 472:grbl/planner.c ****     float nominal_speed = plan_compute_profile_nominal_speed(block);
 473:grbl/planner.c ****     plan_compute_profile_parameters(block, nominal_speed, pl.previous_nominal_speed);
 474:grbl/planner.c ****     pl.previous_nominal_speed = nominal_speed;
 475:grbl/planner.c **** 
 476:grbl/planner.c ****     // Update previous path unit_vector and planner position.
 477:grbl/planner.c ****     memcpy(pl.previous_unit_vec, unit_vec, sizeof(unit_vec)); // pl.previous_unit_vec[] = unit_vec[
 478:grbl/planner.c ****     memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 479:grbl/planner.c **** 
 480:grbl/planner.c ****     // New block is all set. Update buffer head and next buffer head indices.
 481:grbl/planner.c ****     block_buffer_head = next_buffer_head;
 482:grbl/planner.c ****     next_buffer_head = plan_next_block_index(block_buffer_head);
 483:grbl/planner.c **** 
 484:grbl/planner.c ****     // Finish up by recalculating the plan with the new block.
 485:grbl/planner.c ****     planner_recalculate();
 486:grbl/planner.c ****   }
 487:grbl/planner.c ****   return(PLAN_OK);
 488:grbl/planner.c **** }
 1353              		.loc 1 488 0
 1354 00c4 0FB0     		add	sp, sp, #60
 1355              	.LCFI16:
 1356              		.cfi_remember_state
 1357              		.cfi_def_cfa_offset 36
 1358              		@ sp needed
 1359 00c6 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1360              	.LVL126:
 1361              	.L163:
 1362              	.LCFI17:
 1363              		.cfi_restore_state
 393:grbl/planner.c **** #ifdef ENABLE_ACCEL_SCALING
 1364              		.loc 1 393 0
 1365 00ca 08A8     		add	r0, sp, #32
 1366 00cc FFF7FEFF 		bl	convert_delta_vector_to_unit_vector
 1367              	.LVL127:
 1368 00d0 009B     		ldr	r3, [sp]
 1369 00d2 3424     		movs	r4, #52
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 35


 1370 00d4 1A46     		mov	r2, r3
 1371 00d6 6F4B     		ldr	r3, .L164+20
 395:grbl/planner.c **** #else
 1372              		.loc 1 395 0
 1373 00d8 08A9     		add	r1, sp, #32
 393:grbl/planner.c **** #ifdef ENABLE_ACCEL_SCALING
 1374              		.loc 1 393 0
 1375 00da 04FB0234 		mla	r4, r4, r2, r3
 1376 00de 2062     		str	r0, [r4, #32]	@ float
 395:grbl/planner.c **** #else
 1377              		.loc 1 395 0
 1378 00e0 7148     		ldr	r0, .L164+40
 1379 00e2 FFF7FEFF 		bl	limit_value_by_axis_maximum
 1380              	.LVL128:
 399:grbl/planner.c **** 
 1381              		.loc 1 399 0
 1382 00e6 08A9     		add	r1, sp, #32
 395:grbl/planner.c **** #else
 1383              		.loc 1 395 0
 1384 00e8 E061     		str	r0, [r4, #28]	@ float
 399:grbl/planner.c **** 
 1385              		.loc 1 399 0
 1386 00ea 7048     		ldr	r0, .L164+44
 1387 00ec FFF7FEFF 		bl	limit_value_by_axis_maximum
 1388              	.LVL129:
 402:grbl/planner.c ****   else { 
 1389              		.loc 1 402 0
 1390 00f0 657C     		ldrb	r5, [r4, #17]	@ zero_extendqisi2
 399:grbl/planner.c **** 
 1391              		.loc 1 399 0
 1392 00f2 A062     		str	r0, [r4, #40]	@ float
 402:grbl/planner.c ****   else { 
 1393              		.loc 1 402 0
 1394 00f4 EF07     		lsls	r7, r5, #31
 1395 00f6 72D5     		bpl	.L124
 1396              	.L162:
 405:grbl/planner.c ****   }
 1397              		.loc 1 405 0 discriminator 1
 1398 00f8 E062     		str	r0, [r4, #44]	@ float
 1399              	.L125:
 409:grbl/planner.c **** 
 1400              		.loc 1 409 0
 1401 00fa 6D4B     		ldr	r3, .L164+48
 1402 00fc 644A     		ldr	r2, .L164+16
 1403 00fe 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1404 0100 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1405 0102 9A42     		cmp	r2, r3
 1406 0104 01D0     		beq	.L126
 409:grbl/planner.c **** 
 1407              		.loc 1 409 0 is_stmt 0 discriminator 1
 1408 0106 AC07     		lsls	r4, r5, #30
 1409 0108 76D5     		bpl	.L127
 1410              	.L126:
 413:grbl/planner.c ****     block->max_junction_speed_sqr = 0.0; // Starting from rest. Enforce start from zero velocity.
 1411              		.loc 1 413 0 is_stmt 1
 1412 010a 009A     		ldr	r2, [sp]
 1413 010c 3423     		movs	r3, #52
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 36


 1414 010e 1146     		mov	r1, r2
 1415 0110 604A     		ldr	r2, .L164+20
 1416 0112 03FB0123 		mla	r3, r3, r1, r2
 1417 0116 0022     		movs	r2, #0
 1418 0118 5A61     		str	r2, [r3, #20]	@ float
 414:grbl/planner.c **** 
 1419              		.loc 1 414 0
 1420 011a 5A62     		str	r2, [r3, #36]	@ float
 1421              	.L128:
 471:grbl/planner.c ****     float nominal_speed = plan_compute_profile_nominal_speed(block);
 1422              		.loc 1 471 0
 1423 011c 009A     		ldr	r2, [sp]
 1424 011e 3423     		movs	r3, #52
 1425 0120 1146     		mov	r1, r2
 1426 0122 5C4A     		ldr	r2, .L164+20
 1427 0124 03FB0123 		mla	r3, r3, r1, r2
 1428 0128 5A7C     		ldrb	r2, [r3, #17]	@ zero_extendqisi2
 1429 012a 9007     		lsls	r0, r2, #30
 1430 012c 60D4     		bmi	.L148
 1431              	.LVL130:
 1432              	.LBB105:
 1433              	.LBB106:
 1434              	.LBB107:
 263:grbl/planner.c ****   else {
 1435              		.loc 1 263 0
 1436 012e D107     		lsls	r1, r2, #31
 262:grbl/planner.c ****   if (block->condition & PL_COND_FLAG_RAPID_MOTION) { nominal_speed *= (0.01*sys.r_override); }
 1437              		.loc 1 262 0
 1438 0130 DE6A     		ldr	r6, [r3, #44]	@ float
 1439              	.LVL131:
 263:grbl/planner.c ****   else {
 1440              		.loc 1 263 0
 1441 0132 40F1C580 		bpl	.L135
 1442 0136 5F4B     		ldr	r3, .L164+52
 1443 0138 587A     		ldrb	r0, [r3, #9]	@ zero_extendqisi2
 1444 013a FFF7FEFF 		bl	__aeabi_i2d
 1445              	.LVL132:
 1446 013e 50A3     		adr	r3, .L164
 1447 0140 D3E90023 		ldrd	r2, [r3]
 1448 0144 FFF7FEFF 		bl	__aeabi_dmul
 1449              	.LVL133:
 1450 0148 0446     		mov	r4, r0
 1451 014a 3046     		mov	r0, r6
 1452 014c 0D46     		mov	r5, r1
 1453 014e FFF7FEFF 		bl	__aeabi_f2d
 1454              	.LVL134:
 1455 0152 0246     		mov	r2, r0
 1456 0154 0B46     		mov	r3, r1
 1457 0156 2046     		mov	r0, r4
 1458 0158 2946     		mov	r1, r5
 1459 015a FFF7FEFF 		bl	__aeabi_dmul
 1460              	.LVL135:
 1461 015e FFF7FEFF 		bl	__aeabi_d2f
 1462              	.LVL136:
 1463 0162 0646     		mov	r6, r0
 1464              	.LVL137:
 1465              	.L136:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 37


 268:grbl/planner.c ****   return(MINIMUM_FEED_RATE);
 1466              		.loc 1 268 0
 1467 0164 4FF07E51 		mov	r1, #1065353216
 1468 0168 3046     		mov	r0, r6
 1469 016a FFF7FEFF 		bl	__aeabi_fcmpgt
 1470              	.LVL138:
 1471 016e 08B9     		cbnz	r0, .L139
 269:grbl/planner.c **** }
 1472              		.loc 1 269 0
 1473 0170 4FF07E56 		mov	r6, #1065353216
 1474              	.LVL139:
 1475              	.L139:
 1476              	.LBE107:
 1477              	.LBE106:
 473:grbl/planner.c ****     pl.previous_nominal_speed = nominal_speed;
 1478              		.loc 1 473 0
 1479 0174 494C     		ldr	r4, .L164+28
 1480              	.LBB109:
 1481              	.LBB110:
 278:grbl/planner.c ****   else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 1482              		.loc 1 278 0
 1483 0176 3146     		mov	r1, r6
 1484              	.LBE110:
 1485              	.LBE109:
 473:grbl/planner.c ****     pl.previous_nominal_speed = nominal_speed;
 1486              		.loc 1 473 0
 1487 0178 A769     		ldr	r7, [r4, #24]	@ float
 1488 017a DAF82450 		ldr	r5, [r10, #36]	@ float
 1489              	.LVL140:
 1490              	.LBB113:
 1491              	.LBB111:
 278:grbl/planner.c ****   else { block->max_entry_speed_sqr = nominal_speed*nominal_speed; }
 1492              		.loc 1 278 0
 1493 017e 3846     		mov	r0, r7
 1494 0180 FFF7FEFF 		bl	__aeabi_fcmplt
 1495              	.LVL141:
 1496 0184 0028     		cmp	r0, #0
 1497 0186 00F0C780 		beq	.L160
 1498 018a 3946     		mov	r1, r7
 1499 018c 3846     		mov	r0, r7
 1500 018e FFF7FEFF 		bl	__aeabi_fmul
 1501              	.LVL142:
 1502 0192 0746     		mov	r7, r0
 1503              	.LVL143:
 1504              	.L142:
 280:grbl/planner.c **** }
 1505              		.loc 1 280 0
 1506 0194 2946     		mov	r1, r5
 1507 0196 3846     		mov	r0, r7
 1508 0198 FFF7FEFF 		bl	__aeabi_fcmpgt
 1509              	.LVL144:
 1510 019c 0028     		cmp	r0, #0
 1511 019e 40F0B880 		bne	.L143
 1512 01a2 CAF81870 		str	r7, [r10, #24]	@ float
 1513              	.L144:
 1514              	.LBE111:
 1515              	.LBE113:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 38


 481:grbl/planner.c ****     next_buffer_head = plan_next_block_index(block_buffer_head);
 1516              		.loc 1 481 0
 1517 01a6 444A     		ldr	r2, .L164+56
 1518 01a8 3948     		ldr	r0, .L164+16
 1519 01aa 1178     		ldrb	r1, [r2]	@ zero_extendqisi2
 477:grbl/planner.c ****     memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 1520              		.loc 1 477 0
 1521 01ac 434D     		ldr	r5, .L164+60
 1522              	.LBB114:
 1523              	.LBB115:
  47:grbl/planner.c ****   if (block_index == BLOCK_BUFFER_SIZE) { block_index = 0; }
 1524              		.loc 1 47 0
 1525 01ae 4B1C     		adds	r3, r1, #1
 1526 01b0 DBB2     		uxtb	r3, r3
  48:grbl/planner.c ****   return(block_index);
 1527              		.loc 1 48 0
 1528 01b2 C82B     		cmp	r3, #200
 1529 01b4 08BF     		it	eq
 1530 01b6 0023     		moveq	r3, #0
 1531              	.LBE115:
 1532              	.LBE114:
 482:grbl/planner.c **** 
 1533              		.loc 1 482 0
 1534 01b8 1370     		strb	r3, [r2]
 477:grbl/planner.c ****     memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 1535              		.loc 1 477 0
 1536 01ba 08AB     		add	r3, sp, #32
 481:grbl/planner.c ****     next_buffer_head = plan_next_block_index(block_buffer_head);
 1537              		.loc 1 481 0
 1538 01bc 0170     		strb	r1, [r0]
 477:grbl/planner.c ****     memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 1539              		.loc 1 477 0
 1540 01be 93E80700 		ldm	r3, {r0, r1, r2}
 478:grbl/planner.c **** 
 1541              		.loc 1 478 0
 1542 01c2 02AB     		add	r3, sp, #8
 474:grbl/planner.c **** 
 1543              		.loc 1 474 0
 1544 01c4 A661     		str	r6, [r4, #24]	@ float
 477:grbl/planner.c ****     memcpy(pl.position, target_steps, sizeof(target_steps)); // pl.position[] = target_steps[]
 1545              		.loc 1 477 0
 1546 01c6 85E80700 		stm	r5, {r0, r1, r2}
 478:grbl/planner.c **** 
 1547              		.loc 1 478 0
 1548 01ca 93E80700 		ldm	r3, {r0, r1, r2}
 1549 01ce 84E80700 		stm	r4, {r0, r1, r2}
 485:grbl/planner.c ****   }
 1550              		.loc 1 485 0
 1551 01d2 FFF7FEFF 		bl	planner_recalculate
 1552              	.LVL145:
 1553              	.LBE105:
 487:grbl/planner.c **** }
 1554              		.loc 1 487 0
 1555 01d6 0120     		movs	r0, #1
 1556              		.loc 1 488 0
 1557 01d8 0FB0     		add	sp, sp, #60
 1558              	.LCFI18:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 39


 1559              		.cfi_remember_state
 1560              		.cfi_def_cfa_offset 36
 1561              		@ sp needed
 1562 01da BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1563              	.LVL146:
 1564              	.L124:
 1565              	.LCFI19:
 1566              		.cfi_restore_state
 404:grbl/planner.c ****     if (block->condition & PL_COND_FLAG_INVERSE_TIME) { block->programmed_rate *= block->millimeter
 1567              		.loc 1 404 0
 1568 01de 019B     		ldr	r3, [sp, #4]
 405:grbl/planner.c ****   }
 1569              		.loc 1 405 0
 1570 01e0 2E07     		lsls	r6, r5, #28
 404:grbl/planner.c ****     if (block->condition & PL_COND_FLAG_INVERSE_TIME) { block->programmed_rate *= block->millimeter
 1571              		.loc 1 404 0
 1572 01e2 1968     		ldr	r1, [r3]	@ float
 1573 01e4 E162     		str	r1, [r4, #44]	@ float
 405:grbl/planner.c ****   }
 1574              		.loc 1 405 0
 1575 01e6 88D5     		bpl	.L125
 405:grbl/planner.c ****   }
 1576              		.loc 1 405 0 is_stmt 0 discriminator 1
 1577 01e8 206A     		ldr	r0, [r4, #32]	@ float
 1578 01ea FFF7FEFF 		bl	__aeabi_fmul
 1579              	.LVL147:
 1580 01ee 83E7     		b	.L162
 1581              	.L148:
 487:grbl/planner.c **** }
 1582              		.loc 1 487 0 is_stmt 1
 1583 01f0 0120     		movs	r0, #1
 1584              		.loc 1 488 0
 1585 01f2 0FB0     		add	sp, sp, #60
 1586              	.LCFI20:
 1587              		.cfi_remember_state
 1588              		.cfi_def_cfa_offset 36
 1589              		@ sp needed
 1590 01f4 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1591              	.LVL148:
 1592              	.L127:
 1593              	.LCFI21:
 1594              		.cfi_restore_state
 1595              	.LBB118:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1596              		.loc 1 442 0
 1597 01f8 284C     		ldr	r4, .L164+28
 1598 01fa 089D     		ldr	r5, [sp, #32]	@ float
 1599 01fc E668     		ldr	r6, [r4, #12]	@ float
 1600 01fe 2846     		mov	r0, r5
 1601 0200 3146     		mov	r1, r6
 1602 0202 FFF7FEFF 		bl	__aeabi_fmul
 1603              	.LVL149:
 1604 0206 0146     		mov	r1, r0
 1605 0208 0020     		movs	r0, #0
 1606 020a FFF7FEFF 		bl	__aeabi_fsub
 1607              	.LVL150:
 443:grbl/planner.c ****     }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 40


 1608              		.loc 1 443 0
 1609 020e 3146     		mov	r1, r6
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1610              		.loc 1 442 0
 1611 0210 0746     		mov	r7, r0
 1612              	.LVL151:
 443:grbl/planner.c ****     }
 1613              		.loc 1 443 0
 1614 0212 2846     		mov	r0, r5
 1615              	.LVL152:
 1616 0214 FFF7FEFF 		bl	__aeabi_fsub
 1617              	.LVL153:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1618              		.loc 1 442 0
 1619 0218 2669     		ldr	r6, [r4, #16]	@ float
 1620 021a 099D     		ldr	r5, [sp, #36]	@ float
 1621 021c 3146     		mov	r1, r6
 443:grbl/planner.c ****     }
 1622              		.loc 1 443 0
 1623 021e 0B90     		str	r0, [sp, #44]	@ float
 1624              	.LVL154:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1625              		.loc 1 442 0
 1626 0220 2846     		mov	r0, r5
 1627 0222 FFF7FEFF 		bl	__aeabi_fmul
 1628              	.LVL155:
 1629 0226 0146     		mov	r1, r0
 1630 0228 3846     		mov	r0, r7
 1631 022a FFF7FEFF 		bl	__aeabi_fsub
 1632              	.LVL156:
 443:grbl/planner.c ****     }
 1633              		.loc 1 443 0
 1634 022e 3146     		mov	r1, r6
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1635              		.loc 1 442 0
 1636 0230 0746     		mov	r7, r0
 1637              	.LVL157:
 443:grbl/planner.c ****     }
 1638              		.loc 1 443 0
 1639 0232 2846     		mov	r0, r5
 1640              	.LVL158:
 1641 0234 FFF7FEFF 		bl	__aeabi_fsub
 1642              	.LVL159:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1643              		.loc 1 442 0
 1644 0238 6469     		ldr	r4, [r4, #20]	@ float
 1645 023a 0A9D     		ldr	r5, [sp, #40]	@ float
 443:grbl/planner.c ****     }
 1646              		.loc 1 443 0
 1647 023c 0C90     		str	r0, [sp, #48]	@ float
 1648              	.LVL160:
 1649 023e 2146     		mov	r1, r4
 1650 0240 2846     		mov	r0, r5
 1651 0242 FFF7FEFF 		bl	__aeabi_fsub
 1652              	.LVL161:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1653              		.loc 1 442 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 41


 1654 0246 2946     		mov	r1, r5
 443:grbl/planner.c ****     }
 1655              		.loc 1 443 0
 1656 0248 0D90     		str	r0, [sp, #52]	@ float
 1657              	.LVL162:
 442:grbl/planner.c ****       junction_unit_vec[idx] = unit_vec[idx]-pl.previous_unit_vec[idx];
 1658              		.loc 1 442 0
 1659 024a 2046     		mov	r0, r4
 1660 024c FFF7FEFF 		bl	__aeabi_fmul
 1661              	.LVL163:
 1662 0250 0146     		mov	r1, r0
 1663 0252 3846     		mov	r0, r7
 1664 0254 FFF7FEFF 		bl	__aeabi_fsub
 1665              	.LVL164:
 447:grbl/planner.c ****       //  For a 0 degree acute junction, just set minimum junction speed.
 1666              		.loc 1 447 0
 1667 0258 FFF7FEFF 		bl	__aeabi_f2d
 1668              	.LVL165:
 1669 025c 0AA3     		adr	r3, .L164+8
 1670 025e D3E90023 		ldrd	r2, [r3]
 1671 0262 0646     		mov	r6, r0
 1672 0264 0F46     		mov	r7, r1
 1673              	.LVL166:
 1674 0266 FFF7FEFF 		bl	__aeabi_dcmpgt
 1675              	.LVL167:
 1676 026a 0028     		cmp	r0, #0
 1677 026c 5AD0     		beq	.L158
 449:grbl/planner.c ****     } else {
 1678              		.loc 1 449 0
 1679 026e 009A     		ldr	r2, [sp]
 1680 0270 3423     		movs	r3, #52
 1681 0272 1146     		mov	r1, r2
 1682 0274 074A     		ldr	r2, .L164+20
 1683 0276 03FB0123 		mla	r3, r3, r1, r2
 1684 027a 0022     		movs	r2, #0
 1685 027c 5A62     		str	r2, [r3, #36]	@ float
 1686 027e 4DE7     		b	.L128
 1687              	.L165:
 1688              		.align	3
 1689              	.L164:
 1690 0280 7B14AE47 		.word	1202590843
 1691 0284 E17A843F 		.word	1065646817
 1692 0288 E90B21E7 		.word	3877702633
 1693 028c FDFFEF3F 		.word	1072693245
 1694 0290 00000000 		.word	.LANCHOR0
 1695 0294 00000000 		.word	block_buffer
 1696 0298 00000000 		.word	sys_position
 1697 029c 00000000 		.word	.LANCHOR3
 1698 02a0 00000000 		.word	settings
 1699 02a4 00000000 		.word	direction_pin_mask
 1700 02a8 0C000000 		.word	adjustments+12
 1701 02ac 0C000000 		.word	settings+12
 1702 02b0 00000000 		.word	.LANCHOR2
 1703 02b4 00000000 		.word	sys
 1704 02b8 00000000 		.word	.LANCHOR4
 1705 02bc 0C000000 		.word	.LANCHOR3+12
 1706              	.LVL168:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 42


 1707              	.L135:
 1708              	.LBE118:
 1709              	.LBB120:
 1710              	.LBB116:
 1711              	.LBB108:
 265:grbl/planner.c ****     if (nominal_speed > block->rapid_rate) { nominal_speed = block->rapid_rate; }
 1712              		.loc 1 265 0
 1713 02c0 5307     		lsls	r3, r2, #29
 1714 02c2 16D4     		bmi	.L137
 1715 02c4 484B     		ldr	r3, .L166+16
 1716 02c6 187A     		ldrb	r0, [r3, #8]	@ zero_extendqisi2
 1717 02c8 FFF7FEFF 		bl	__aeabi_i2d
 1718              	.LVL169:
 1719 02cc 42A3     		adr	r3, .L166
 1720 02ce D3E90023 		ldrd	r2, [r3]
 1721 02d2 FFF7FEFF 		bl	__aeabi_dmul
 1722              	.LVL170:
 1723 02d6 0446     		mov	r4, r0
 1724 02d8 3046     		mov	r0, r6
 1725 02da 0D46     		mov	r5, r1
 1726 02dc FFF7FEFF 		bl	__aeabi_f2d
 1727              	.LVL171:
 1728 02e0 0246     		mov	r2, r0
 1729 02e2 0B46     		mov	r3, r1
 1730 02e4 2046     		mov	r0, r4
 1731 02e6 2946     		mov	r1, r5
 1732 02e8 FFF7FEFF 		bl	__aeabi_dmul
 1733              	.LVL172:
 1734 02ec FFF7FEFF 		bl	__aeabi_d2f
 1735              	.LVL173:
 1736 02f0 0646     		mov	r6, r0
 1737              	.LVL174:
 1738              	.L137:
 266:grbl/planner.c ****   }
 1739              		.loc 1 266 0
 1740 02f2 009A     		ldr	r2, [sp]
 1741 02f4 3423     		movs	r3, #52
 1742 02f6 1146     		mov	r1, r2
 1743 02f8 3C4A     		ldr	r2, .L166+20
 1744 02fa 03FB0123 		mla	r3, r3, r1, r2
 1745 02fe 9C6A     		ldr	r4, [r3, #40]	@ float
 1746 0300 3146     		mov	r1, r6
 1747 0302 2046     		mov	r0, r4
 1748 0304 FFF7FEFF 		bl	__aeabi_fcmplt
 1749              	.LVL175:
 1750 0308 0028     		cmp	r0, #0
 1751 030a 3FF42BAF 		beq	.L136
 1752 030e 2646     		mov	r6, r4
 1753              	.LVL176:
 1754 0310 28E7     		b	.L136
 1755              	.LVL177:
 1756              	.L143:
 1757              	.LBE108:
 1758              	.LBE116:
 1759              	.LBB117:
 1760              	.LBB112:
 280:grbl/planner.c **** }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 43


 1761              		.loc 1 280 0
 1762 0312 CAF81850 		str	r5, [r10, #24]	@ float
 1763 0316 46E7     		b	.L144
 1764              	.LVL178:
 1765              	.L160:
 279:grbl/planner.c ****   if (block->max_entry_speed_sqr > block->max_junction_speed_sqr) { block->max_entry_speed_sqr = bl
 1766              		.loc 1 279 0
 1767 0318 3146     		mov	r1, r6
 1768 031a 3046     		mov	r0, r6
 1769 031c FFF7FEFF 		bl	__aeabi_fmul
 1770              	.LVL179:
 1771 0320 0746     		mov	r7, r0
 1772              	.LVL180:
 1773 0322 37E7     		b	.L142
 1774              	.LVL181:
 1775              	.L158:
 1776              	.LBE112:
 1777              	.LBE117:
 1778              	.LBE120:
 1779              	.LBB121:
 451:grbl/planner.c ****         // Junction is a straight line or 180 degrees. Junction speed is infinite.
 1780              		.loc 1 451 0
 1781 0324 2EA3     		adr	r3, .L166+8
 1782 0326 D3E90023 		ldrd	r2, [r3]
 1783 032a 3046     		mov	r0, r6
 1784 032c 3946     		mov	r1, r7
 1785 032e FFF7FEFF 		bl	__aeabi_dcmplt
 1786              	.LVL182:
 1787 0332 40B1     		cbz	r0, .L159
 453:grbl/planner.c ****       } else {
 1788              		.loc 1 453 0
 1789 0334 009A     		ldr	r2, [sp]
 1790 0336 3423     		movs	r3, #52
 1791 0338 1146     		mov	r1, r2
 1792 033a 2C4A     		ldr	r2, .L166+20
 1793 033c 03FB0123 		mla	r3, r3, r1, r2
 1794 0340 2B4A     		ldr	r2, .L166+24
 1795 0342 5A62     		str	r2, [r3, #36]	@ float
 1796 0344 EAE6     		b	.L128
 1797              	.L159:
 1798              	.LBB119:
 455:grbl/planner.c **** 
 1799              		.loc 1 455 0
 1800 0346 0BA8     		add	r0, sp, #44
 1801 0348 FFF7FEFF 		bl	convert_delta_vector_to_unit_vector
 1802              	.LVL183:
 458:grbl/planner.c **** 				#else
 1803              		.loc 1 458 0
 1804 034c 0BA9     		add	r1, sp, #44
 1805 034e 2948     		ldr	r0, .L166+28
 1806 0350 FFF7FEFF 		bl	limit_value_by_axis_maximum
 1807              	.LVL184:
 463:grbl/planner.c ****         block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
 1808              		.loc 1 463 0
 1809 0354 3246     		mov	r2, r6
 458:grbl/planner.c **** 				#else
 1810              		.loc 1 458 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 44


 1811 0356 0446     		mov	r4, r0
 1812              	.LVL185:
 463:grbl/planner.c ****         block->max_junction_speed_sqr = max( MINIMUM_JUNCTION_SPEED*MINIMUM_JUNCTION_SPEED,
 1813              		.loc 1 463 0
 1814 0358 3B46     		mov	r3, r7
 1815 035a 0020     		movs	r0, #0
 1816              	.LVL186:
 1817 035c 2649     		ldr	r1, .L166+32
 1818 035e FFF7FEFF 		bl	__aeabi_dsub
 1819              	.LVL187:
 1820 0362 0022     		movs	r2, #0
 1821 0364 254B     		ldr	r3, .L166+36
 1822 0366 FFF7FEFF 		bl	__aeabi_dmul
 1823              	.LVL188:
 1824 036a FFF7FEFF 		bl	__aeabi_d2f
 1825              	.LVL189:
 1826 036e FFF7FEFF 		bl	sqrtf
 1827              	.LVL190:
 1828 0372 0646     		mov	r6, r0
 1829              	.LVL191:
 464:grbl/planner.c ****                        (junction_acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-si
 1830              		.loc 1 464 0
 1831 0374 224B     		ldr	r3, .L166+40
 1832 0376 2046     		mov	r0, r4
 1833              	.LVL192:
 1834 0378 996B     		ldr	r1, [r3, #56]	@ float
 1835 037a FFF7FEFF 		bl	__aeabi_fmul
 1836              	.LVL193:
 1837 037e 3146     		mov	r1, r6
 1838 0380 FFF7FEFF 		bl	__aeabi_fmul
 1839              	.LVL194:
 1840 0384 FFF7FEFF 		bl	__aeabi_f2d
 1841              	.LVL195:
 1842 0388 0446     		mov	r4, r0
 1843              	.LVL196:
 1844 038a 3046     		mov	r0, r6
 1845 038c 0D46     		mov	r5, r1
 1846 038e FFF7FEFF 		bl	__aeabi_f2d
 1847              	.LVL197:
 1848 0392 0246     		mov	r2, r0
 1849 0394 0B46     		mov	r3, r1
 1850 0396 0020     		movs	r0, #0
 1851 0398 1749     		ldr	r1, .L166+32
 1852 039a FFF7FEFF 		bl	__aeabi_dsub
 1853              	.LVL198:
 1854 039e 0246     		mov	r2, r0
 1855 03a0 0B46     		mov	r3, r1
 1856 03a2 2046     		mov	r0, r4
 1857 03a4 2946     		mov	r1, r5
 1858 03a6 FFF7FEFF 		bl	__aeabi_ddiv
 1859              	.LVL199:
 1860 03aa 0022     		movs	r2, #0
 1861 03ac 0023     		movs	r3, #0
 1862 03ae 0446     		mov	r4, r0
 1863 03b0 0D46     		mov	r5, r1
 1864 03b2 FFF7FEFF 		bl	__aeabi_dcmplt
 1865              	.LVL200:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 45


 1866 03b6 58B9     		cbnz	r0, .L147
 464:grbl/planner.c ****                        (junction_acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-si
 1867              		.loc 1 464 0 is_stmt 0 discriminator 2
 1868 03b8 2046     		mov	r0, r4
 1869 03ba 2946     		mov	r1, r5
 1870 03bc FFF7FEFF 		bl	__aeabi_d2f
 1871              	.LVL201:
 1872              	.L134:
 464:grbl/planner.c ****                        (junction_acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-si
 1873              		.loc 1 464 0 discriminator 4
 1874 03c0 009A     		ldr	r2, [sp]
 1875 03c2 3423     		movs	r3, #52
 1876 03c4 1146     		mov	r1, r2
 1877 03c6 094A     		ldr	r2, .L166+20
 1878 03c8 03FB0123 		mla	r3, r3, r1, r2
 1879 03cc 5862     		str	r0, [r3, #36]	@ float
 1880 03ce A5E6     		b	.L128
 1881              	.L147:
 464:grbl/planner.c ****                        (junction_acceleration * settings.junction_deviation * sin_theta_d2)/(1.0-si
 1882              		.loc 1 464 0
 1883 03d0 0020     		movs	r0, #0
 1884 03d2 F5E7     		b	.L134
 1885              	.L167:
 1886 03d4 AFF30080 		.align	3
 1887              	.L166:
 1888 03d8 7B14AE47 		.word	1202590843
 1889 03dc E17A843F 		.word	1065646817
 1890 03e0 E90B21E7 		.word	3877702633
 1891 03e4 FDFFEFBF 		.word	-1074790403
 1892 03e8 00000000 		.word	sys
 1893 03ec 00000000 		.word	block_buffer
 1894 03f0 FFFF7F7F 		.word	2139095039
 1895 03f4 0C000000 		.word	adjustments+12
 1896 03f8 0000F03F 		.word	1072693248
 1897 03fc 0000E03F 		.word	1071644672
 1898 0400 00000000 		.word	settings
 1899              	.LBE119:
 1900              	.LBE121:
 1901              		.cfi_endproc
 1902              	.LFE716:
 1904              		.section	.text.plan_sync_position,"ax",%progbits
 1905              		.align	1
 1906              		.p2align 2,,3
 1907              		.global	plan_sync_position
 1908              		.syntax unified
 1909              		.thumb
 1910              		.thumb_func
 1911              		.fpu softvfp
 1913              	plan_sync_position:
 1914              	.LFB717:
 489:grbl/planner.c **** 
 490:grbl/planner.c **** 
 491:grbl/planner.c **** // Reset the planner position vectors. Called by the system abort/initialization routine.
 492:grbl/planner.c **** void plan_sync_position()
 493:grbl/planner.c **** {
 1915              		.loc 1 493 0 is_stmt 1
 1916              		.cfi_startproc
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 46


 1917              		@ args = 0, pretend = 0, frame = 0
 1918              		@ frame_needed = 0, uses_anonymous_args = 0
 1919              		@ link register save eliminated.
 1920              	.LVL202:
 494:grbl/planner.c ****   // TODO: For motor configurations not in the same coordinate frame as the machine position,
 495:grbl/planner.c ****   // this function needs to be updated to accomodate the difference.
 496:grbl/planner.c ****   uint8_t idx;
 497:grbl/planner.c ****   for (idx=0; idx<N_AXIS; idx++) {
 498:grbl/planner.c ****     #ifdef COREXY
 499:grbl/planner.c ****       if (idx==X_AXIS) {
 500:grbl/planner.c ****         pl.position[X_AXIS] = system_convert_corexy_to_x_axis_steps(sys_position);
 501:grbl/planner.c ****       } else if (idx==Y_AXIS) {
 502:grbl/planner.c ****         pl.position[Y_AXIS] = system_convert_corexy_to_y_axis_steps(sys_position);
 503:grbl/planner.c ****       } else {
 504:grbl/planner.c ****         pl.position[idx] = sys_position[idx];
 505:grbl/planner.c ****       }
 506:grbl/planner.c ****     #else
 507:grbl/planner.c ****       pl.position[idx] = sys_position[idx];
 1921              		.loc 1 507 0
 1922 0000 044A     		ldr	r2, .L169
 1923 0002 054B     		ldr	r3, .L169+4
 1924 0004 D2E90001 		ldrd	r0, r1, [r2]
 1925 0008 9268     		ldr	r2, [r2, #8]
 1926 000a C3E90001 		strd	r0, r1, [r3]
 1927              	.LVL203:
 1928 000e 9A60     		str	r2, [r3, #8]
 1929              	.LVL204:
 508:grbl/planner.c ****     #endif
 509:grbl/planner.c ****   }
 510:grbl/planner.c **** }
 1930              		.loc 1 510 0
 1931 0010 7047     		bx	lr
 1932              	.L170:
 1933 0012 00BF     		.align	2
 1934              	.L169:
 1935 0014 00000000 		.word	sys_position
 1936 0018 00000000 		.word	.LANCHOR3
 1937              		.cfi_endproc
 1938              	.LFE717:
 1940              		.section	.text.plan_get_block_buffer_available,"ax",%progbits
 1941              		.align	1
 1942              		.p2align 2,,3
 1943              		.global	plan_get_block_buffer_available
 1944              		.syntax unified
 1945              		.thumb
 1946              		.thumb_func
 1947              		.fpu softvfp
 1949              	plan_get_block_buffer_available:
 1950              	.LFB718:
 511:grbl/planner.c **** 
 512:grbl/planner.c **** 
 513:grbl/planner.c **** // Returns the number of available blocks are in the planner buffer.
 514:grbl/planner.c **** uint8_t plan_get_block_buffer_available()
 515:grbl/planner.c **** {
 1951              		.loc 1 515 0
 1952              		.cfi_startproc
 1953              		@ args = 0, pretend = 0, frame = 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 47


 1954              		@ frame_needed = 0, uses_anonymous_args = 0
 1955              		@ link register save eliminated.
 516:grbl/planner.c ****   if (block_buffer_head >= block_buffer_tail) { return((BLOCK_BUFFER_SIZE-1)-(block_buffer_head-blo
 1956              		.loc 1 516 0
 1957 0000 064A     		ldr	r2, .L174
 1958 0002 074B     		ldr	r3, .L174+4
 1959 0004 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 1960 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1961 0008 9A42     		cmp	r2, r3
 1962 000a 2CBF     		ite	cs
 1963 000c A3F13900 		subcs	r0, r3, #57
 517:grbl/planner.c ****   return((block_buffer_tail-block_buffer_head-1));
 1964              		.loc 1 517 0
 1965 0010 03F1FF30 		addcc	r0, r3, #-1
 1966 0014 801A     		subs	r0, r0, r2
 1967 0016 C0B2     		uxtb	r0, r0
 518:grbl/planner.c **** }
 1968              		.loc 1 518 0
 1969 0018 7047     		bx	lr
 1970              	.L175:
 1971 001a 00BF     		.align	2
 1972              	.L174:
 1973 001c 00000000 		.word	.LANCHOR0
 1974 0020 00000000 		.word	.LANCHOR2
 1975              		.cfi_endproc
 1976              	.LFE718:
 1978              		.section	.text.plan_get_block_buffer_count,"ax",%progbits
 1979              		.align	1
 1980              		.p2align 2,,3
 1981              		.global	plan_get_block_buffer_count
 1982              		.syntax unified
 1983              		.thumb
 1984              		.thumb_func
 1985              		.fpu softvfp
 1987              	plan_get_block_buffer_count:
 1988              	.LFB719:
 519:grbl/planner.c **** 
 520:grbl/planner.c **** 
 521:grbl/planner.c **** // Returns the number of active blocks are in the planner buffer.
 522:grbl/planner.c **** // NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
 523:grbl/planner.c **** uint8_t plan_get_block_buffer_count()
 524:grbl/planner.c **** {
 1989              		.loc 1 524 0
 1990              		.cfi_startproc
 1991              		@ args = 0, pretend = 0, frame = 0
 1992              		@ frame_needed = 0, uses_anonymous_args = 0
 1993              		@ link register save eliminated.
 525:grbl/planner.c ****   if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
 1994              		.loc 1 525 0
 1995 0000 044A     		ldr	r2, .L180
 1996 0002 054B     		ldr	r3, .L180+4
 1997 0004 1078     		ldrb	r0, [r2]	@ zero_extendqisi2
 1998 0006 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1999 0008 9842     		cmp	r0, r3
 526:grbl/planner.c ****   return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
 2000              		.loc 1 526 0
 2001 000a 38BF     		it	cc
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 48


 2002 000c 3838     		subcc	r0, r0, #56
 2003 000e C01A     		subs	r0, r0, r3
 2004 0010 C0B2     		uxtb	r0, r0
 527:grbl/planner.c **** }
 2005              		.loc 1 527 0
 2006 0012 7047     		bx	lr
 2007              	.L181:
 2008              		.align	2
 2009              	.L180:
 2010 0014 00000000 		.word	.LANCHOR0
 2011 0018 00000000 		.word	.LANCHOR2
 2012              		.cfi_endproc
 2013              	.LFE719:
 2015              		.section	.text.plan_cycle_reinitialize,"ax",%progbits
 2016              		.align	1
 2017              		.p2align 2,,3
 2018              		.global	plan_cycle_reinitialize
 2019              		.syntax unified
 2020              		.thumb
 2021              		.thumb_func
 2022              		.fpu softvfp
 2024              	plan_cycle_reinitialize:
 2025              	.LFB720:
 528:grbl/planner.c **** 
 529:grbl/planner.c **** 
 530:grbl/planner.c **** // Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
 531:grbl/planner.c **** // Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
 532:grbl/planner.c **** void plan_cycle_reinitialize()
 533:grbl/planner.c **** {
 2026              		.loc 1 533 0
 2027              		.cfi_startproc
 2028              		@ args = 0, pretend = 0, frame = 0
 2029              		@ frame_needed = 0, uses_anonymous_args = 0
 2030 0000 08B5     		push	{r3, lr}
 2031              	.LCFI22:
 2032              		.cfi_def_cfa_offset 8
 2033              		.cfi_offset 3, -8
 2034              		.cfi_offset 14, -4
 534:grbl/planner.c ****   // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
 535:grbl/planner.c ****   st_update_plan_block_parameters();
 2035              		.loc 1 535 0
 2036 0002 FFF7FEFF 		bl	st_update_plan_block_parameters
 2037              	.LVL205:
 536:grbl/planner.c ****   block_buffer_planned = block_buffer_tail;
 2038              		.loc 1 536 0
 2039 0006 044A     		ldr	r2, .L184
 2040 0008 044B     		ldr	r3, .L184+4
 2041 000a 1278     		ldrb	r2, [r2]	@ zero_extendqisi2
 2042 000c 1A70     		strb	r2, [r3]
 537:grbl/planner.c ****   planner_recalculate();
 538:grbl/planner.c **** }
 2043              		.loc 1 538 0
 2044 000e BDE80840 		pop	{r3, lr}
 2045              	.LCFI23:
 2046              		.cfi_restore 14
 2047              		.cfi_restore 3
 2048              		.cfi_def_cfa_offset 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 49


 537:grbl/planner.c ****   planner_recalculate();
 2049              		.loc 1 537 0
 2050 0012 FFF7FEBF 		b	planner_recalculate
 2051              	.LVL206:
 2052              	.L185:
 2053 0016 00BF     		.align	2
 2054              	.L184:
 2055 0018 00000000 		.word	.LANCHOR2
 2056 001c 00000000 		.word	.LANCHOR1
 2057              		.cfi_endproc
 2058              	.LFE720:
 2060              		.section	.bss.block_buffer,"aw",%nobits
 2061              		.align	2
 2064              	block_buffer:
 2065 0000 00000000 		.space	10400
 2065      00000000 
 2065      00000000 
 2065      00000000 
 2065      00000000 
 2066              		.section	.bss.block_buffer_head,"aw",%nobits
 2067              		.set	.LANCHOR0,. + 0
 2070              	block_buffer_head:
 2071 0000 00       		.space	1
 2072              		.section	.bss.block_buffer_planned,"aw",%nobits
 2073              		.set	.LANCHOR1,. + 0
 2076              	block_buffer_planned:
 2077 0000 00       		.space	1
 2078              		.section	.bss.block_buffer_tail,"aw",%nobits
 2079              		.set	.LANCHOR2,. + 0
 2082              	block_buffer_tail:
 2083 0000 00       		.space	1
 2084              		.section	.bss.next_buffer_head,"aw",%nobits
 2085              		.set	.LANCHOR4,. + 0
 2088              	next_buffer_head:
 2089 0000 00       		.space	1
 2090              		.section	.bss.pl,"aw",%nobits
 2091              		.align	2
 2092              		.set	.LANCHOR3,. + 0
 2095              	pl:
 2096 0000 00000000 		.space	28
 2096      00000000 
 2096      00000000 
 2096      00000000 
 2096      00000000 
 2097              		.text
 2098              	.Letext0:
 2099              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 2100              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 2101              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 2102              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 2103              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 2104              		.file 7 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/math.h"
 2105              		.file 8 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 2106              		.file 9 "Drivers/CMSIS/Include/core_cm3.h"
 2107              		.file 10 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 2108              		.file 11 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 2109              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h"
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 50


 2110              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h"
 2111              		.file 14 "stm32/stm32utilities.h"
 2112              		.file 15 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 2113              		.file 16 "grbl/settings.h"
 2114              		.file 17 "grbl/system.h"
 2115              		.file 18 "grbl/planner.h"
 2116              		.file 19 "grbl/gcode.h"
 2117              		.file 20 "grbl/stepper.h"
 2118              		.file 21 "grbl/nuts_bolts.h"
 2119              		.file 22 "<built-in>"
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 51


DEFINED SYMBOLS
                            *ABS*:0000000000000000 planner.c
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:21     .text.planner_recalculate:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:28     .text.planner_recalculate:0000000000000000 planner_recalculate
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:367    .text.planner_recalculate:00000000000001b4 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2064   .bss.block_buffer:0000000000000000 block_buffer
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:375    .text.plan_next_block_index:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:383    .text.plan_next_block_index:0000000000000000 plan_next_block_index
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:408    .text.plan_reset:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:416    .text.plan_reset:0000000000000000 plan_reset
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:493    .text.plan_reset:000000000000002c $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:502    .text.plan_reset_buffer:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:510    .text.plan_reset_buffer:0000000000000000 plan_reset_buffer
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:553    .text.plan_reset_buffer:000000000000001c $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:561    .text.plan_discard_current_block:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:569    .text.plan_discard_current_block:0000000000000000 plan_discard_current_block
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:626    .text.plan_discard_current_block:000000000000002c $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:633    .text.plan_get_system_motion_block:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:641    .text.plan_get_system_motion_block:0000000000000000 plan_get_system_motion_block
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:659    .text.plan_get_system_motion_block:0000000000000010 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:665    .text.plan_get_current_block:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:673    .text.plan_get_current_block:0000000000000000 plan_get_current_block
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:698    .text.plan_get_current_block:0000000000000018 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:705    .text.plan_get_exec_block_exit_speed_sqr:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:713    .text.plan_get_exec_block_exit_speed_sqr:0000000000000000 plan_get_exec_block_exit_speed_sqr
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:763    .text.plan_get_exec_block_exit_speed_sqr:0000000000000028 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:770    .text.plan_check_full_buffer:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:778    .text.plan_check_full_buffer:0000000000000000 plan_check_full_buffer
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:798    .text.plan_check_full_buffer:0000000000000014 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:808    .text.plan_compute_profile_nominal_speed:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:816    .text.plan_compute_profile_nominal_speed:0000000000000000 plan_compute_profile_nominal_speed
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:926    .text.plan_compute_profile_nominal_speed:0000000000000098 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:933    .text.plan_update_velocity_profile_parameters:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:941    .text.plan_update_velocity_profile_parameters:0000000000000000 plan_update_velocity_profile_parameters
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1188   .text.plan_update_velocity_profile_parameters:0000000000000108 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1207   .text.plan_buffer_line:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1215   .text.plan_buffer_line:0000000000000000 plan_buffer_line
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1690   .text.plan_buffer_line:0000000000000280 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1713   .text.plan_buffer_line:00000000000002c0 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1888   .text.plan_buffer_line:00000000000003d8 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1905   .text.plan_sync_position:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1913   .text.plan_sync_position:0000000000000000 plan_sync_position
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1935   .text.plan_sync_position:0000000000000014 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1941   .text.plan_get_block_buffer_available:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1949   .text.plan_get_block_buffer_available:0000000000000000 plan_get_block_buffer_available
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1973   .text.plan_get_block_buffer_available:000000000000001c $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1979   .text.plan_get_block_buffer_count:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:1987   .text.plan_get_block_buffer_count:0000000000000000 plan_get_block_buffer_count
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2010   .text.plan_get_block_buffer_count:0000000000000014 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2016   .text.plan_cycle_reinitialize:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2024   .text.plan_cycle_reinitialize:0000000000000000 plan_cycle_reinitialize
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2055   .text.plan_cycle_reinitialize:0000000000000018 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2061   .bss.block_buffer:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2070   .bss.block_buffer_head:0000000000000000 block_buffer_head
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2071   .bss.block_buffer_head:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2076   .bss.block_buffer_planned:0000000000000000 block_buffer_planned
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2077   .bss.block_buffer_planned:0000000000000000 $d
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s 			page 52


/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2082   .bss.block_buffer_tail:0000000000000000 block_buffer_tail
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2083   .bss.block_buffer_tail:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2088   .bss.next_buffer_head:0000000000000000 next_buffer_head
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2089   .bss.next_buffer_head:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2091   .bss.pl:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccAXVKf7.s:2095   .bss.pl:0000000000000000 pl

UNDEFINED SYMBOLS
__aeabi_fadd
__aeabi_fmul
__aeabi_fcmplt
__aeabi_fcmpeq
__aeabi_fcmpgt
st_update_plan_block_parameters
__aeabi_i2d
__aeabi_dmul
__aeabi_f2d
__aeabi_d2f
sys
__aeabi_i2f
__aeabi_fdiv
__aeabi_fsub
__aeabi_dcmpgt
__aeabi_dcmplt
__aeabi_dsub
__aeabi_ddiv
memset
lround
convert_delta_vector_to_unit_vector
limit_value_by_axis_maximum
sys_position
settings
direction_pin_mask
adjustments
sqrtf
