ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 2
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"motion_control.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.mc_line,"ax",%progbits
  16              		.align	1
  17              		.p2align 2,,3
  18              		.global	mc_line
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	mc_line:
  25              	.LFB703:
  26              		.file 1 "grbl/motion_control.c"
   1:grbl/motion_control.c **** /*
   2:grbl/motion_control.c ****   motion_control.c - high level interface for issuing motion commands
   3:grbl/motion_control.c ****   Part of Grbl
   4:grbl/motion_control.c **** 
   5:grbl/motion_control.c ****   Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
   6:grbl/motion_control.c ****   Copyright (c) 2009-2011 Simen Svale Skogsrud
   7:grbl/motion_control.c ****   Copyright (c) 2018-2019 Thomas Truong
   8:grbl/motion_control.c **** 
   9:grbl/motion_control.c ****   Grbl is free software: you can redistribute it and/or modify
  10:grbl/motion_control.c ****   it under the terms of the GNU General Public License as published by
  11:grbl/motion_control.c ****   the Free Software Foundation, either version 3 of the License, or
  12:grbl/motion_control.c ****   (at your option) any later version.
  13:grbl/motion_control.c **** 
  14:grbl/motion_control.c ****   Grbl is distributed in the hope that it will be useful,
  15:grbl/motion_control.c ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:grbl/motion_control.c ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:grbl/motion_control.c ****   GNU General Public License for more details.
  18:grbl/motion_control.c **** 
  19:grbl/motion_control.c ****   You should have received a copy of the GNU General Public License
  20:grbl/motion_control.c ****   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  21:grbl/motion_control.c **** */
  22:grbl/motion_control.c **** 
  23:grbl/motion_control.c **** #include "grbl.h"
  24:grbl/motion_control.c **** 
  25:grbl/motion_control.c **** 
  26:grbl/motion_control.c **** // Execute linear motion in absolute millimeter coordinates. Feed rate given in millimeters/second
  27:grbl/motion_control.c **** // unless invert_feed_rate is true. Then the feed_rate means that the motion should be completed in
  28:grbl/motion_control.c **** // (1 minute)/feed_rate time.
  29:grbl/motion_control.c **** // NOTE: This is the primary gateway to the grbl planner. All line motions, including arc line
  30:grbl/motion_control.c **** // segments, must pass through this routine before being passed to the planner. The seperation of
  31:grbl/motion_control.c **** // mc_line and plan_buffer_line is done primarily to place non-planner-type functions from being
  32:grbl/motion_control.c **** // in the planner and to let backlash compensation or canned cycle integration simple and direct.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 2


  33:grbl/motion_control.c **** void mc_line(float *target, plan_line_data_t *pl_data)
  34:grbl/motion_control.c **** {
  27              		.loc 1 34 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31              	.LVL0:
  32 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  33              	.LCFI0:
  34              		.cfi_def_cfa_offset 24
  35              		.cfi_offset 3, -24
  36              		.cfi_offset 4, -20
  37              		.cfi_offset 5, -16
  38              		.cfi_offset 6, -12
  39              		.cfi_offset 7, -8
  40              		.cfi_offset 14, -4
  35:grbl/motion_control.c ****   // If enabled, check for soft limit violations. Placed here all line motions are picked up
  36:grbl/motion_control.c ****   // from everywhere in Grbl.
  37:grbl/motion_control.c ****   if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
  41              		.loc 1 37 0
  42 0002 174D     		ldr	r5, .L21
  43 0004 174C     		ldr	r4, .L21+4
  44 0006 95F84820 		ldrb	r2, [r5, #72]	@ zero_extendqisi2
  34:grbl/motion_control.c ****   // If enabled, check for soft limit violations. Placed here all line motions are picked up
  45              		.loc 1 34 0
  46 000a 0E46     		mov	r6, r1
  47              		.loc 1 37 0
  48 000c 9106     		lsls	r1, r2, #26
  49              	.LVL1:
  50 000e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
  34:grbl/motion_control.c ****   // If enabled, check for soft limit violations. Placed here all line motions are picked up
  51              		.loc 1 34 0
  52 0010 0746     		mov	r7, r0
  53              		.loc 1 37 0
  54 0012 04D5     		bpl	.L2
  38:grbl/motion_control.c ****     // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
  39:grbl/motion_control.c ****     if (sys.state != STATE_JOG) { limits_soft_check(target); }
  55              		.loc 1 39 0
  56 0014 202B     		cmp	r3, #32
  57 0016 0AD0     		beq	.L4
  58              		.loc 1 39 0 is_stmt 0 discriminator 1
  59 0018 FFF7FEFF 		bl	limits_soft_check
  60              	.LVL2:
  61 001c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
  62              	.L2:
  40:grbl/motion_control.c ****   }
  41:grbl/motion_control.c **** 
  42:grbl/motion_control.c ****   // If in check gcode mode, prevent motion by blocking planner. Soft limits still work.
  43:grbl/motion_control.c ****   if (sys.state == STATE_CHECK_MODE) { return; }
  63              		.loc 1 43 0 is_stmt 1
  64 001e 022B     		cmp	r3, #2
  65 0020 05D1     		bne	.L4
  66              	.L1:
  44:grbl/motion_control.c **** 
  45:grbl/motion_control.c ****   // NOTE: Backlash compensation may be installed here. It will need direction info to track when
  46:grbl/motion_control.c ****   // to insert a backlash line motion(s) before the intended line motion and will require its own
  47:grbl/motion_control.c ****   // plan_check_full_buffer() and check for system abort loop. Also for position reporting
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 3


  48:grbl/motion_control.c ****   // backlash steps will need to be also tracked, which will need to be kept at a system level.
  49:grbl/motion_control.c ****   // There are likely some other things that will need to be tracked as well. However, we feel
  50:grbl/motion_control.c ****   // that backlash compensation should NOT be handled by Grbl itself, because there are a myriad
  51:grbl/motion_control.c ****   // of ways to implement it and can be effective or ineffective for different CNC machines. This
  52:grbl/motion_control.c ****   // would be better handled by the interface as a post-processor task, where the original g-code
  53:grbl/motion_control.c ****   // is translated and inserts backlash motions that best suits the machine.
  54:grbl/motion_control.c ****   // NOTE: Perhaps as a middle-ground, all that needs to be sent is a flag or special command that
  55:grbl/motion_control.c ****   // indicates to Grbl what is a backlash compensation motion, so that Grbl executes the move but
  56:grbl/motion_control.c ****   // doesn't update the machine position values. Since the position values used by the g-code
  57:grbl/motion_control.c ****   // parser and planner are separate from the system machine positions, this is doable.
  58:grbl/motion_control.c **** 
  59:grbl/motion_control.c ****   // If the buffer is full: good! That means we are well ahead of the robot.
  60:grbl/motion_control.c ****   // Remain in this loop until there is room in the buffer.
  61:grbl/motion_control.c ****   do {
  62:grbl/motion_control.c ****     protocol_execute_realtime(); // Check for any run-time commands
  63:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
  64:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
  65:grbl/motion_control.c ****     else { break; }
  66:grbl/motion_control.c ****   } while (1);
  67:grbl/motion_control.c **** 
  68:grbl/motion_control.c ****   // Plan and queue motion into planner buffer
  69:grbl/motion_control.c ****   if (plan_buffer_line(target, pl_data) == PLAN_EMPTY_BLOCK) {
  70:grbl/motion_control.c ****     if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
  71:grbl/motion_control.c ****       // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
  72:grbl/motion_control.c ****       // sync while in M3 laser mode only.
  73:grbl/motion_control.c ****       if (pl_data->condition & PL_COND_FLAG_SPINDLE_CW) {
  74:grbl/motion_control.c ****         spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
  75:grbl/motion_control.c ****       }
  76:grbl/motion_control.c ****     }
  77:grbl/motion_control.c ****   }
  78:grbl/motion_control.c **** }
  67              		.loc 1 78 0
  68 0022 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
  69              	.LVL3:
  70              	.L20:
  64:grbl/motion_control.c ****     else { break; }
  71              		.loc 1 64 0
  72 0024 FFF7FEFF 		bl	plan_check_full_buffer
  73              	.LVL4:
  74 0028 38B1     		cbz	r0, .L8
  64:grbl/motion_control.c ****     else { break; }
  75              		.loc 1 64 0 is_stmt 0 discriminator 1
  76 002a FFF7FEFF 		bl	protocol_auto_cycle_start
  77              	.LVL5:
  78              	.L4:
  62:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
  79              		.loc 1 62 0 is_stmt 1
  80 002e FFF7FEFF 		bl	protocol_execute_realtime
  81              	.LVL6:
  63:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
  82              		.loc 1 63 0
  83 0032 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
  84 0034 002B     		cmp	r3, #0
  85 0036 F5D0     		beq	.L20
  86 0038 F3E7     		b	.L1
  87              	.L8:
  69:grbl/motion_control.c ****     if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 4


  88              		.loc 1 69 0
  89 003a 3846     		mov	r0, r7
  90 003c 3146     		mov	r1, r6
  91 003e FFF7FEFF 		bl	plan_buffer_line
  92              	.LVL7:
  93 0042 0028     		cmp	r0, #0
  94 0044 EDD1     		bne	.L1
  70:grbl/motion_control.c ****       // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
  95              		.loc 1 70 0
  96 0046 95F84830 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
  97 004a 9A07     		lsls	r2, r3, #30
  98 004c E9D5     		bpl	.L1
  73:grbl/motion_control.c ****         spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
  99              		.loc 1 73 0
 100 004e 337A     		ldrb	r3, [r6, #8]	@ zero_extendqisi2
 101 0050 DB06     		lsls	r3, r3, #27
 102 0052 E6D5     		bpl	.L1
 103              	.LVL8:
 104              	.LBB6:
 105              	.LBB7:
  74:grbl/motion_control.c ****       }
 106              		.loc 1 74 0
 107 0054 7168     		ldr	r1, [r6, #4]	@ float
 108 0056 1020     		movs	r0, #16
 109              	.LBE7:
 110              	.LBE6:
 111              		.loc 1 78 0
 112 0058 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 113              	.LCFI1:
 114              		.cfi_restore 14
 115              		.cfi_restore 7
 116              		.cfi_restore 6
 117              		.cfi_restore 5
 118              		.cfi_restore 4
 119              		.cfi_restore 3
 120              		.cfi_def_cfa_offset 0
 121              	.LVL9:
 122              	.LBB9:
 123              	.LBB8:
  74:grbl/motion_control.c ****       }
 124              		.loc 1 74 0
 125 005c FFF7FEBF 		b	spindle_sync
 126              	.LVL10:
 127              	.L22:
 128              		.align	2
 129              	.L21:
 130 0060 00000000 		.word	settings
 131 0064 00000000 		.word	sys
 132              	.LBE8:
 133              	.LBE9:
 134              		.cfi_endproc
 135              	.LFE703:
 137              		.global	__aeabi_fadd
 138              		.global	__aeabi_fsub
 139              		.global	__aeabi_fmul
 140              		.global	__aeabi_f2d
 141              		.global	__aeabi_dcmpge
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 5


 142              		.global	__aeabi_dsub
 143              		.global	__aeabi_d2f
 144              		.global	__aeabi_dcmple
 145              		.global	__aeabi_dadd
 146              		.global	__aeabi_dmul
 147              		.global	__aeabi_ddiv
 148              		.global	__aeabi_d2uiz
 149              		.global	__aeabi_i2f
 150              		.global	__aeabi_fdiv
 151              		.section	.text.mc_arc,"ax",%progbits
 152              		.align	1
 153              		.p2align 2,,3
 154              		.global	mc_arc
 155              		.syntax unified
 156              		.thumb
 157              		.thumb_func
 158              		.fpu softvfp
 160              	mc_arc:
 161              	.LFB704:
  79:grbl/motion_control.c **** 
  80:grbl/motion_control.c **** 
  81:grbl/motion_control.c **** // Execute an arc in offset mode format. position == current xyz, target == target xyz,
  82:grbl/motion_control.c **** // offset == offset from current xyz, axis_X defines circle plane in tool space, axis_linear is
  83:grbl/motion_control.c **** // the direction of helical travel, radius == circle radius, isclockwise boolean. Used
  84:grbl/motion_control.c **** // for vector transformation direction.
  85:grbl/motion_control.c **** // The arc is approximated by generating a huge number of tiny, linear segments. The chordal tolera
  86:grbl/motion_control.c **** // of each segment is configured in settings.arc_tolerance, which is defined to be the maximum norm
  87:grbl/motion_control.c **** // distance from segment to the circle when the end points both lie on the circle.
  88:grbl/motion_control.c **** void mc_arc(float *target, plan_line_data_t *pl_data, float *position, float *offset, float radius,
  89:grbl/motion_control.c ****   uint8_t axis_0, uint8_t axis_1, uint8_t axis_linear, uint8_t is_clockwise_arc)
  90:grbl/motion_control.c **** {
 162              		.loc 1 90 0
 163              		.cfi_startproc
 164              		@ args = 20, pretend = 0, frame = 56
 165              		@ frame_needed = 0, uses_anonymous_args = 0
 166              	.LVL11:
 167 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 168              	.LCFI2:
 169              		.cfi_def_cfa_offset 36
 170              		.cfi_offset 4, -36
 171              		.cfi_offset 5, -32
 172              		.cfi_offset 6, -28
 173              		.cfi_offset 7, -24
 174              		.cfi_offset 8, -20
 175              		.cfi_offset 9, -16
 176              		.cfi_offset 10, -12
 177              		.cfi_offset 11, -8
 178              		.cfi_offset 14, -4
 179 0004 1F46     		mov	r7, r3
 180 0006 8FB0     		sub	sp, sp, #60
 181              	.LCFI3:
 182              		.cfi_def_cfa_offset 96
 183              		.loc 1 90 0
 184 0008 9DF86440 		ldrb	r4, [sp, #100]	@ zero_extendqisi2
 185 000c 9346     		mov	fp, r2
  91:grbl/motion_control.c ****   float center_axis0 = position[axis_0] + offset[axis_0];
 186              		.loc 1 91 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 6


 187 000e 53F82450 		ldr	r5, [r3, r4, lsl #2]	@ float
 188 0012 A300     		lsls	r3, r4, #2
 189              	.LVL12:
  90:grbl/motion_control.c ****   float center_axis0 = position[axis_0] + offset[axis_0];
 190              		.loc 1 90 0
 191 0014 0B90     		str	r0, [sp, #44]
 192 0016 0791     		str	r1, [sp, #28]
 193              		.loc 1 91 0
 194 0018 2846     		mov	r0, r5
 195              	.LVL13:
 196 001a 52F82410 		ldr	r1, [r2, r4, lsl #2]	@ float
 197              	.LVL14:
 198 001e 1A44     		add	r2, r2, r3
 199              	.LVL15:
 200 0020 FB18     		adds	r3, r7, r3
 201 0022 0192     		str	r2, [sp, #4]
 202 0024 0893     		str	r3, [sp, #32]
 203 0026 FFF7FEFF 		bl	__aeabi_fadd
 204              	.LVL16:
  90:grbl/motion_control.c ****   float center_axis0 = position[axis_0] + offset[axis_0];
 205              		.loc 1 90 0
 206 002a 9DF86860 		ldrb	r6, [sp, #104]	@ zero_extendqisi2
 207              		.loc 1 91 0
 208 002e 8246     		mov	r10, r0
  92:grbl/motion_control.c ****   float center_axis1 = position[axis_1] + offset[axis_1];
 209              		.loc 1 92 0
 210 0030 57F82680 		ldr	r8, [r7, r6, lsl #2]	@ float
 211 0034 B300     		lsls	r3, r6, #2
 212 0036 FA18     		adds	r2, r7, r3
 213 0038 5BF82610 		ldr	r1, [fp, r6, lsl #2]	@ float
 214 003c 5B44     		add	r3, fp, r3
  91:grbl/motion_control.c ****   float center_axis0 = position[axis_0] + offset[axis_0];
 215              		.loc 1 91 0
 216 003e 0390     		str	r0, [sp, #12]	@ float
 217              	.LVL17:
 218              		.loc 1 92 0
 219 0040 4046     		mov	r0, r8
 220              	.LVL18:
 221 0042 0992     		str	r2, [sp, #36]
 222 0044 0293     		str	r3, [sp, #8]
 223 0046 FFF7FEFF 		bl	__aeabi_fadd
 224              	.LVL19:
  93:grbl/motion_control.c ****   float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
  94:grbl/motion_control.c ****   float r_axis1 = -offset[axis_1];
  95:grbl/motion_control.c ****   float rt_axis0 = target[axis_0] - center_axis0;
 225              		.loc 1 95 0
 226 004a 0B9F     		ldr	r7, [sp, #44]
 227              	.LVL20:
 228 004c 5146     		mov	r1, r10
  92:grbl/motion_control.c ****   float center_axis1 = position[axis_1] + offset[axis_1];
 229              		.loc 1 92 0
 230 004e 8146     		mov	r9, r0
 231 0050 0490     		str	r0, [sp, #16]	@ float
 232              	.LVL21:
 233              		.loc 1 95 0
 234 0052 57F82400 		ldr	r0, [r7, r4, lsl #2]	@ float
 235              	.LVL22:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 7


 236 0056 FFF7FEFF 		bl	__aeabi_fsub
 237              	.LVL23:
  96:grbl/motion_control.c ****   float rt_axis1 = target[axis_1] - center_axis1;
 238              		.loc 1 96 0
 239 005a 4946     		mov	r1, r9
  95:grbl/motion_control.c ****   float rt_axis1 = target[axis_1] - center_axis1;
 240              		.loc 1 95 0
 241 005c 0446     		mov	r4, r0
 242              		.loc 1 96 0
 243 005e 57F82600 		ldr	r0, [r7, r6, lsl #2]	@ float
 244 0062 FFF7FEFF 		bl	__aeabi_fsub
 245              	.LVL24:
  93:grbl/motion_control.c ****   float r_axis0 = -offset[axis_0];  // Radius vector from center to current location
 246              		.loc 1 93 0
 247 0066 05F10045 		add	r5, r5, #-2147483648
 248              	.LVL25:
 249              		.loc 1 96 0
 250 006a 0646     		mov	r6, r0
  97:grbl/motion_control.c **** 
  98:grbl/motion_control.c ****   // CCW angle between position and target from circle center. Only one atan2() trig computation re
  99:grbl/motion_control.c ****   float angular_travel = atan2f(r_axis0*rt_axis1-r_axis1*rt_axis0, r_axis0*rt_axis0+r_axis1*rt_axis
 251              		.loc 1 99 0
 252 006c 2146     		mov	r1, r4
 253 006e 2846     		mov	r0, r5
 254 0070 FFF7FEFF 		bl	__aeabi_fmul
 255              	.LVL26:
  94:grbl/motion_control.c ****   float rt_axis0 = target[axis_0] - center_axis0;
 256              		.loc 1 94 0
 257 0074 08F10048 		add	r8, r8, #-2147483648
 258              	.LVL27:
 259              		.loc 1 99 0
 260 0078 0746     		mov	r7, r0
 261 007a 3146     		mov	r1, r6
 262 007c 4046     		mov	r0, r8
 263 007e FFF7FEFF 		bl	__aeabi_fmul
 264              	.LVL28:
 265 0082 0146     		mov	r1, r0
 266 0084 3846     		mov	r0, r7
 267 0086 FFF7FEFF 		bl	__aeabi_fadd
 268              	.LVL29:
 269 008a 3146     		mov	r1, r6
 270 008c 0746     		mov	r7, r0
 271 008e 2846     		mov	r0, r5
 272 0090 FFF7FEFF 		bl	__aeabi_fmul
 273              	.LVL30:
 274 0094 2146     		mov	r1, r4
 275 0096 0646     		mov	r6, r0
 276              	.LVL31:
 277 0098 4046     		mov	r0, r8
 278 009a FFF7FEFF 		bl	__aeabi_fmul
 279              	.LVL32:
 280 009e 0146     		mov	r1, r0
 281 00a0 3046     		mov	r0, r6
 282 00a2 FFF7FEFF 		bl	__aeabi_fsub
 283              	.LVL33:
 284 00a6 3946     		mov	r1, r7
  90:grbl/motion_control.c ****   float center_axis0 = position[axis_0] + offset[axis_0];
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 8


 285              		.loc 1 90 0
 286 00a8 9DF87060 		ldrb	r6, [sp, #112]	@ zero_extendqisi2
 287 00ac 189C     		ldr	r4, [sp, #96]	@ float
 288              	.LVL34:
 289 00ae 9DF86CA0 		ldrb	r10, [sp, #108]	@ zero_extendqisi2
 290              	.LVL35:
 291              		.loc 1 99 0
 292 00b2 FFF7FEFF 		bl	atan2f
 293              	.LVL36:
 294 00b6 0590     		str	r0, [sp, #20]	@ float
 295              	.LVL37:
 100:grbl/motion_control.c ****   if (is_clockwise_arc) { // Correct atan2 output per direction
 296              		.loc 1 100 0
 297 00b8 002E     		cmp	r6, #0
 298 00ba 00F09181 		beq	.L24
 101:grbl/motion_control.c ****     if (angular_travel >= -ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel -= 2*M_PI; }
 299              		.loc 1 101 0
 300 00be FFF7FEFF 		bl	__aeabi_f2d
 301              	.LVL38:
 302 00c2 A3A3     		adr	r3, .L89
 303 00c4 D3E90023 		ldrd	r2, [r3]
 304 00c8 0646     		mov	r6, r0
 305 00ca 0F46     		mov	r7, r1
 306 00cc FFF7FEFF 		bl	__aeabi_dcmpge
 307              	.LVL39:
 308 00d0 68B1     		cbz	r0, .L25
 309              		.loc 1 101 0 is_stmt 0 discriminator 1
 310 00d2 A1A3     		adr	r3, .L89+8
 311 00d4 D3E90023 		ldrd	r2, [r3]
 312 00d8 3046     		mov	r0, r6
 313 00da 3946     		mov	r1, r7
 314 00dc FFF7FEFF 		bl	__aeabi_dsub
 315              	.LVL40:
 316              	.L84:
 102:grbl/motion_control.c ****   } else {
 103:grbl/motion_control.c ****     if (angular_travel <= ARC_ANGULAR_TRAVEL_EPSILON) { angular_travel += 2*M_PI; }
 317              		.loc 1 103 0 is_stmt 1 discriminator 1
 318 00e0 FFF7FEFF 		bl	__aeabi_d2f
 319              	.LVL41:
 320 00e4 0590     		str	r0, [sp, #20]	@ float
 321              	.LVL42:
 322 00e6 FFF7FEFF 		bl	__aeabi_f2d
 323              	.LVL43:
 324 00ea 0646     		mov	r6, r0
 325 00ec 0F46     		mov	r7, r1
 326              	.L25:
 104:grbl/motion_control.c ****   }
 105:grbl/motion_control.c **** 
 106:grbl/motion_control.c ****   // NOTE: Segment end points are on the arc, which can lead to the arc diameter being smaller by u
 107:grbl/motion_control.c ****   // (2x) settings.arc_tolerance. For 99% of users, this is just fine. If a different arc segment f
 108:grbl/motion_control.c ****   // is desired, i.e. least-squares, midpoint on arc, just change the mm_per_arc_segment calculatio
 109:grbl/motion_control.c ****   // For the intended uses of Grbl, this value shouldn't exceed 2000 for the strictest of cases.
 110:grbl/motion_control.c ****   uint16_t segments = floor(fabs(0.5*angular_travel*radius)/
 111:grbl/motion_control.c ****                           sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 327              		.loc 1 111 0
 328 00ee 9E4B     		ldr	r3, .L89+24
 329 00f0 2146     		mov	r1, r4
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 9


 330 00f2 D3F83C90 		ldr	r9, [r3, #60]	@ float
 331              	.LVL44:
 332 00f6 2046     		mov	r0, r4
 333 00f8 FFF7FEFF 		bl	__aeabi_fadd
 334              	.LVL45:
 335 00fc 4946     		mov	r1, r9
 336 00fe FFF7FEFF 		bl	__aeabi_fsub
 337              	.LVL46:
 338 0102 4946     		mov	r1, r9
 339 0104 FFF7FEFF 		bl	__aeabi_fmul
 340              	.LVL47:
 341 0108 FFF7FEFF 		bl	sqrtf
 342              	.LVL48:
 110:grbl/motion_control.c ****                           sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 343              		.loc 1 110 0
 344 010c 0022     		movs	r2, #0
 345 010e 974B     		ldr	r3, .L89+28
 346              		.loc 1 111 0
 347 0110 8146     		mov	r9, r0
 110:grbl/motion_control.c ****                           sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 348              		.loc 1 110 0
 349 0112 3946     		mov	r1, r7
 350 0114 3046     		mov	r0, r6
 351 0116 FFF7FEFF 		bl	__aeabi_dmul
 352              	.LVL49:
 353 011a 0646     		mov	r6, r0
 354 011c 2046     		mov	r0, r4
 355 011e 0F46     		mov	r7, r1
 356 0120 FFF7FEFF 		bl	__aeabi_f2d
 357              	.LVL50:
 358 0124 0246     		mov	r2, r0
 359 0126 0B46     		mov	r3, r1
 360 0128 3046     		mov	r0, r6
 361 012a 3946     		mov	r1, r7
 362 012c FFF7FEFF 		bl	__aeabi_dmul
 363              	.LVL51:
 364 0130 0446     		mov	r4, r0
 365              		.loc 1 111 0
 366 0132 4846     		mov	r0, r9
 110:grbl/motion_control.c ****                           sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 367              		.loc 1 110 0
 368 0134 21F00046 		bic	r6, r1, #-2147483648
 369              		.loc 1 111 0
 370 0138 FFF7FEFF 		bl	__aeabi_f2d
 371              	.LVL52:
 110:grbl/motion_control.c ****                           sqrtf(settings.arc_tolerance*(2*radius - settings.arc_tolerance)) );
 372              		.loc 1 110 0
 373 013c 0B46     		mov	r3, r1
 374 013e 0246     		mov	r2, r0
 375 0140 3146     		mov	r1, r6
 376 0142 2046     		mov	r0, r4
 377 0144 FFF7FEFF 		bl	__aeabi_ddiv
 378              	.LVL53:
 379 0148 FFF7FEFF 		bl	floor
 380              	.LVL54:
 381 014c FFF7FEFF 		bl	__aeabi_d2uiz
 382              	.LVL55:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 10


 383 0150 83B2     		uxth	r3, r0
 384 0152 0093     		str	r3, [sp]
 385              	.LVL56:
 112:grbl/motion_control.c **** 
 113:grbl/motion_control.c ****   if (segments) {
 386              		.loc 1 113 0
 387 0154 002B     		cmp	r3, #0
 388 0156 00F06081 		beq	.L85
 389 015a 1846     		mov	r0, r3
 390 015c FFF7FEFF 		bl	__aeabi_i2f
 391              	.LVL57:
 392              	.LBB19:
 114:grbl/motion_control.c ****     // Multiply inverse feed_rate to compensate for the fact that this movement is approximated
 115:grbl/motion_control.c ****     // by a number of discrete segments. The inverse feed_rate should be correct for the sum of
 116:grbl/motion_control.c ****     // all segments.
 117:grbl/motion_control.c ****     if (pl_data->condition & PL_COND_FLAG_INVERSE_TIME) { 
 393              		.loc 1 117 0
 394 0160 079F     		ldr	r7, [sp, #28]
 395 0162 0646     		mov	r6, r0
 396 0164 3C7A     		ldrb	r4, [r7, #8]	@ zero_extendqisi2
 397 0166 2107     		lsls	r1, r4, #28
 398 0168 00F14E81 		bmi	.L86
 399              	.L29:
 118:grbl/motion_control.c ****       pl_data->feed_rate *= segments; 
 119:grbl/motion_control.c ****       bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over 
 120:grbl/motion_control.c ****     }
 121:grbl/motion_control.c ****     
 122:grbl/motion_control.c ****     float theta_per_segment = angular_travel/segments;
 400              		.loc 1 122 0
 401 016c 3146     		mov	r1, r6
 402 016e 0598     		ldr	r0, [sp, #20]	@ float
 403 0170 FFF7FEFF 		bl	__aeabi_fdiv
 404              	.LVL58:
 123:grbl/motion_control.c ****     float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
 405              		.loc 1 123 0
 406 0174 0B9B     		ldr	r3, [sp, #44]
 122:grbl/motion_control.c ****     float linear_per_segment = (target[axis_linear] - position[axis_linear])/segments;
 407              		.loc 1 122 0
 408 0176 0446     		mov	r4, r0
 409 0178 0C90     		str	r0, [sp, #48]	@ float
 410              	.LVL59:
 411              		.loc 1 123 0
 412 017a 5BF82A10 		ldr	r1, [fp, r10, lsl #2]	@ float
 413 017e 53F82A00 		ldr	r0, [r3, r10, lsl #2]	@ float
 414              	.LVL60:
 415 0182 FFF7FEFF 		bl	__aeabi_fsub
 416              	.LVL61:
 417 0186 3146     		mov	r1, r6
 418 0188 FFF7FEFF 		bl	__aeabi_fdiv
 419              	.LVL62:
 124:grbl/motion_control.c **** 
 125:grbl/motion_control.c ****     /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vecto
 126:grbl/motion_control.c ****        and phi is the angle of rotation. Solution approach by Jens Geisler.
 127:grbl/motion_control.c ****            r_T = [cos(phi) -sin(phi);
 128:grbl/motion_control.c ****                   sin(phi)  cos(phi] * r ;
 129:grbl/motion_control.c **** 
 130:grbl/motion_control.c ****        For arc generation, the center of the circle is the axis of rotation and the radius vector i
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 11


 131:grbl/motion_control.c ****        defined from the circle center to the initial position. Each line segment is formed by succe
 132:grbl/motion_control.c ****        vector rotations. Single precision values can accumulate error greater than tool precision i
 133:grbl/motion_control.c ****        cases. So, exact arc path correction is implemented. This approach avoids the problem of too
 134:grbl/motion_control.c ****        expensive trig operations [sin(),cos(),tan()] which can take 100-200 usec each to compute.
 135:grbl/motion_control.c **** 
 136:grbl/motion_control.c ****        Small angle approximation may be used to reduce computation overhead further. A third-order 
 137:grbl/motion_control.c ****        (second order sin() has too much error) holds for most, if not, all CNC applications. Note t
 138:grbl/motion_control.c ****        approximation will begin to accumulate a numerical drift error when theta_per_segment is gre
 139:grbl/motion_control.c ****        ~0.25 rad(14 deg) AND the approximation is successively used without correction several doze
 140:grbl/motion_control.c ****        scenario is extremely unlikely, since segment lengths and theta_per_segment are automaticall
 141:grbl/motion_control.c ****        and scaled by the arc tolerance setting. Only a very large arc tolerance setting, unrealisti
 142:grbl/motion_control.c ****        applications, would cause this numerical drift error. However, it is best to set N_ARC_CORRE
 143:grbl/motion_control.c ****        low of ~4 to a high of ~20 or so to avoid trig operations while keeping arc generation accur
 144:grbl/motion_control.c **** 
 145:grbl/motion_control.c ****        This approximation also allows mc_arc to immediately insert a line segment into the planner
 146:grbl/motion_control.c ****        without the initial overhead of computing cos() or sin(). By the time the arc needs to be ap
 147:grbl/motion_control.c ****        a correction, the planner should have caught up to the lag caused by the initial mc_arc over
 148:grbl/motion_control.c ****        This is important when there are successive arc motions.
 149:grbl/motion_control.c ****     */
 150:grbl/motion_control.c ****     // Computes: cos_T = 1 - theta_per_segment^2/2, sin_T = theta_per_segment - theta_per_segment^3
 151:grbl/motion_control.c ****     float cos_T = 2.0 - theta_per_segment*theta_per_segment;
 420              		.loc 1 151 0
 421 018c 2146     		mov	r1, r4
 123:grbl/motion_control.c **** 
 422              		.loc 1 123 0
 423 018e 0590     		str	r0, [sp, #20]	@ float
 424              	.LVL63:
 425              		.loc 1 151 0
 426 0190 2046     		mov	r0, r4
 427              	.LVL64:
 428 0192 FFF7FEFF 		bl	__aeabi_fmul
 429              	.LVL65:
 430 0196 0146     		mov	r1, r0
 431 0198 4FF08040 		mov	r0, #1073741824
 432 019c FFF7FEFF 		bl	__aeabi_fsub
 433              	.LVL66:
 434 01a0 2646     		mov	r6, r4
 435 01a2 0446     		mov	r4, r0
 436              	.LVL67:
 152:grbl/motion_control.c ****     float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
 437              		.loc 1 152 0
 438 01a4 3046     		mov	r0, r6
 439              	.LVL68:
 440 01a6 FFF7FEFF 		bl	__aeabi_f2d
 441              	.LVL69:
 442 01aa 6DA3     		adr	r3, .L89+16
 443 01ac D3E90023 		ldrd	r2, [r3]
 444 01b0 FFF7FEFF 		bl	__aeabi_dmul
 445              	.LVL70:
 446 01b4 0646     		mov	r6, r0
 447              	.LVL71:
 448 01b6 2046     		mov	r0, r4
 449 01b8 0F46     		mov	r7, r1
 450 01ba FFF7FEFF 		bl	__aeabi_f2d
 451              	.LVL72:
 452 01be 0022     		movs	r2, #0
 453 01c0 6B4B     		ldr	r3, .L89+32
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 12


 454 01c2 FFF7FEFF 		bl	__aeabi_dadd
 455              	.LVL73:
 456 01c6 0B46     		mov	r3, r1
 457 01c8 0246     		mov	r2, r0
 458 01ca 3946     		mov	r1, r7
 459 01cc 3046     		mov	r0, r6
 460 01ce FFF7FEFF 		bl	__aeabi_dmul
 461              	.LVL74:
 462 01d2 FFF7FEFF 		bl	__aeabi_d2f
 463              	.LVL75:
 153:grbl/motion_control.c ****     cos_T *= 0.5;
 464              		.loc 1 153 0
 465 01d6 4FF07C51 		mov	r1, #1056964608
 152:grbl/motion_control.c ****     float sin_T = theta_per_segment*0.16666667*(cos_T + 4.0);
 466              		.loc 1 152 0
 467 01da 0690     		str	r0, [sp, #24]	@ float
 468              	.LVL76:
 469              		.loc 1 153 0
 470 01dc 2046     		mov	r0, r4
 471              	.LVL77:
 472 01de FFF7FEFF 		bl	__aeabi_fmul
 473              	.LVL78:
 154:grbl/motion_control.c **** 
 155:grbl/motion_control.c ****     float sin_Ti;
 156:grbl/motion_control.c ****     float cos_Ti;
 157:grbl/motion_control.c ****     float r_axisi;
 158:grbl/motion_control.c ****     uint16_t i;
 159:grbl/motion_control.c ****     uint8_t count = 0;
 160:grbl/motion_control.c **** 
 161:grbl/motion_control.c ****     for (i = 1; i<segments; i++) { // Increment (segments-1).
 474              		.loc 1 161 0
 475 01e2 009B     		ldr	r3, [sp]
 123:grbl/motion_control.c **** 
 476              		.loc 1 123 0
 477 01e4 0BEB8A07 		add	r7, fp, r10, lsl #2
 478              		.loc 1 161 0
 479 01e8 012B     		cmp	r3, #1
 153:grbl/motion_control.c ****     cos_T *= 0.5;
 480              		.loc 1 153 0
 481 01ea 0D90     		str	r0, [sp, #52]	@ float
 482              	.LVL79:
 483              		.loc 1 161 0
 484 01ec 00F01581 		beq	.L85
 485 01f0 0126     		movs	r6, #1
 159:grbl/motion_control.c **** 
 486              		.loc 1 159 0
 487 01f2 4FF00009 		mov	r9, #0
 488 01f6 5F4C     		ldr	r4, .L89+36
 489 01f8 CDF828B0 		str	fp, [sp, #40]
 490              	.LVL80:
 491              	.L42:
 162:grbl/motion_control.c **** 
 163:grbl/motion_control.c ****       if (count < N_ARC_CORRECTION) {
 492              		.loc 1 163 0
 493 01fc B9F10B0F 		cmp	r9, #11
 494 0200 00F2BA80 		bhi	.L30
 164:grbl/motion_control.c ****         // Apply vector rotation matrix. ~40 usec
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 13


 165:grbl/motion_control.c ****         r_axisi = r_axis0*sin_T + r_axis1*cos_T;
 495              		.loc 1 165 0
 496 0204 2946     		mov	r1, r5
 497 0206 0698     		ldr	r0, [sp, #24]	@ float
 498 0208 FFF7FEFF 		bl	__aeabi_fmul
 499              	.LVL81:
 500 020c DDF834B0 		ldr	fp, [sp, #52]	@ float
 501 0210 8246     		mov	r10, r0
 502 0212 4146     		mov	r1, r8
 503 0214 5846     		mov	r0, fp
 504 0216 FFF7FEFF 		bl	__aeabi_fmul
 505              	.LVL82:
 506 021a 0146     		mov	r1, r0
 507 021c 5046     		mov	r0, r10
 508 021e FFF7FEFF 		bl	__aeabi_fadd
 509              	.LVL83:
 166:grbl/motion_control.c ****         r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
 510              		.loc 1 166 0
 511 0222 2946     		mov	r1, r5
 165:grbl/motion_control.c ****         r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
 512              		.loc 1 165 0
 513 0224 8246     		mov	r10, r0
 514              	.LVL84:
 515              		.loc 1 166 0
 516 0226 5846     		mov	r0, fp
 517              	.LVL85:
 518 0228 FFF7FEFF 		bl	__aeabi_fmul
 519              	.LVL86:
 520 022c 4146     		mov	r1, r8
 521 022e 0546     		mov	r5, r0
 522              	.LVL87:
 523 0230 0698     		ldr	r0, [sp, #24]	@ float
 524 0232 FFF7FEFF 		bl	__aeabi_fmul
 525              	.LVL88:
 526 0236 0146     		mov	r1, r0
 527 0238 2846     		mov	r0, r5
 528 023a FFF7FEFF 		bl	__aeabi_fsub
 529              	.LVL89:
 167:grbl/motion_control.c ****         r_axis1 = r_axisi;
 530              		.loc 1 167 0
 531 023e D046     		mov	r8, r10
 532              	.LVL90:
 166:grbl/motion_control.c ****         r_axis0 = r_axis0*cos_T - r_axis1*sin_T;
 533              		.loc 1 166 0
 534 0240 0546     		mov	r5, r0
 535              	.LVL91:
 168:grbl/motion_control.c ****         count++;
 536              		.loc 1 168 0
 537 0242 09F10109 		add	r9, r9, #1
 538              	.LVL92:
 539 0246 5FFA89F9 		uxtb	r9, r9
 540              	.LVL93:
 541              	.L31:
 169:grbl/motion_control.c ****       } else {
 170:grbl/motion_control.c ****         // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments. ~375 u
 171:grbl/motion_control.c ****         // Compute exact location by applying transformation matrix from initial radius vector(=-of
 172:grbl/motion_control.c ****         cos_Ti = cosf(i*theta_per_segment);
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 14


 173:grbl/motion_control.c ****         sin_Ti = sinf(i*theta_per_segment);
 174:grbl/motion_control.c ****         r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
 175:grbl/motion_control.c ****         r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 176:grbl/motion_control.c ****         count = 0;
 177:grbl/motion_control.c ****       }
 178:grbl/motion_control.c **** 
 179:grbl/motion_control.c ****       // Update arc_target location
 180:grbl/motion_control.c ****       position[axis_0] = center_axis0 + r_axis0;
 542              		.loc 1 180 0
 543 024a 0399     		ldr	r1, [sp, #12]	@ float
 544 024c 2846     		mov	r0, r5
 545 024e FFF7FEFF 		bl	__aeabi_fadd
 546              	.LVL94:
 547 0252 019B     		ldr	r3, [sp, #4]
 181:grbl/motion_control.c ****       position[axis_1] = center_axis1 + r_axis1;
 548              		.loc 1 181 0
 549 0254 0499     		ldr	r1, [sp, #16]	@ float
 180:grbl/motion_control.c ****       position[axis_1] = center_axis1 + r_axis1;
 550              		.loc 1 180 0
 551 0256 1860     		str	r0, [r3]	@ float
 552              		.loc 1 181 0
 553 0258 4046     		mov	r0, r8
 554 025a FFF7FEFF 		bl	__aeabi_fadd
 555              	.LVL95:
 556 025e 029B     		ldr	r3, [sp, #8]
 182:grbl/motion_control.c ****       position[axis_linear] += linear_per_segment;
 557              		.loc 1 182 0
 558 0260 0599     		ldr	r1, [sp, #20]	@ float
 181:grbl/motion_control.c ****       position[axis_1] = center_axis1 + r_axis1;
 559              		.loc 1 181 0
 560 0262 1860     		str	r0, [r3]	@ float
 561              		.loc 1 182 0
 562 0264 3868     		ldr	r0, [r7]	@ float
 563 0266 FFF7FEFF 		bl	__aeabi_fadd
 564              	.LVL96:
 565              	.LBB20:
 566              	.LBB21:
  37:grbl/motion_control.c ****     // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
 567              		.loc 1 37 0
 568 026a 3F4B     		ldr	r3, .L89+24
 569              	.LBE21:
 570              	.LBE20:
 571              		.loc 1 182 0
 572 026c 3860     		str	r0, [r7]	@ float
 573              	.LBB26:
 574              	.LBB24:
  37:grbl/motion_control.c ****     // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
 575              		.loc 1 37 0
 576 026e 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 577 0272 9A06     		lsls	r2, r3, #26
 578 0274 05D5     		bpl	.L32
  39:grbl/motion_control.c ****   }
 579              		.loc 1 39 0
 580 0276 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 581 0278 202B     		cmp	r3, #32
 582 027a 0BD0     		beq	.L34
 583 027c 0A98     		ldr	r0, [sp, #40]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 15


 584 027e FFF7FEFF 		bl	limits_soft_check
 585              	.LVL97:
 586              	.L32:
  43:grbl/motion_control.c **** 
 587              		.loc 1 43 0
 588 0282 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 589 0284 022B     		cmp	r3, #2
 590 0286 05D1     		bne	.L34
 591 0288 21E0     		b	.L36
 592              	.L87:
  64:grbl/motion_control.c ****     else { break; }
 593              		.loc 1 64 0
 594 028a FFF7FEFF 		bl	plan_check_full_buffer
 595              	.LVL98:
 596 028e 48B1     		cbz	r0, .L39
 597 0290 FFF7FEFF 		bl	protocol_auto_cycle_start
 598              	.LVL99:
 599              	.L34:
  62:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
 600              		.loc 1 62 0
 601 0294 FFF7FEFF 		bl	protocol_execute_realtime
 602              	.LVL100:
  63:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
 603              		.loc 1 63 0
 604 0298 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 605 029a 002B     		cmp	r3, #0
 606 029c F5D0     		beq	.L87
 607              	.LVL101:
 608              	.L23:
 609              	.LBE24:
 610              	.LBE26:
 611              	.LBE19:
 183:grbl/motion_control.c **** 
 184:grbl/motion_control.c ****       mc_line(position, pl_data);
 185:grbl/motion_control.c **** 
 186:grbl/motion_control.c ****       // Bail mid-circle on system abort. Runtime command check already performed by mc_line.
 187:grbl/motion_control.c ****       if (sys.abort) { return; }
 188:grbl/motion_control.c ****     }
 189:grbl/motion_control.c ****   }
 190:grbl/motion_control.c ****   // Ensure last segment arrives at target location.
 191:grbl/motion_control.c ****   mc_line(target, pl_data);
 192:grbl/motion_control.c **** }
 612              		.loc 1 192 0
 613 029e 0FB0     		add	sp, sp, #60
 614              	.LCFI4:
 615              		.cfi_remember_state
 616              		.cfi_def_cfa_offset 36
 617              	.LVL102:
 618              		@ sp needed
 619 02a0 BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 620              	.LVL103:
 621              	.L39:
 622              	.LCFI5:
 623              		.cfi_restore_state
 624              	.LBB28:
 625              	.LBB27:
 626              	.LBB25:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 16


  69:grbl/motion_control.c ****     if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 627              		.loc 1 69 0
 628 02a4 DDF81CA0 		ldr	r10, [sp, #28]
 629 02a8 0A98     		ldr	r0, [sp, #40]
 630 02aa 5146     		mov	r1, r10
 631 02ac FFF7FEFF 		bl	plan_buffer_line
 632              	.LVL104:
 633 02b0 68B9     		cbnz	r0, .L36
  70:grbl/motion_control.c ****       // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
 634              		.loc 1 70 0
 635 02b2 2D4B     		ldr	r3, .L89+24
 636 02b4 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 637 02b8 9B07     		lsls	r3, r3, #30
 638 02ba 08D5     		bpl	.L36
  73:grbl/motion_control.c ****         spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
 639              		.loc 1 73 0
 640 02bc 9AF80830 		ldrb	r3, [r10, #8]	@ zero_extendqisi2
 641 02c0 D806     		lsls	r0, r3, #27
 642 02c2 04D5     		bpl	.L36
 643              	.LVL105:
 644              	.LBB22:
 645              	.LBB23:
  74:grbl/motion_control.c ****       }
 646              		.loc 1 74 0
 647 02c4 079B     		ldr	r3, [sp, #28]
 648 02c6 1020     		movs	r0, #16
 649 02c8 5968     		ldr	r1, [r3, #4]	@ float
 650 02ca FFF7FEFF 		bl	spindle_sync
 651              	.LVL106:
 652              	.L36:
 653              	.LBE23:
 654              	.LBE22:
 655              	.LBE25:
 656              	.LBE27:
 187:grbl/motion_control.c ****     }
 657              		.loc 1 187 0
 658 02ce 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 659 02d0 002B     		cmp	r3, #0
 660 02d2 E4D1     		bne	.L23
 661              	.LVL107:
 662 02d4 0136     		adds	r6, r6, #1
 663              	.LVL108:
 161:grbl/motion_control.c **** 
 664              		.loc 1 161 0 discriminator 2
 665 02d6 009A     		ldr	r2, [sp]
 666 02d8 B3B2     		uxth	r3, r6
 667 02da 9342     		cmp	r3, r2
 668 02dc 8ED3     		bcc	.L42
 669              	.LVL109:
 670              	.L28:
 671              	.LBE28:
 672              	.LBB29:
 673              	.LBB30:
  37:grbl/motion_control.c ****     // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
 674              		.loc 1 37 0
 675 02de 224B     		ldr	r3, .L89+24
 676 02e0 93F84820 		ldrb	r2, [r3, #72]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 17


 677 02e4 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 678 02e6 9106     		lsls	r1, r2, #26
 679 02e8 05D5     		bpl	.L43
  39:grbl/motion_control.c ****   }
 680              		.loc 1 39 0
 681 02ea 202B     		cmp	r3, #32
 682 02ec 0FD0     		beq	.L45
 683 02ee 0B98     		ldr	r0, [sp, #44]
 684 02f0 FFF7FEFF 		bl	limits_soft_check
 685              	.LVL110:
 686 02f4 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 687              	.L43:
  43:grbl/motion_control.c **** 
 688              		.loc 1 43 0
 689 02f6 022B     		cmp	r3, #2
 690 02f8 D1D0     		beq	.L23
  62:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
 691              		.loc 1 62 0
 692 02fa FFF7FEFF 		bl	protocol_execute_realtime
 693              	.LVL111:
  63:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
 694              		.loc 1 63 0
 695 02fe 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 696 0300 002B     		cmp	r3, #0
 697 0302 CCD1     		bne	.L23
  64:grbl/motion_control.c ****     else { break; }
 698              		.loc 1 64 0
 699 0304 FFF7FEFF 		bl	plan_check_full_buffer
 700              	.LVL112:
 701 0308 50B1     		cbz	r0, .L47
 702              	.L88:
 703 030a FFF7FEFF 		bl	protocol_auto_cycle_start
 704              	.LVL113:
 705              	.L45:
  62:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
 706              		.loc 1 62 0
 707 030e FFF7FEFF 		bl	protocol_execute_realtime
 708              	.LVL114:
  63:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
 709              		.loc 1 63 0
 710 0312 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 711 0314 002B     		cmp	r3, #0
 712 0316 C2D1     		bne	.L23
  64:grbl/motion_control.c ****     else { break; }
 713              		.loc 1 64 0
 714 0318 FFF7FEFF 		bl	plan_check_full_buffer
 715              	.LVL115:
 716 031c 0028     		cmp	r0, #0
 717 031e F4D1     		bne	.L88
 718              	.L47:
  69:grbl/motion_control.c ****     if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 719              		.loc 1 69 0
 720 0320 079C     		ldr	r4, [sp, #28]
 721 0322 0B98     		ldr	r0, [sp, #44]
 722 0324 2146     		mov	r1, r4
 723 0326 FFF7FEFF 		bl	plan_buffer_line
 724              	.LVL116:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 18


 725 032a 0028     		cmp	r0, #0
 726 032c B7D1     		bne	.L23
  70:grbl/motion_control.c ****       // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
 727              		.loc 1 70 0
 728 032e 0E4B     		ldr	r3, .L89+24
 729 0330 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 730 0334 9A07     		lsls	r2, r3, #30
 731 0336 B2D5     		bpl	.L23
  73:grbl/motion_control.c ****         spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
 732              		.loc 1 73 0
 733 0338 237A     		ldrb	r3, [r4, #8]	@ zero_extendqisi2
 734 033a DB06     		lsls	r3, r3, #27
 735 033c AFD5     		bpl	.L23
 736              	.LVL117:
 737              	.LBB31:
 738              	.LBB32:
  74:grbl/motion_control.c ****       }
 739              		.loc 1 74 0
 740 033e 1020     		movs	r0, #16
 741 0340 079B     		ldr	r3, [sp, #28]
 742 0342 5968     		ldr	r1, [r3, #4]	@ float
 743              	.LBE32:
 744              	.LBE31:
 745              	.LBE30:
 746              	.LBE29:
 747              		.loc 1 192 0
 748 0344 0FB0     		add	sp, sp, #60
 749              	.LCFI6:
 750              		.cfi_remember_state
 751              		.cfi_def_cfa_offset 36
 752              	.LVL118:
 753              		@ sp needed
 754 0346 BDE8F04F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 755              	.LCFI7:
 756              		.cfi_restore 14
 757              		.cfi_restore 11
 758              		.cfi_restore 10
 759              		.cfi_restore 9
 760              		.cfi_restore 8
 761              		.cfi_restore 7
 762              		.cfi_restore 6
 763              		.cfi_restore 5
 764              		.cfi_restore 4
 765              		.cfi_def_cfa_offset 0
 766              	.LVL119:
 767              	.LBB36:
 768              	.LBB35:
 769              	.LBB34:
 770              	.LBB33:
  74:grbl/motion_control.c ****       }
 771              		.loc 1 74 0
 772 034a FFF7FEBF 		b	spindle_sync
 773              	.LVL120:
 774              	.L90:
 775 034e 00BF     		.align	3
 776              	.L89:
 777 0350 8DEDB5A0 		.word	2696277389
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 19


 778 0354 F7C6A0BE 		.word	-1096759561
 779 0358 182D4454 		.word	1413754136
 780 035c FB211940 		.word	1075388923
 781 0360 4BDA7D5C 		.word	1551751755
 782 0364 5555C53F 		.word	1069897045
 783 0368 00000000 		.word	settings
 784 036c 0000E03F 		.word	1071644672
 785 0370 00001040 		.word	1074790400
 786 0374 00000000 		.word	sys
 787              	.LVL121:
 788              	.L30:
 789              	.LCFI8:
 790              		.cfi_restore_state
 791              	.LBE33:
 792              	.LBE34:
 793              	.LBE35:
 794              	.LBE36:
 795              	.LBB37:
 172:grbl/motion_control.c ****         sin_Ti = sinf(i*theta_per_segment);
 796              		.loc 1 172 0
 797 0378 3046     		mov	r0, r6
 798 037a FFF7FEFF 		bl	__aeabi_i2f
 799              	.LVL122:
 800 037e 0C99     		ldr	r1, [sp, #48]	@ float
 801 0380 FFF7FEFF 		bl	__aeabi_fmul
 802              	.LVL123:
 803 0384 0546     		mov	r5, r0
 804              	.LVL124:
 805 0386 FFF7FEFF 		bl	cosf
 806              	.LVL125:
 807 038a 8146     		mov	r9, r0
 808              	.LVL126:
 173:grbl/motion_control.c ****         r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
 809              		.loc 1 173 0
 810 038c 2846     		mov	r0, r5
 811              	.LVL127:
 812 038e FFF7FEFF 		bl	sinf
 813              	.LVL128:
 174:grbl/motion_control.c ****         r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 814              		.loc 1 174 0
 815 0392 089B     		ldr	r3, [sp, #32]
 173:grbl/motion_control.c ****         r_axis0 = -offset[axis_0]*cos_Ti + offset[axis_1]*sin_Ti;
 816              		.loc 1 173 0
 817 0394 8246     		mov	r10, r0
 818              	.LVL129:
 174:grbl/motion_control.c ****         r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 819              		.loc 1 174 0
 820 0396 1B68     		ldr	r3, [r3]
 821 0398 4946     		mov	r1, r9
 822 039a 03F1004B 		add	fp, r3, #-2147483648
 823 039e 099B     		ldr	r3, [sp, #36]
 824 03a0 5846     		mov	r0, fp
 825              	.LVL130:
 826 03a2 D3F80080 		ldr	r8, [r3]	@ float
 827              	.LVL131:
 828 03a6 FFF7FEFF 		bl	__aeabi_fmul
 829              	.LVL132:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 20


 830 03aa 5146     		mov	r1, r10
 831 03ac 0546     		mov	r5, r0
 832 03ae 4046     		mov	r0, r8
 833 03b0 FFF7FEFF 		bl	__aeabi_fmul
 834              	.LVL133:
 835 03b4 0146     		mov	r1, r0
 836 03b6 2846     		mov	r0, r5
 837 03b8 FFF7FEFF 		bl	__aeabi_fadd
 838              	.LVL134:
 175:grbl/motion_control.c ****         count = 0;
 839              		.loc 1 175 0
 840 03bc 5146     		mov	r1, r10
 174:grbl/motion_control.c ****         r_axis1 = -offset[axis_0]*sin_Ti - offset[axis_1]*cos_Ti;
 841              		.loc 1 174 0
 842 03be 0546     		mov	r5, r0
 843              	.LVL135:
 175:grbl/motion_control.c ****         count = 0;
 844              		.loc 1 175 0
 845 03c0 5846     		mov	r0, fp
 846              	.LVL136:
 847 03c2 FFF7FEFF 		bl	__aeabi_fmul
 848              	.LVL137:
 849 03c6 4946     		mov	r1, r9
 850 03c8 8246     		mov	r10, r0
 851              	.LVL138:
 852 03ca 4046     		mov	r0, r8
 853 03cc FFF7FEFF 		bl	__aeabi_fmul
 854              	.LVL139:
 855 03d0 0146     		mov	r1, r0
 856 03d2 5046     		mov	r0, r10
 857 03d4 FFF7FEFF 		bl	__aeabi_fsub
 858              	.LVL140:
 176:grbl/motion_control.c ****       }
 859              		.loc 1 176 0
 860 03d8 4FF00009 		mov	r9, #0
 861              	.LVL141:
 175:grbl/motion_control.c ****         count = 0;
 862              		.loc 1 175 0
 863 03dc 8046     		mov	r8, r0
 864              	.LVL142:
 865 03de 34E7     		b	.L31
 866              	.LVL143:
 867              	.L24:
 868              	.LBE37:
 103:grbl/motion_control.c ****   }
 869              		.loc 1 103 0
 870 03e0 FFF7FEFF 		bl	__aeabi_f2d
 871              	.LVL144:
 872 03e4 0EA3     		adr	r3, .L91
 873 03e6 D3E90023 		ldrd	r2, [r3]
 874 03ea 0646     		mov	r6, r0
 875 03ec 0F46     		mov	r7, r1
 876 03ee FFF7FEFF 		bl	__aeabi_dcmple
 877              	.LVL145:
 878 03f2 0028     		cmp	r0, #0
 879 03f4 3FF47BAE 		beq	.L25
 103:grbl/motion_control.c ****   }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 21


 880              		.loc 1 103 0 is_stmt 0 discriminator 1
 881 03f8 0BA3     		adr	r3, .L91+8
 882 03fa D3E90023 		ldrd	r2, [r3]
 883 03fe 3046     		mov	r0, r6
 884 0400 3946     		mov	r1, r7
 885 0402 FFF7FEFF 		bl	__aeabi_dadd
 886              	.LVL146:
 887 0406 6BE6     		b	.L84
 888              	.LVL147:
 889              	.L86:
 890              	.LBB38:
 118:grbl/motion_control.c ****       bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over 
 891              		.loc 1 118 0 is_stmt 1
 892 0408 0146     		mov	r1, r0
 893 040a 3868     		ldr	r0, [r7]	@ float
 894 040c FFF7FEFF 		bl	__aeabi_fmul
 895              	.LVL148:
 119:grbl/motion_control.c ****     }
 896              		.loc 1 119 0
 897 0410 24F00804 		bic	r4, r4, #8
 118:grbl/motion_control.c ****       bit_false(pl_data->condition,PL_COND_FLAG_INVERSE_TIME); // Force as feed absolute mode over 
 898              		.loc 1 118 0
 899 0414 3860     		str	r0, [r7]	@ float
 119:grbl/motion_control.c ****     }
 900              		.loc 1 119 0
 901 0416 3C72     		strb	r4, [r7, #8]
 902 0418 A8E6     		b	.L29
 903              	.LVL149:
 904              	.L85:
 905 041a 054C     		ldr	r4, .L91+16
 906 041c 5FE7     		b	.L28
 907              	.L92:
 908 041e 00BF     		.align	3
 909              	.L91:
 910 0420 8DEDB5A0 		.word	2696277389
 911 0424 F7C6A03E 		.word	1050724087
 912 0428 182D4454 		.word	1413754136
 913 042c FB211940 		.word	1075388923
 914 0430 00000000 		.word	sys
 915              	.LBE38:
 916              		.cfi_endproc
 917              	.LFE704:
 919              		.section	.text.mc_dwell,"ax",%progbits
 920              		.align	1
 921              		.p2align 2,,3
 922              		.global	mc_dwell
 923              		.syntax unified
 924              		.thumb
 925              		.thumb_func
 926              		.fpu softvfp
 928              	mc_dwell:
 929              	.LFB705:
 193:grbl/motion_control.c **** 
 194:grbl/motion_control.c **** 
 195:grbl/motion_control.c **** // Execute dwell in seconds.
 196:grbl/motion_control.c **** void mc_dwell(float seconds)
 197:grbl/motion_control.c **** {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 22


 930              		.loc 1 197 0
 931              		.cfi_startproc
 932              		@ args = 0, pretend = 0, frame = 0
 933              		@ frame_needed = 0, uses_anonymous_args = 0
 934              	.LVL150:
 198:grbl/motion_control.c ****   if (sys.state == STATE_CHECK_MODE) { return; }
 935              		.loc 1 198 0
 936 0000 074B     		ldr	r3, .L98
 937 0002 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 938 0004 022B     		cmp	r3, #2
 939 0006 09D0     		beq	.L93
 197:grbl/motion_control.c ****   if (sys.state == STATE_CHECK_MODE) { return; }
 940              		.loc 1 197 0
 941 0008 10B5     		push	{r4, lr}
 942              	.LCFI9:
 943              		.cfi_def_cfa_offset 8
 944              		.cfi_offset 4, -8
 945              		.cfi_offset 14, -4
 946 000a 0446     		mov	r4, r0
 199:grbl/motion_control.c ****   protocol_buffer_synchronize();
 947              		.loc 1 199 0
 948 000c FFF7FEFF 		bl	protocol_buffer_synchronize
 949              	.LVL151:
 200:grbl/motion_control.c ****   delay_sec(seconds, DELAY_MODE_DWELL);
 950              		.loc 1 200 0
 951 0010 2046     		mov	r0, r4
 201:grbl/motion_control.c **** }
 952              		.loc 1 201 0
 953 0012 BDE81040 		pop	{r4, lr}
 954              	.LCFI10:
 955              		.cfi_restore 14
 956              		.cfi_restore 4
 957              		.cfi_def_cfa_offset 0
 958              	.LVL152:
 200:grbl/motion_control.c ****   delay_sec(seconds, DELAY_MODE_DWELL);
 959              		.loc 1 200 0
 960 0016 0021     		movs	r1, #0
 961 0018 FFF7FEBF 		b	delay_sec
 962              	.LVL153:
 963              	.L93:
 964 001c 7047     		bx	lr
 965              	.L99:
 966 001e 00BF     		.align	2
 967              	.L98:
 968 0020 00000000 		.word	sys
 969              		.cfi_endproc
 970              	.LFE705:
 972              		.section	.text.mc_homing_cycle,"ax",%progbits
 973              		.align	1
 974              		.p2align 2,,3
 975              		.global	mc_homing_cycle
 976              		.syntax unified
 977              		.thumb
 978              		.thumb_func
 979              		.fpu softvfp
 981              	mc_homing_cycle:
 982              	.LFB706:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 23


 202:grbl/motion_control.c **** 
 203:grbl/motion_control.c **** 
 204:grbl/motion_control.c **** // Perform homing cycle to locate and set machine zero. Only '$H' executes this command.
 205:grbl/motion_control.c **** // NOTE: There should be no motions in the buffer and Grbl must be in an idle state before
 206:grbl/motion_control.c **** // executing the homing cycle. This prevents incorrect buffered plans after homing.
 207:grbl/motion_control.c **** void mc_homing_cycle(uint8_t cycle_mask)
 208:grbl/motion_control.c **** {
 983              		.loc 1 208 0
 984              		.cfi_startproc
 985              		@ args = 0, pretend = 0, frame = 0
 986              		@ frame_needed = 0, uses_anonymous_args = 0
 987              	.LVL154:
 988 0000 10B5     		push	{r4, lr}
 989              	.LCFI11:
 990              		.cfi_def_cfa_offset 8
 991              		.cfi_offset 4, -8
 992              		.cfi_offset 14, -4
 993              		.loc 1 208 0
 994 0002 0446     		mov	r4, r0
 209:grbl/motion_control.c ****   // Check and abort homing cycle, if hard limits are already enabled. Helps prevent problems
 210:grbl/motion_control.c ****   // with machines with limits wired on both ends of travel to one limit pin.
 211:grbl/motion_control.c ****   // TODO: Move the pin-specific LIMIT_PIN call to limits.c as a function.
 212:grbl/motion_control.c ****   #ifdef LIMITS_TWO_SWITCHES_ON_AXES
 213:grbl/motion_control.c ****     if (limits_get_state()) {
 214:grbl/motion_control.c ****       mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
 215:grbl/motion_control.c ****       system_set_exec_alarm(EXEC_ALARM_HARD_LIMIT);
 216:grbl/motion_control.c ****       return;
 217:grbl/motion_control.c ****     }
 218:grbl/motion_control.c ****   #endif
 219:grbl/motion_control.c **** 
 220:grbl/motion_control.c ****   limits_disable(); // Disable hard limits pin change register for cycle duration
 995              		.loc 1 220 0
 996 0004 FFF7FEFF 		bl	limits_disable
 997              	.LVL155:
 221:grbl/motion_control.c **** 
 222:grbl/motion_control.c ****   // -------------------------------------------------------------------------------------
 223:grbl/motion_control.c ****   // Perform homing routine. NOTE: Special motion case. Only system reset works.
 224:grbl/motion_control.c ****   
 225:grbl/motion_control.c ****   #ifdef HOMING_SINGLE_AXIS_COMMANDS
 226:grbl/motion_control.c ****     if (cycle_mask) { limits_go_home(cycle_mask); } // Perform homing cycle based on mask.
 998              		.loc 1 226 0
 999 0008 44B1     		cbz	r4, .L101
 1000              		.loc 1 226 0 is_stmt 0 discriminator 1
 1001 000a 2046     		mov	r0, r4
 1002 000c FFF7FEFF 		bl	limits_go_home
 1003              	.LVL156:
 227:grbl/motion_control.c ****     else
 228:grbl/motion_control.c ****   #endif
 229:grbl/motion_control.c ****   {
 230:grbl/motion_control.c ****     // Search to engage all axes limit switches at faster homing seek rate.
 231:grbl/motion_control.c ****     limits_go_home(HOMING_CYCLE_0);  // Homing cycle 0
 232:grbl/motion_control.c ****     #ifdef HOMING_CYCLE_1
 233:grbl/motion_control.c ****       limits_go_home(HOMING_CYCLE_1);  // Homing cycle 1
 234:grbl/motion_control.c ****     #endif
 235:grbl/motion_control.c ****     #ifdef HOMING_CYCLE_2
 236:grbl/motion_control.c ****       limits_go_home(HOMING_CYCLE_2);  // Homing cycle 2
 237:grbl/motion_control.c ****     #endif
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 24


 238:grbl/motion_control.c ****   }
 239:grbl/motion_control.c **** 
 240:grbl/motion_control.c ****   protocol_execute_realtime(); // Check for reset and set system abort.
 1004              		.loc 1 240 0 is_stmt 1 discriminator 1
 1005 0010 FFF7FEFF 		bl	protocol_execute_realtime
 1006              	.LVL157:
 241:grbl/motion_control.c ****   if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 1007              		.loc 1 241 0 discriminator 1
 1008 0014 0F4B     		ldr	r3, .L106
 1009 0016 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1010 0018 63B1     		cbz	r3, .L105
 1011              	.L100:
 242:grbl/motion_control.c **** 
 243:grbl/motion_control.c ****   // Homing cycle complete! Setup system for normal operation.
 244:grbl/motion_control.c ****   // -------------------------------------------------------------------------------------
 245:grbl/motion_control.c **** 
 246:grbl/motion_control.c ****   // Sync gcode parser and planner positions to homed position.
 247:grbl/motion_control.c ****   gc_sync_position();
 248:grbl/motion_control.c ****   plan_sync_position();
 249:grbl/motion_control.c **** 
 250:grbl/motion_control.c ****   // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
 251:grbl/motion_control.c **** #ifdef STM32
 252:grbl/motion_control.c ****   LL_EXTI_ClearFlag_0_31(LIM_MASK);
 253:grbl/motion_control.c ****   HAL_NVIC_ClearPendingIRQ(EXTI15_10_IRQn);
 254:grbl/motion_control.c ****   HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 255:grbl/motion_control.c **** #endif
 256:grbl/motion_control.c **** }
 1012              		.loc 1 256 0
 1013 001a 10BD     		pop	{r4, pc}
 1014              	.L101:
 231:grbl/motion_control.c ****     #ifdef HOMING_CYCLE_1
 1015              		.loc 1 231 0
 1016 001c 0420     		movs	r0, #4
 1017 001e FFF7FEFF 		bl	limits_go_home
 1018              	.LVL158:
 233:grbl/motion_control.c ****     #endif
 1019              		.loc 1 233 0
 1020 0022 0320     		movs	r0, #3
 1021 0024 FFF7FEFF 		bl	limits_go_home
 1022              	.LVL159:
 240:grbl/motion_control.c ****   if (sys.abort) { return; } // Did not complete. Alarm state set by mc_alarm.
 1023              		.loc 1 240 0
 1024 0028 FFF7FEFF 		bl	protocol_execute_realtime
 1025              	.LVL160:
 241:grbl/motion_control.c **** 
 1026              		.loc 1 241 0
 1027 002c 094B     		ldr	r3, .L106
 1028 002e 5B78     		ldrb	r3, [r3, #1]	@ zero_extendqisi2
 1029 0030 002B     		cmp	r3, #0
 1030 0032 F2D1     		bne	.L100
 1031              	.L105:
 247:grbl/motion_control.c ****   plan_sync_position();
 1032              		.loc 1 247 0
 1033 0034 FFF7FEFF 		bl	gc_sync_position
 1034              	.LVL161:
 248:grbl/motion_control.c **** 
 1035              		.loc 1 248 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 25


 1036 0038 FFF7FEFF 		bl	plan_sync_position
 1037              	.LVL162:
 1038              	.LBB39:
 1039              	.LBB40:
 1040              		.file 2 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h"
   1:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
   2:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   ******************************************************************************
   3:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @file    stm32f1xx_ll_exti.h
   4:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @author  MCD Application Team
   5:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief   Header file of EXTI LL module.
   6:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   ******************************************************************************
   7:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @attention
   8:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *
   9:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * <h2><center>&copy; Copyright (c) 2016 STMicroelectronics.
  10:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * All rights reserved.</center></h2>
  11:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *
  12:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * This software component is licensed by ST under BSD 3-Clause license,
  13:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * the "License"; You may not use this file except in compliance with the
  14:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * License. You may obtain a copy of the License at:
  15:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *                        opensource.org/licenses/BSD-3-Clause
  16:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *
  17:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   ******************************************************************************
  18:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  19:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  20:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Define to prevent recursive inclusion -------------------------------------*/
  21:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #ifndef STM32F1xx_LL_EXTI_H
  22:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define STM32F1xx_LL_EXTI_H
  23:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  24:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #ifdef __cplusplus
  25:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** extern "C" {
  26:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
  27:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  28:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Includes ------------------------------------------------------------------*/
  29:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #include "stm32f1xx.h"
  30:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  31:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @addtogroup STM32F1xx_LL_Driver
  32:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  33:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  34:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  35:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined (EXTI)
  36:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  37:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL EXTI
  38:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  39:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  40:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  41:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Private types -------------------------------------------------------------*/
  42:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Private variables ---------------------------------------------------------*/
  43:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Private constants ---------------------------------------------------------*/
  44:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Private Macros ------------------------------------------------------------*/
  45:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(USE_FULL_LL_DRIVER)
  46:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_Private_Macros EXTI Private Macros
  47:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  48:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  49:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
  50:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
  51:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  52:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif /*USE_FULL_LL_DRIVER*/
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 26


  53:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Exported types ------------------------------------------------------------*/
  54:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(USE_FULL_LL_DRIVER)
  55:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_ES_INIT EXTI Exported Init structure
  56:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  57:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  58:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** typedef struct
  59:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
  60:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  61:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   uint32_t Line_0_31;           /*!< Specifies the EXTI lines to be enabled or disabled for Lines i
  62:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****                                      This parameter can be any combination of @ref EXTI_LL_EC_LINE 
  63:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  64:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   FunctionalState LineCommand;  /*!< Specifies the new state of the selected EXTI lines.
  65:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****                                      This parameter can be set either to ENABLE or DISABLE */
  66:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  67:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   uint8_t Mode;                 /*!< Specifies the mode for the EXTI lines.
  68:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****                                      This parameter can be a value of @ref EXTI_LL_EC_MODE. */
  69:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  70:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   uint8_t Trigger;              /*!< Specifies the trigger signal active edge for the EXTI lines.
  71:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****                                      This parameter can be a value of @ref EXTI_LL_EC_TRIGGER. */
  72:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** } LL_EXTI_InitTypeDef;
  73:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  74:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
  75:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
  76:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  77:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif /*USE_FULL_LL_DRIVER*/
  78:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  79:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Exported constants --------------------------------------------------------*/
  80:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_Exported_Constants EXTI Exported Constants
  81:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  82:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  83:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
  84:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EC_LINE LINE
  85:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
  86:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
  87:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_0                 EXTI_IMR_IM0           /*!< Extended line 0 */
  88:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_1                 EXTI_IMR_IM1           /*!< Extended line 1 */
  89:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_2                 EXTI_IMR_IM2           /*!< Extended line 2 */
  90:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_3                 EXTI_IMR_IM3           /*!< Extended line 3 */
  91:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_4                 EXTI_IMR_IM4           /*!< Extended line 4 */
  92:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_5                 EXTI_IMR_IM5           /*!< Extended line 5 */
  93:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_6                 EXTI_IMR_IM6           /*!< Extended line 6 */
  94:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_7                 EXTI_IMR_IM7           /*!< Extended line 7 */
  95:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_8                 EXTI_IMR_IM8           /*!< Extended line 8 */
  96:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_9                 EXTI_IMR_IM9           /*!< Extended line 9 */
  97:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_10                EXTI_IMR_IM10          /*!< Extended line 10 */
  98:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_11                EXTI_IMR_IM11          /*!< Extended line 11 */
  99:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_12                EXTI_IMR_IM12          /*!< Extended line 12 */
 100:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_13                EXTI_IMR_IM13          /*!< Extended line 13 */
 101:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_14                EXTI_IMR_IM14          /*!< Extended line 14 */
 102:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_15                EXTI_IMR_IM15          /*!< Extended line 15 */
 103:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM16)
 104:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_16                EXTI_IMR_IM16          /*!< Extended line 16 */
 105:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 106:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_17                EXTI_IMR_IM17          /*!< Extended line 17 */
 107:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM18)
 108:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_18                EXTI_IMR_IM18          /*!< Extended line 18 */
 109:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 27


 110:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM19)
 111:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_19                EXTI_IMR_IM19          /*!< Extended line 19 */
 112:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 113:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM20)
 114:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_20                EXTI_IMR_IM20          /*!< Extended line 20 */
 115:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 116:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM21)
 117:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_21                EXTI_IMR_IM21          /*!< Extended line 21 */
 118:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 119:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM22)
 120:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_22                EXTI_IMR_IM22          /*!< Extended line 22 */
 121:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 122:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM23)
 123:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_23                EXTI_IMR_IM23          /*!< Extended line 23 */
 124:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 125:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM24)
 126:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_24                EXTI_IMR_IM24          /*!< Extended line 24 */
 127:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 128:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM25)
 129:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_25                EXTI_IMR_IM25          /*!< Extended line 25 */
 130:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 131:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM26)
 132:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_26                EXTI_IMR_IM26          /*!< Extended line 26 */
 133:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 134:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM27)
 135:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_27                EXTI_IMR_IM27          /*!< Extended line 27 */
 136:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 137:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM28)
 138:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_28                EXTI_IMR_IM28          /*!< Extended line 28 */
 139:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 140:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM29)
 141:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_29                EXTI_IMR_IM29          /*!< Extended line 29 */
 142:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 143:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM30)
 144:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_30                EXTI_IMR_IM30          /*!< Extended line 30 */
 145:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 146:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(EXTI_IMR_IM31)
 147:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_31                EXTI_IMR_IM31          /*!< Extended line 31 */
 148:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif
 149:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_ALL_0_31          EXTI_IMR_IM            /*!< All Extended line not reserved*/
 150:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 151:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 152:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_ALL               (0xFFFFFFFFU)  /*!< All Extended line */
 153:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 154:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(USE_FULL_LL_DRIVER)
 155:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_LINE_NONE              (0x00000000U)  /*!< None Extended line */
 156:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif /*USE_FULL_LL_DRIVER*/
 157:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 158:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 159:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 160:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 161:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #if defined(USE_FULL_LL_DRIVER)
 162:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 163:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EC_MODE Mode
 164:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 165:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 166:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_MODE_IT                 ((uint8_t)0x00) /*!< Interrupt Mode */
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 28


 167:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_MODE_EVENT              ((uint8_t)0x01) /*!< Event Mode */
 168:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_MODE_IT_EVENT           ((uint8_t)0x02) /*!< Interrupt & Event Mode */
 169:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 170:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 171:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 172:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 173:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EC_TRIGGER Edge Trigger
 174:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 175:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 176:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_TRIGGER_NONE            ((uint8_t)0x00) /*!< No Trigger Mode */
 177:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_TRIGGER_RISING          ((uint8_t)0x01) /*!< Trigger Rising Mode */
 178:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_TRIGGER_FALLING         ((uint8_t)0x02) /*!< Trigger Falling Mode */
 179:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_TRIGGER_RISING_FALLING  ((uint8_t)0x03) /*!< Trigger Rising & Falling Mode */
 180:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 181:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 182:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 183:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 184:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 185:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 186:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #endif /*USE_FULL_LL_DRIVER*/
 187:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 188:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 189:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 190:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 191:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 192:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 193:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Exported macro ------------------------------------------------------------*/
 194:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_Exported_Macros EXTI Exported Macros
 195:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 196:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 197:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 198:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EM_WRITE_READ Common Write and read registers Macros
 199:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 200:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 201:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 202:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 203:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Write a value in EXTI register
 204:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  __REG__ Register to be written
 205:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  __VALUE__ Value to be written in the register
 206:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 207:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 208:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_WriteReg(__REG__, __VALUE__) WRITE_REG(EXTI->__REG__, (__VALUE__))
 209:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 210:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 211:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Read a value in EXTI register
 212:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  __REG__ Register to be read
 213:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval Register value
 214:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 215:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** #define LL_EXTI_ReadReg(__REG__) READ_REG(EXTI->__REG__)
 216:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 217:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 218:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 219:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 220:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 221:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 222:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 223:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 29


 224:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 225:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 226:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 227:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /* Exported functions --------------------------------------------------------*/
 228:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_Exported_Functions EXTI Exported Functions
 229:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****  * @{
 230:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****  */
 231:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_IT_Management IT_Management
 232:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 233:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 234:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 235:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 236:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Enable ExtiLine Interrupt request for Lines in range 0 to 31
 237:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The reset value for the direct or internal lines (see RM)
 238:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       is set to 1 in order to enable the interrupt by default.
 239:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Bits are set automatically at Power on.
 240:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll IMR         IMx           LL_EXTI_EnableIT_0_31
 241:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 242:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 243:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 244:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 245:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 246:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 247:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 248:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 249:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 250:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 251:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 252:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 253:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 254:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 255:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 256:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 257:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 258:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 259:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 260:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 261:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 262:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 263:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 264:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 265:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 266:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_EnableIT_0_31(uint32_t ExtiLine)
 267:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 268:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   SET_BIT(EXTI->IMR, ExtiLine);
 269:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 270:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 271:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 272:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Disable ExtiLine Interrupt request for Lines in range 0 to 31
 273:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The reset value for the direct or internal lines (see RM)
 274:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       is set to 1 in order to enable the interrupt by default.
 275:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Bits are set automatically at Power on.
 276:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll IMR         IMx           LL_EXTI_DisableIT_0_31
 277:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 278:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 279:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 280:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 30


 281:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 282:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 283:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 284:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 285:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 286:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 287:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 288:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 289:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 290:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 291:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 292:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 293:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 294:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 295:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 296:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 297:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 298:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 299:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 300:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 301:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 302:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_DisableIT_0_31(uint32_t ExtiLine)
 303:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 304:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   CLEAR_BIT(EXTI->IMR, ExtiLine);
 305:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 306:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 307:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 308:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 309:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Indicate if ExtiLine Interrupt request is enabled for Lines in range 0 to 31
 310:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The reset value for the direct or internal lines (see RM)
 311:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       is set to 1 in order to enable the interrupt by default.
 312:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Bits are set automatically at Power on.
 313:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll IMR         IMx           LL_EXTI_IsEnabledIT_0_31
 314:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 315:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 316:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 317:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 318:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 319:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 320:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 321:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 322:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 323:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 324:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 325:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 326:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 327:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 328:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 329:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 330:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 331:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 332:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 333:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 334:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 335:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 336:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 337:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval State of bit (1 or 0).
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 31


 338:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 339:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_IsEnabledIT_0_31(uint32_t ExtiLine)
 340:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 341:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (READ_BIT(EXTI->IMR, ExtiLine) == (ExtiLine));
 342:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 343:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 344:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 345:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 346:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 347:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 348:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 349:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_Event_Management Event_Management
 350:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 351:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 352:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 353:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 354:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Enable ExtiLine Event request for Lines in range 0 to 31
 355:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll EMR         EMx           LL_EXTI_EnableEvent_0_31
 356:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 357:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 358:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 359:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 360:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 361:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 362:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 363:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 364:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 365:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 366:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 367:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 368:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 369:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 370:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 371:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 372:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 373:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 374:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 375:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 376:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 377:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 378:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 379:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 380:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 381:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_EnableEvent_0_31(uint32_t ExtiLine)
 382:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 383:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   SET_BIT(EXTI->EMR, ExtiLine);
 384:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 385:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 386:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 387:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 388:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 389:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Disable ExtiLine Event request for Lines in range 0 to 31
 390:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll EMR         EMx           LL_EXTI_DisableEvent_0_31
 391:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 392:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 393:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 394:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 32


 395:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 396:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 397:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 398:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 399:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 400:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 401:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 402:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 403:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 404:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 405:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 406:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 407:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 408:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 409:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 410:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 411:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 412:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 413:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 414:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 415:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 416:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_DisableEvent_0_31(uint32_t ExtiLine)
 417:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 418:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   CLEAR_BIT(EXTI->EMR, ExtiLine);
 419:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 420:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 421:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 422:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 423:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Indicate if ExtiLine Event request is enabled for Lines in range 0 to 31
 424:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll EMR         EMx           LL_EXTI_IsEnabledEvent_0_31
 425:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be one of the following values:
 426:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 427:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 428:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 429:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 430:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 431:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 432:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 433:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 434:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 435:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 436:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 437:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 438:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 439:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 440:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 441:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 442:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 443:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_17
 444:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 445:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 446:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_ALL_0_31
 447:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 448:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval State of bit (1 or 0).
 449:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 450:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_IsEnabledEvent_0_31(uint32_t ExtiLine)
 451:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 33


 452:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (READ_BIT(EXTI->EMR, ExtiLine) == (ExtiLine));
 453:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 454:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 455:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 456:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 457:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 458:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 459:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 460:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 461:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_Rising_Trigger_Management Rising_Trigger_Management
 462:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 463:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 464:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 465:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 466:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Enable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
 467:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The configurable wakeup lines are edge-triggered. No glitch must be
 468:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       generated on these lines. If a rising edge on a configurable interrupt
 469:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line occurs during a write operation in the EXTI_RTSR register, the
 470:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       pending bit is not set.
 471:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Rising and falling edge triggers can be set for
 472:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       the same interrupt line. In this case, both generate a trigger
 473:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       condition.
 474:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll RTSR        RTx           LL_EXTI_EnableRisingTrig_0_31
 475:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 476:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 477:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 478:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 479:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 480:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 481:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 482:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 483:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 484:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 485:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 486:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 487:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 488:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 489:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 490:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 491:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 492:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 493:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 494:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 495:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 496:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 497:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 498:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_EnableRisingTrig_0_31(uint32_t ExtiLine)
 499:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 500:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   SET_BIT(EXTI->RTSR, ExtiLine);
 501:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 502:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 503:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 504:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 505:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 506:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Disable ExtiLine Rising Edge Trigger for Lines in range 0 to 31
 507:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The configurable wakeup lines are edge-triggered. No glitch must be
 508:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       generated on these lines. If a rising edge on a configurable interrupt
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 34


 509:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line occurs during a write operation in the EXTI_RTSR register, the
 510:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       pending bit is not set.
 511:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Rising and falling edge triggers can be set for
 512:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       the same interrupt line. In this case, both generate a trigger
 513:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       condition.
 514:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll RTSR        RTx           LL_EXTI_DisableRisingTrig_0_31
 515:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 516:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 517:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 518:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 519:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 520:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 521:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 522:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 523:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 524:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 525:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 526:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 527:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 528:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 529:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 530:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 531:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 532:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 533:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 534:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 535:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 536:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 537:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 538:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_DisableRisingTrig_0_31(uint32_t ExtiLine)
 539:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 540:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   CLEAR_BIT(EXTI->RTSR, ExtiLine);
 541:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 542:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 543:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 544:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 545:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 546:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Check if rising edge trigger is enabled for Lines in range 0 to 31
 547:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll RTSR        RTx           LL_EXTI_IsEnabledRisingTrig_0_31
 548:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 549:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 550:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 551:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 552:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 553:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 554:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 555:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 556:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 557:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 558:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 559:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 560:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 561:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 562:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 563:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 564:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 565:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 35


 566:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 567:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 568:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 569:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval State of bit (1 or 0).
 570:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 571:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_IsEnabledRisingTrig_0_31(uint32_t ExtiLine)
 572:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 573:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (READ_BIT(EXTI->RTSR, ExtiLine) == (ExtiLine));
 574:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 575:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 576:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 577:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 578:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 579:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 580:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 581:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_Falling_Trigger_Management Falling_Trigger_Management
 582:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 583:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 584:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 585:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 586:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Enable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
 587:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The configurable wakeup lines are edge-triggered. No glitch must be
 588:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       generated on these lines. If a falling edge on a configurable interrupt
 589:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line occurs during a write operation in the EXTI_FTSR register, the
 590:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       pending bit is not set.
 591:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Rising and falling edge triggers can be set for
 592:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       the same interrupt line. In this case, both generate a trigger
 593:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       condition.
 594:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll FTSR        FTx           LL_EXTI_EnableFallingTrig_0_31
 595:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 596:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 597:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 598:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 599:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 600:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 601:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 602:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 603:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 604:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 605:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 606:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 607:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 608:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 609:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 610:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 611:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 612:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 613:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 614:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 615:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 616:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 617:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 618:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_EnableFallingTrig_0_31(uint32_t ExtiLine)
 619:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 620:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   SET_BIT(EXTI->FTSR, ExtiLine);
 621:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 622:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 36


 623:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 624:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 625:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Disable ExtiLine Falling Edge Trigger for Lines in range 0 to 31
 626:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note The configurable wakeup lines are edge-triggered. No glitch must be
 627:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       generated on these lines. If a Falling edge on a configurable interrupt
 628:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line occurs during a write operation in the EXTI_FTSR register, the
 629:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       pending bit is not set.
 630:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       Rising and falling edge triggers can be set for the same interrupt line.
 631:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       In this case, both generate a trigger condition.
 632:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll FTSR        FTx           LL_EXTI_DisableFallingTrig_0_31
 633:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 634:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 635:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 636:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 637:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 638:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 639:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 640:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 641:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 642:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 643:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 644:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 645:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 646:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 647:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 648:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 649:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 650:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 651:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 652:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 653:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 654:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 655:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 656:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_DisableFallingTrig_0_31(uint32_t ExtiLine)
 657:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 658:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   CLEAR_BIT(EXTI->FTSR, ExtiLine);
 659:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 660:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 661:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 662:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 663:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Check if falling edge trigger is enabled for Lines in range 0 to 31
 664:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll FTSR        FTx           LL_EXTI_IsEnabledFallingTrig_0_31
 665:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 666:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 667:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 668:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 669:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 670:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 671:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 672:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 673:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 674:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 675:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 676:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 677:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 678:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 679:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 37


 680:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 681:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 682:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 683:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 684:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 685:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 686:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval State of bit (1 or 0).
 687:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 688:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_IsEnabledFallingTrig_0_31(uint32_t ExtiLine)
 689:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 690:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (READ_BIT(EXTI->FTSR, ExtiLine) == (ExtiLine));
 691:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 692:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 693:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 694:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 695:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 696:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 697:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 698:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_Software_Interrupt_Management Software_Interrupt_Management
 699:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 700:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 701:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 702:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 703:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Generate a software Interrupt Event for Lines in range 0 to 31
 704:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note If the interrupt is enabled on this line in the EXTI_IMR, writing a 1 to
 705:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       this bit when it is at '0' sets the corresponding pending bit in EXTI_PR
 706:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       resulting in an interrupt request generation.
 707:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       This bit is cleared by clearing the corresponding bit in the EXTI_PR
 708:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       register (by writing a 1 into the bit)
 709:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll SWIER       SWIx          LL_EXTI_GenerateSWI_0_31
 710:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 711:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 712:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 713:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 714:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 715:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 716:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 717:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 718:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 719:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 720:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 721:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 722:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 723:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 724:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 725:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 726:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 727:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 728:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 729:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 730:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 731:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 732:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 733:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_GenerateSWI_0_31(uint32_t ExtiLine)
 734:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 735:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   SET_BIT(EXTI->SWIER, ExtiLine);
 736:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 38


 737:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 738:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 739:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 740:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @}
 741:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 742:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 743:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /** @defgroup EXTI_LL_EF_Flag_Management Flag_Management
 744:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @{
 745:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 746:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 747:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 748:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Check if the ExtLine Flag is set or not for Lines in range 0 to 31
 749:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note This bit is set when the selected edge event arrives on the interrupt
 750:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line. This bit is cleared by writing a 1 to the bit.
 751:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll PR          PIFx           LL_EXTI_IsActiveFlag_0_31
 752:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 753:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 754:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 755:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 756:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 757:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 758:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 759:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 760:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 761:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 762:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 763:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 764:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 765:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 766:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 767:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 768:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 769:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 770:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 771:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 772:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 773:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval State of bit (1 or 0).
 774:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 775:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_IsActiveFlag_0_31(uint32_t ExtiLine)
 776:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 777:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (READ_BIT(EXTI->PR, ExtiLine) == (ExtiLine));
 778:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 779:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 780:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 781:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 782:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Read ExtLine Combination Flag for Lines in range 0 to 31
 783:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note This bit is set when the selected edge event arrives on the interrupt
 784:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line. This bit is cleared by writing a 1 to the bit.
 785:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll PR          PIFx           LL_EXTI_ReadFlag_0_31
 786:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 787:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 788:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 789:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 790:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 791:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 792:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 793:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 39


 794:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 795:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 796:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 797:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 798:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 799:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 800:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 801:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 802:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 803:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 804:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 805:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 806:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 807:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval @note This bit is set when the selected edge event arrives on the interrupt
 808:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 809:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE uint32_t LL_EXTI_ReadFlag_0_31(uint32_t ExtiLine)
 810:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 811:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   return (uint32_t)(READ_BIT(EXTI->PR, ExtiLine));
 812:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** }
 813:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 814:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** 
 815:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** /**
 816:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @brief  Clear ExtLine Flags  for Lines in range 0 to 31
 817:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note This bit is set when the selected edge event arrives on the interrupt
 818:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *       line. This bit is cleared by writing a 1 to the bit.
 819:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @rmtoll PR          PIFx           LL_EXTI_ClearFlag_0_31
 820:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @param  ExtiLine This parameter can be a combination of the following values:
 821:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_0
 822:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_1
 823:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_2
 824:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_3
 825:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_4
 826:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_5
 827:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_6
 828:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_7
 829:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_8
 830:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_9
 831:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_10
 832:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_11
 833:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_12
 834:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_13
 835:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_14
 836:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_15
 837:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_16
 838:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_18
 839:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   *         @arg @ref LL_EXTI_LINE_19
 840:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @note   Please check each device line mapping for EXTI Line availability
 841:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   * @retval None
 842:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   */
 843:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** __STATIC_INLINE void LL_EXTI_ClearFlag_0_31(uint32_t ExtiLine)
 844:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h **** {
 845:Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_exti.h ****   WRITE_REG(EXTI->PR, ExtiLine);
 1041              		.loc 2 845 0
 1042 003c 4FF4E052 		mov	r2, #7168
 1043 0040 054B     		ldr	r3, .L106+4
 1044              	.LBE40:
 1045              	.LBE39:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 40


 253:grbl/motion_control.c ****   HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 1046              		.loc 1 253 0
 1047 0042 2820     		movs	r0, #40
 1048              	.LBB42:
 1049              	.LBB41:
 1050              		.loc 2 845 0
 1051 0044 5A61     		str	r2, [r3, #20]
 1052              	.LVL163:
 1053              	.LBE41:
 1054              	.LBE42:
 253:grbl/motion_control.c ****   HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 1055              		.loc 1 253 0
 1056 0046 FFF7FEFF 		bl	HAL_NVIC_ClearPendingIRQ
 1057              	.LVL164:
 1058              		.loc 1 256 0
 1059 004a BDE81040 		pop	{r4, lr}
 1060              	.LCFI12:
 1061              		.cfi_restore 14
 1062              		.cfi_restore 4
 1063              		.cfi_def_cfa_offset 0
 254:grbl/motion_control.c **** #endif
 1064              		.loc 1 254 0
 1065 004e 2820     		movs	r0, #40
 1066 0050 FFF7FEBF 		b	HAL_NVIC_EnableIRQ
 1067              	.LVL165:
 1068              	.L107:
 1069              		.align	2
 1070              	.L106:
 1071 0054 00000000 		.word	sys
 1072 0058 00040140 		.word	1073808384
 1073              		.cfi_endproc
 1074              	.LFE706:
 1076              		.section	.text.mc_probe_cycle,"ax",%progbits
 1077              		.align	1
 1078              		.p2align 2,,3
 1079              		.global	mc_probe_cycle
 1080              		.syntax unified
 1081              		.thumb
 1082              		.thumb_func
 1083              		.fpu softvfp
 1085              	mc_probe_cycle:
 1086              	.LFB707:
 257:grbl/motion_control.c **** 
 258:grbl/motion_control.c **** 
 259:grbl/motion_control.c **** // Perform tool length probe cycle. Requires probe switch.
 260:grbl/motion_control.c **** // NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
 261:grbl/motion_control.c **** uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
 262:grbl/motion_control.c **** {
 1087              		.loc 1 262 0
 1088              		.cfi_startproc
 1089              		@ args = 0, pretend = 0, frame = 0
 1090              		@ frame_needed = 0, uses_anonymous_args = 0
 1091              	.LVL166:
 1092 0000 2DE9F041 		push	{r4, r5, r6, r7, r8, lr}
 1093              	.LCFI13:
 1094              		.cfi_def_cfa_offset 24
 1095              		.cfi_offset 4, -24
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 41


 1096              		.cfi_offset 5, -20
 1097              		.cfi_offset 6, -16
 1098              		.cfi_offset 7, -12
 1099              		.cfi_offset 8, -8
 1100              		.cfi_offset 14, -4
 263:grbl/motion_control.c ****   // TODO: Need to update this cycle so it obeys a non-auto cycle start.
 264:grbl/motion_control.c ****   if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
 1101              		.loc 1 264 0
 1102 0004 424C     		ldr	r4, .L142
 1103 0006 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1104 0008 022B     		cmp	r3, #2
 1105 000a 32D0     		beq	.L124
 1106 000c 1546     		mov	r5, r2
 1107 000e 0F46     		mov	r7, r1
 1108 0010 0646     		mov	r6, r0
 265:grbl/motion_control.c **** 
 266:grbl/motion_control.c ****   // Finish all queued commands and empty planner buffer before starting probe cycle.
 267:grbl/motion_control.c ****   protocol_buffer_synchronize();
 1109              		.loc 1 267 0
 1110 0012 FFF7FEFF 		bl	protocol_buffer_synchronize
 1111              	.LVL167:
 268:grbl/motion_control.c ****   if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
 1112              		.loc 1 268 0
 1113 0016 94F80180 		ldrb	r8, [r4, #1]	@ zero_extendqisi2
 1114 001a B8F1000F 		cmp	r8, #0
 1115 001e 25D1     		bne	.L136
 1116              	.LVL168:
 269:grbl/motion_control.c **** 
 270:grbl/motion_control.c ****   // Initialize probing control variables
 271:grbl/motion_control.c ****   uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
 272:grbl/motion_control.c ****   uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
 273:grbl/motion_control.c ****   sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
 274:grbl/motion_control.c ****   probe_configure_invert_mask(is_probe_away);
 1117              		.loc 1 274 0
 1118 0020 C5F3C000 		ubfx	r0, r5, #3, #1
 273:grbl/motion_control.c ****   probe_configure_invert_mask(is_probe_away);
 1119              		.loc 1 273 0
 1120 0024 84F80580 		strb	r8, [r4, #5]
 1121              		.loc 1 274 0
 1122 0028 FFF7FEFF 		bl	probe_configure_invert_mask
 1123              	.LVL169:
 275:grbl/motion_control.c **** 
 276:grbl/motion_control.c ****   // After syncing, check if probe is already triggered. If so, halt and issue alarm.
 277:grbl/motion_control.c ****   // NOTE: This probe initialization error applies to all probing cycles.
 278:grbl/motion_control.c ****   if ( probe_get_state() ) { // Check probe pin state.
 1124              		.loc 1 278 0
 1125 002c FFF7FEFF 		bl	probe_get_state
 1126              	.LVL170:
 1127 0030 68BB     		cbnz	r0, .L137
 1128              	.LVL171:
 1129              	.LBB47:
 1130              	.LBB48:
  37:grbl/motion_control.c ****     // NOTE: Block jog state. Jogging is a special case and soft limits are handled independently.
 1131              		.loc 1 37 0
 1132 0032 DFF8EC80 		ldr	r8, .L142+16
 1133 0036 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1134 0038 98F84820 		ldrb	r2, [r8, #72]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 42


 1135 003c 9006     		lsls	r0, r2, #26
 1136 003e 05D5     		bpl	.L112
  39:grbl/motion_control.c ****   }
 1137              		.loc 1 39 0
 1138 0040 202B     		cmp	r3, #32
 1139 0042 1ED0     		beq	.L114
 1140 0044 3046     		mov	r0, r6
 1141 0046 FFF7FEFF 		bl	limits_soft_check
 1142              	.LVL172:
 1143 004a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1144              	.L112:
  43:grbl/motion_control.c **** 
 1145              		.loc 1 43 0
 1146 004c 022B     		cmp	r3, #2
 1147 004e 18D1     		bne	.L114
 1148              	.L116:
 1149              	.LVL173:
 1150              	.LBE48:
 1151              	.LBE47:
 279:grbl/motion_control.c ****     system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
 280:grbl/motion_control.c ****     protocol_execute_realtime();
 281:grbl/motion_control.c ****     probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
 282:grbl/motion_control.c ****     return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
 283:grbl/motion_control.c ****   }
 284:grbl/motion_control.c **** 
 285:grbl/motion_control.c ****   // Setup and queue probing motion. Auto cycle-start should not start the cycle.
 286:grbl/motion_control.c ****   mc_line(target, pl_data);
 287:grbl/motion_control.c **** 
 288:grbl/motion_control.c ****   // Activate the probing state monitor in the stepper module.
 289:grbl/motion_control.c ****   sys_probe_state = PROBE_ACTIVE;
 1152              		.loc 1 289 0
 1153 0050 0123     		movs	r3, #1
 1154 0052 304E     		ldr	r6, .L142+4
 1155              	.LVL174:
 290:grbl/motion_control.c **** 
 291:grbl/motion_control.c ****   // Perform probing cycle. Wait here until probe is triggered or motion completes.
 292:grbl/motion_control.c ****   system_set_exec_state_flag(EXEC_CYCLE_START);
 1156              		.loc 1 292 0
 1157 0054 0220     		movs	r0, #2
 289:grbl/motion_control.c **** 
 1158              		.loc 1 289 0
 1159 0056 3370     		strb	r3, [r6]
 1160              		.loc 1 292 0
 1161 0058 FFF7FEFF 		bl	system_set_exec_state_flag
 1162              	.LVL175:
 1163 005c 01E0     		b	.L120
 1164              	.L139:
 293:grbl/motion_control.c ****   do {
 294:grbl/motion_control.c ****     protocol_execute_realtime();
 295:grbl/motion_control.c ****     if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
 296:grbl/motion_control.c ****   } while (sys.state != STATE_IDLE);
 1165              		.loc 1 296 0
 1166 005e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1167 0060 F3B1     		cbz	r3, .L138
 1168              	.L120:
 294:grbl/motion_control.c ****     if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
 1169              		.loc 1 294 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 43


 1170 0062 FFF7FEFF 		bl	protocol_execute_realtime
 1171              	.LVL176:
 295:grbl/motion_control.c ****   } while (sys.state != STATE_IDLE);
 1172              		.loc 1 295 0
 1173 0066 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1174 0068 002B     		cmp	r3, #0
 1175 006a F8D0     		beq	.L139
 1176              	.LVL177:
 1177              	.L136:
 282:grbl/motion_control.c ****   }
 1178              		.loc 1 282 0
 1179 006c 0220     		movs	r0, #2
 1180              	.L109:
 297:grbl/motion_control.c **** 
 298:grbl/motion_control.c ****   // Probing cycle complete!
 299:grbl/motion_control.c **** 
 300:grbl/motion_control.c ****   // Set state variables and error out, if the probe failed and cycle with error is enabled.
 301:grbl/motion_control.c ****   if (sys_probe_state == PROBE_ACTIVE) {
 302:grbl/motion_control.c ****     if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
 303:grbl/motion_control.c ****     else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
 304:grbl/motion_control.c ****   } else {
 305:grbl/motion_control.c ****     sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
 306:grbl/motion_control.c ****   }
 307:grbl/motion_control.c ****   sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
 308:grbl/motion_control.c ****   probe_configure_invert_mask(false); // Re-initialize invert mask.
 309:grbl/motion_control.c ****   protocol_execute_realtime();   // Check and execute run-time commands
 310:grbl/motion_control.c **** 
 311:grbl/motion_control.c ****   // Reset the stepper and planner buffers to remove the remainder of the probe motion.
 312:grbl/motion_control.c ****   st_reset(); // Reset step segment buffer.
 313:grbl/motion_control.c ****   plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 314:grbl/motion_control.c ****   plan_sync_position(); // Sync planner position to current machine position.
 315:grbl/motion_control.c **** 
 316:grbl/motion_control.c ****   #ifdef MESSAGE_PROBE_COORDINATES
 317:grbl/motion_control.c ****     // All done! Output the probe position as message.
 318:grbl/motion_control.c ****     report_probe_parameters();
 319:grbl/motion_control.c ****   #endif
 320:grbl/motion_control.c **** 
 321:grbl/motion_control.c ****   if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
 322:grbl/motion_control.c ****   else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without err
 323:grbl/motion_control.c **** }
 1181              		.loc 1 323 0
 1182 006e BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1183              	.LVL178:
 1184              	.L124:
 264:grbl/motion_control.c **** 
 1185              		.loc 1 264 0
 1186 0072 0020     		movs	r0, #0
 1187              	.LVL179:
 1188              		.loc 1 323 0
 1189 0074 BDE8F081 		pop	{r4, r5, r6, r7, r8, pc}
 1190              	.LVL180:
 1191              	.L140:
 1192              	.LBB53:
 1193              	.LBB51:
  64:grbl/motion_control.c ****     else { break; }
 1194              		.loc 1 64 0
 1195 0078 FFF7FEFF 		bl	plan_check_full_buffer
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 44


 1196              	.LVL181:
 1197 007c 48B3     		cbz	r0, .L118
 1198 007e FFF7FEFF 		bl	protocol_auto_cycle_start
 1199              	.LVL182:
 1200              	.L114:
  62:grbl/motion_control.c ****     if (sys.abort) { return; } // Bail, if system abort.
 1201              		.loc 1 62 0
 1202 0082 FFF7FEFF 		bl	protocol_execute_realtime
 1203              	.LVL183:
  63:grbl/motion_control.c ****     if ( plan_check_full_buffer() ) { protocol_auto_cycle_start(); } // Auto-cycle start when buffe
 1204              		.loc 1 63 0
 1205 0086 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1206 0088 002B     		cmp	r3, #0
 1207 008a F5D0     		beq	.L140
 1208 008c E0E7     		b	.L116
 1209              	.LVL184:
 1210              	.L137:
 1211              	.LBE51:
 1212              	.LBE53:
 279:grbl/motion_control.c ****     protocol_execute_realtime();
 1213              		.loc 1 279 0
 1214 008e 0420     		movs	r0, #4
 1215 0090 FFF7FEFF 		bl	system_set_exec_alarm
 1216              	.LVL185:
 280:grbl/motion_control.c ****     probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
 1217              		.loc 1 280 0
 1218 0094 FFF7FEFF 		bl	protocol_execute_realtime
 1219              	.LVL186:
 281:grbl/motion_control.c ****     return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
 1220              		.loc 1 281 0
 1221 0098 4046     		mov	r0, r8
 1222 009a FFF7FEFF 		bl	probe_configure_invert_mask
 1223              	.LVL187:
 1224 009e E5E7     		b	.L136
 1225              	.LVL188:
 1226              	.L138:
 301:grbl/motion_control.c ****     if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
 1227              		.loc 1 301 0
 1228 00a0 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 1229 00a2 012B     		cmp	r3, #1
 1230 00a4 27D0     		beq	.L141
 305:grbl/motion_control.c ****   }
 1231              		.loc 1 305 0
 1232 00a6 0123     		movs	r3, #1
 1233 00a8 6371     		strb	r3, [r4, #5]
 1234              	.L123:
 307:grbl/motion_control.c ****   probe_configure_invert_mask(false); // Re-initialize invert mask.
 1235              		.loc 1 307 0
 1236 00aa 0023     		movs	r3, #0
 308:grbl/motion_control.c ****   protocol_execute_realtime();   // Check and execute run-time commands
 1237              		.loc 1 308 0
 1238 00ac 1846     		mov	r0, r3
 307:grbl/motion_control.c ****   probe_configure_invert_mask(false); // Re-initialize invert mask.
 1239              		.loc 1 307 0
 1240 00ae 3370     		strb	r3, [r6]
 308:grbl/motion_control.c ****   protocol_execute_realtime();   // Check and execute run-time commands
 1241              		.loc 1 308 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 45


 1242 00b0 FFF7FEFF 		bl	probe_configure_invert_mask
 1243              	.LVL189:
 309:grbl/motion_control.c **** 
 1244              		.loc 1 309 0
 1245 00b4 FFF7FEFF 		bl	protocol_execute_realtime
 1246              	.LVL190:
 312:grbl/motion_control.c ****   plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
 1247              		.loc 1 312 0
 1248 00b8 FFF7FEFF 		bl	st_reset
 1249              	.LVL191:
 313:grbl/motion_control.c ****   plan_sync_position(); // Sync planner position to current machine position.
 1250              		.loc 1 313 0
 1251 00bc FFF7FEFF 		bl	plan_reset
 1252              	.LVL192:
 314:grbl/motion_control.c **** 
 1253              		.loc 1 314 0
 1254 00c0 FFF7FEFF 		bl	plan_sync_position
 1255              	.LVL193:
 318:grbl/motion_control.c ****   #endif
 1256              		.loc 1 318 0
 1257 00c4 FFF7FEFF 		bl	report_probe_parameters
 1258              	.LVL194:
 321:grbl/motion_control.c ****   else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without err
 1259              		.loc 1 321 0
 1260 00c8 6079     		ldrb	r0, [r4, #5]	@ zero_extendqisi2
 264:grbl/motion_control.c **** 
 1261              		.loc 1 264 0
 1262 00ca 0030     		adds	r0, r0, #0
 1263 00cc 18BF     		it	ne
 1264 00ce 0120     		movne	r0, #1
 1265 00d0 CDE7     		b	.L109
 1266              	.LVL195:
 1267              	.L118:
 1268              	.LBB54:
 1269              	.LBB52:
  69:grbl/motion_control.c ****     if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 1270              		.loc 1 69 0
 1271 00d2 3046     		mov	r0, r6
 1272 00d4 3946     		mov	r1, r7
 1273 00d6 FFF7FEFF 		bl	plan_buffer_line
 1274              	.LVL196:
 1275 00da 0028     		cmp	r0, #0
 1276 00dc B8D1     		bne	.L116
  70:grbl/motion_control.c ****       // Correctly set spindle state, if there is a coincident position passed. Forces a buffer
 1277              		.loc 1 70 0
 1278 00de 98F84830 		ldrb	r3, [r8, #72]	@ zero_extendqisi2
 1279 00e2 9907     		lsls	r1, r3, #30
 1280 00e4 B4D5     		bpl	.L116
  73:grbl/motion_control.c ****         spindle_sync(PL_COND_FLAG_SPINDLE_CW, pl_data->spindle_speed);
 1281              		.loc 1 73 0
 1282 00e6 3B7A     		ldrb	r3, [r7, #8]	@ zero_extendqisi2
 1283 00e8 DA06     		lsls	r2, r3, #27
 1284 00ea B1D5     		bpl	.L116
 1285              	.LVL197:
 1286              	.LBB49:
 1287              	.LBB50:
  74:grbl/motion_control.c ****       }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 46


 1288              		.loc 1 74 0
 1289 00ec 7968     		ldr	r1, [r7, #4]	@ float
 1290 00ee 1020     		movs	r0, #16
 1291 00f0 FFF7FEFF 		bl	spindle_sync
 1292              	.LVL198:
 1293 00f4 ACE7     		b	.L116
 1294              	.LVL199:
 1295              	.L141:
 1296              	.LBE50:
 1297              	.LBE49:
 1298              	.LBE52:
 1299              	.LBE54:
 302:grbl/motion_control.c ****     else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
 1300              		.loc 1 302 0
 1301 00f6 EB06     		lsls	r3, r5, #27
 1302 00f8 05D5     		bpl	.L122
 302:grbl/motion_control.c ****     else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
 1303              		.loc 1 302 0 is_stmt 0 discriminator 1
 1304 00fa 074A     		ldr	r2, .L142+8
 1305 00fc 074B     		ldr	r3, .L142+12
 1306 00fe 07CA     		ldm	r2, {r0, r1, r2}
 1307 0100 83E80700 		stm	r3, {r0, r1, r2}
 1308 0104 D1E7     		b	.L123
 1309              	.L122:
 303:grbl/motion_control.c ****   } else {
 1310              		.loc 1 303 0 is_stmt 1
 1311 0106 0520     		movs	r0, #5
 1312 0108 FFF7FEFF 		bl	system_set_exec_alarm
 1313              	.LVL200:
 1314 010c CDE7     		b	.L123
 1315              	.L143:
 1316 010e 00BF     		.align	2
 1317              	.L142:
 1318 0110 00000000 		.word	sys
 1319 0114 00000000 		.word	sys_probe_state
 1320 0118 00000000 		.word	sys_position
 1321 011c 00000000 		.word	sys_probe_position
 1322 0120 00000000 		.word	settings
 1323              		.cfi_endproc
 1324              	.LFE707:
 1326              		.section	.text.mc_reset,"ax",%progbits
 1327              		.align	1
 1328              		.p2align 2,,3
 1329              		.global	mc_reset
 1330              		.syntax unified
 1331              		.thumb
 1332              		.thumb_func
 1333              		.fpu softvfp
 1335              	mc_reset:
 1336              	.LFB708:
 324:grbl/motion_control.c **** 
 325:grbl/motion_control.c **** 
 326:grbl/motion_control.c **** // Plans and executes the single special motion case for parking. Independent of main planner buffe
 327:grbl/motion_control.c **** // NOTE: Uses the always free planner ring buffer head to store motion parameters for execution.
 328:grbl/motion_control.c **** #ifdef PARKING_ENABLE
 329:grbl/motion_control.c ****   void mc_parking_motion(float *parking_target, plan_line_data_t *pl_data)
 330:grbl/motion_control.c ****   {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 47


 331:grbl/motion_control.c ****     if (sys.abort) { return; } // Block during abort.
 332:grbl/motion_control.c **** 
 333:grbl/motion_control.c ****     uint8_t plan_status = plan_buffer_line(parking_target, pl_data);
 334:grbl/motion_control.c **** 
 335:grbl/motion_control.c ****     if (plan_status) {
 336:grbl/motion_control.c ****       bit_true(sys.step_control, STEP_CONTROL_EXECUTE_SYS_MOTION);
 337:grbl/motion_control.c ****       bit_false(sys.step_control, STEP_CONTROL_END_MOTION); // Allow parking motion to execute, if 
 338:grbl/motion_control.c ****       st_parking_setup_buffer(); // Setup step segment buffer for special parking motion case
 339:grbl/motion_control.c ****       st_prep_buffer();
 340:grbl/motion_control.c ****       st_wake_up();
 341:grbl/motion_control.c ****       do {
 342:grbl/motion_control.c ****         protocol_exec_rt_system();
 343:grbl/motion_control.c ****         if (sys.abort) { return; }
 344:grbl/motion_control.c ****       } while (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION);
 345:grbl/motion_control.c ****       st_parking_restore_buffer(); // Restore step segment buffer to normal run state.
 346:grbl/motion_control.c ****     } else {
 347:grbl/motion_control.c ****       bit_false(sys.step_control, STEP_CONTROL_EXECUTE_SYS_MOTION);
 348:grbl/motion_control.c ****       protocol_exec_rt_system();
 349:grbl/motion_control.c ****     }
 350:grbl/motion_control.c **** 
 351:grbl/motion_control.c ****   }
 352:grbl/motion_control.c **** #endif
 353:grbl/motion_control.c **** 
 354:grbl/motion_control.c **** 
 355:grbl/motion_control.c **** #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
 356:grbl/motion_control.c ****   void mc_override_ctrl_update(uint8_t override_state)
 357:grbl/motion_control.c ****   {
 358:grbl/motion_control.c ****     // Finish all queued commands before altering override control state
 359:grbl/motion_control.c ****     protocol_buffer_synchronize();
 360:grbl/motion_control.c ****     if (sys.abort) { return; }
 361:grbl/motion_control.c ****     sys.override_ctrl = override_state;
 362:grbl/motion_control.c ****   }
 363:grbl/motion_control.c **** #endif
 364:grbl/motion_control.c **** 
 365:grbl/motion_control.c **** 
 366:grbl/motion_control.c **** // Method to ready the system to reset by setting the realtime reset command and killing any
 367:grbl/motion_control.c **** // active processes in the system. This also checks if a system reset is issued while Grbl
 368:grbl/motion_control.c **** // is in a motion state. If so, kills the steppers and sets the system alarm to flag position
 369:grbl/motion_control.c **** // lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
 370:grbl/motion_control.c **** // realtime abort command and hard limits. So, keep to a minimum.
 371:grbl/motion_control.c **** void mc_reset()
 372:grbl/motion_control.c **** {
 1337              		.loc 1 372 0
 1338              		.cfi_startproc
 1339              		@ args = 0, pretend = 0, frame = 0
 1340              		@ frame_needed = 0, uses_anonymous_args = 0
 1341 0000 08B5     		push	{r3, lr}
 1342              	.LCFI14:
 1343              		.cfi_def_cfa_offset 8
 1344              		.cfi_offset 3, -8
 1345              		.cfi_offset 14, -4
 373:grbl/motion_control.c ****   // Only this function can set the system reset. Helps prevent multiple kill calls.
 374:grbl/motion_control.c ****   if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
 1346              		.loc 1 374 0
 1347 0002 154B     		ldr	r3, .L158
 1348 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1349 0006 DB06     		lsls	r3, r3, #27
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 48


 1350 0008 00D5     		bpl	.L155
 1351              	.L144:
 375:grbl/motion_control.c ****     system_set_exec_state_flag(EXEC_RESET);
 376:grbl/motion_control.c **** 
 377:grbl/motion_control.c ****     // Kill spindle and coolant.
 378:grbl/motion_control.c ****     spindle_stop();
 379:grbl/motion_control.c ****     coolant_stop();
 380:grbl/motion_control.c **** 
 381:grbl/motion_control.c ****     // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
 382:grbl/motion_control.c ****     // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
 383:grbl/motion_control.c ****     // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
 384:grbl/motion_control.c ****     // violated, by which, all bets are off.
 385:grbl/motion_control.c ****     if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
 386:grbl/motion_control.c ****     		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
 387:grbl/motion_control.c ****       if (sys.state == STATE_HOMING) { 
 388:grbl/motion_control.c ****         if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 389:grbl/motion_control.c ****       } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
 390:grbl/motion_control.c ****       st_go_idle(); // Force kill steppers. Position has likely been lost.
 391:grbl/motion_control.c ****     }
 392:grbl/motion_control.c ****   }
 393:grbl/motion_control.c **** }
 1352              		.loc 1 393 0
 1353 000a 08BD     		pop	{r3, pc}
 1354              	.L155:
 375:grbl/motion_control.c ****     system_set_exec_state_flag(EXEC_RESET);
 1355              		.loc 1 375 0
 1356 000c 1020     		movs	r0, #16
 1357 000e FFF7FEFF 		bl	system_set_exec_state_flag
 1358              	.LVL201:
 378:grbl/motion_control.c ****     coolant_stop();
 1359              		.loc 1 378 0
 1360 0012 FFF7FEFF 		bl	spindle_stop
 1361              	.LVL202:
 379:grbl/motion_control.c **** 
 1362              		.loc 1 379 0
 1363 0016 FFF7FEFF 		bl	coolant_stop
 1364              	.LVL203:
 385:grbl/motion_control.c ****     		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
 1365              		.loc 1 385 0
 1366 001a 104A     		ldr	r2, .L158+4
 1367 001c 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 1368 001e 13F02C0F 		tst	r3, #44
 1369 0022 08D0     		beq	.L156
 1370              	.L147:
 387:grbl/motion_control.c ****         if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
 1371              		.loc 1 387 0
 1372 0024 042B     		cmp	r3, #4
 1373 0026 0BD1     		bne	.L149
 388:grbl/motion_control.c ****       } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
 1374              		.loc 1 388 0
 1375 0028 0D4B     		ldr	r3, .L158+8
 1376 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1377 002c 7BB1     		cbz	r3, .L157
 1378              	.L150:
 1379              		.loc 1 393 0
 1380 002e BDE80840 		pop	{r3, lr}
 1381              	.LCFI15:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 49


 1382              		.cfi_remember_state
 1383              		.cfi_restore 14
 1384              		.cfi_restore 3
 1385              		.cfi_def_cfa_offset 0
 390:grbl/motion_control.c ****     }
 1386              		.loc 1 390 0
 1387 0032 FFF7FEBF 		b	st_go_idle
 1388              	.LVL204:
 1389              	.L156:
 1390              	.LCFI16:
 1391              		.cfi_restore_state
 385:grbl/motion_control.c ****     		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
 1392              		.loc 1 385 0 discriminator 1
 1393 0036 1279     		ldrb	r2, [r2, #4]	@ zero_extendqisi2
 1394 0038 12F0060F 		tst	r2, #6
 1395 003c F2D1     		bne	.L147
 1396 003e E4E7     		b	.L144
 1397              	.L149:
 389:grbl/motion_control.c ****       st_go_idle(); // Force kill steppers. Position has likely been lost.
 1398              		.loc 1 389 0
 1399 0040 0320     		movs	r0, #3
 1400 0042 FFF7FEFF 		bl	system_set_exec_alarm
 1401              	.LVL205:
 1402              		.loc 1 393 0
 1403 0046 BDE80840 		pop	{r3, lr}
 1404              	.LCFI17:
 1405              		.cfi_remember_state
 1406              		.cfi_restore 14
 1407              		.cfi_restore 3
 1408              		.cfi_def_cfa_offset 0
 390:grbl/motion_control.c ****     }
 1409              		.loc 1 390 0
 1410 004a FFF7FEBF 		b	st_go_idle
 1411              	.LVL206:
 1412              	.L157:
 1413              	.LCFI18:
 1414              		.cfi_restore_state
 388:grbl/motion_control.c ****       } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
 1415              		.loc 1 388 0 discriminator 1
 1416 004e 0620     		movs	r0, #6
 1417 0050 FFF7FEFF 		bl	system_set_exec_alarm
 1418              	.LVL207:
 1419 0054 EBE7     		b	.L150
 1420              	.L159:
 1421 0056 00BF     		.align	2
 1422              	.L158:
 1423 0058 00000000 		.word	sys_rt_exec_state
 1424 005c 00000000 		.word	sys
 1425 0060 00000000 		.word	sys_rt_exec_alarm
 1426              		.cfi_endproc
 1427              	.LFE708:
 1429              		.text
 1430              	.Letext0:
 1431              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 1432              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 1433              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 1434              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 50


 1435              		.file 7 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 1436              		.file 8 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/math.h"
 1437              		.file 9 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 1438              		.file 10 "Drivers/CMSIS/Include/core_cm3.h"
 1439              		.file 11 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 1440              		.file 12 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/stm32f103xb.h"
 1441              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 1442              		.file 14 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h"
 1443              		.file 15 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h"
 1444              		.file 16 "stm32/stm32utilities.h"
 1445              		.file 17 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 1446              		.file 18 "grbl/settings.h"
 1447              		.file 19 "grbl/system.h"
 1448              		.file 20 "grbl/planner.h"
 1449              		.file 21 "grbl/gcode.h"
 1450              		.file 22 "grbl/spindle_control.h"
 1451              		.file 23 "grbl/coolant_control.h"
 1452              		.file 24 "grbl/stepper.h"
 1453              		.file 25 "grbl/limits.h"
 1454              		.file 26 "grbl/protocol.h"
 1455              		.file 27 "grbl/probe.h"
 1456              		.file 28 "grbl/report.h"
 1457              		.file 29 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal_cortex.h"
 1458              		.file 30 "grbl/nuts_bolts.h"
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 51


DEFINED SYMBOLS
                            *ABS*:0000000000000000 motion_control.c
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:16     .text.mc_line:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:24     .text.mc_line:0000000000000000 mc_line
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:130    .text.mc_line:0000000000000060 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:152    .text.mc_arc:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:160    .text.mc_arc:0000000000000000 mc_arc
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:777    .text.mc_arc:0000000000000350 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:797    .text.mc_arc:0000000000000378 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:910    .text.mc_arc:0000000000000420 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:920    .text.mc_dwell:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:928    .text.mc_dwell:0000000000000000 mc_dwell
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:968    .text.mc_dwell:0000000000000020 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:973    .text.mc_homing_cycle:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:981    .text.mc_homing_cycle:0000000000000000 mc_homing_cycle
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1071   .text.mc_homing_cycle:0000000000000054 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1077   .text.mc_probe_cycle:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1085   .text.mc_probe_cycle:0000000000000000 mc_probe_cycle
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1318   .text.mc_probe_cycle:0000000000000110 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1327   .text.mc_reset:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1335   .text.mc_reset:0000000000000000 mc_reset
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s:1423   .text.mc_reset:0000000000000058 $d

UNDEFINED SYMBOLS
limits_soft_check
plan_check_full_buffer
protocol_auto_cycle_start
protocol_execute_realtime
plan_buffer_line
spindle_sync
settings
sys
__aeabi_fadd
__aeabi_fsub
__aeabi_fmul
__aeabi_f2d
__aeabi_dcmpge
__aeabi_dsub
__aeabi_d2f
__aeabi_dcmple
__aeabi_dadd
__aeabi_dmul
__aeabi_ddiv
__aeabi_d2uiz
__aeabi_i2f
__aeabi_fdiv
atan2f
sqrtf
floor
cosf
sinf
protocol_buffer_synchronize
delay_sec
limits_disable
limits_go_home
gc_sync_position
plan_sync_position
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccsUasOQ.s 			page 52


HAL_NVIC_ClearPendingIRQ
HAL_NVIC_EnableIRQ
probe_configure_invert_mask
probe_get_state
system_set_exec_state_flag
system_set_exec_alarm
st_reset
plan_reset
report_probe_parameters
sys_probe_state
sys_position
sys_probe_position
spindle_stop
coolant_stop
st_go_idle
sys_rt_exec_state
sys_rt_exec_alarm
