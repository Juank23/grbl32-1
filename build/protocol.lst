ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 1


   1              		.cpu cortex-m3
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 2
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"protocol.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.protocol_auto_cycle_start,"ax",%progbits
  16              		.align	1
  17              		.p2align 2,,3
  18              		.global	protocol_auto_cycle_start
  19              		.syntax unified
  20              		.thumb
  21              		.thumb_func
  22              		.fpu softvfp
  24              	protocol_auto_cycle_start:
  25              	.LFB705:
  26              		.file 1 "grbl/protocol.c"
   1:grbl/protocol.c **** /*
   2:grbl/protocol.c ****   protocol.c - controls Grbl execution protocol and procedures
   3:grbl/protocol.c ****   Part of Grbl
   4:grbl/protocol.c **** 
   5:grbl/protocol.c ****   Copyright (c) 2011-2016 Sungeun K. Jeon for Gnea Research LLC
   6:grbl/protocol.c ****   Copyright (c) 2009-2011 Simen Svale Skogsrud
   7:grbl/protocol.c **** 
   8:grbl/protocol.c ****   Grbl is free software: you can redistribute it and/or modify
   9:grbl/protocol.c ****   it under the terms of the GNU General Public License as published by
  10:grbl/protocol.c ****   the Free Software Foundation, either version 3 of the License, or
  11:grbl/protocol.c ****   (at your option) any later version.
  12:grbl/protocol.c **** 
  13:grbl/protocol.c ****   Grbl is distributed in the hope that it will be useful,
  14:grbl/protocol.c ****   but WITHOUT ANY WARRANTY; without even the implied warranty of
  15:grbl/protocol.c ****   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  16:grbl/protocol.c ****   GNU General Public License for more details.
  17:grbl/protocol.c **** 
  18:grbl/protocol.c ****   You should have received a copy of the GNU General Public License
  19:grbl/protocol.c ****   along with Grbl.  If not, see <http://www.gnu.org/licenses/>.
  20:grbl/protocol.c **** */
  21:grbl/protocol.c **** 
  22:grbl/protocol.c **** #include "grbl.h"
  23:grbl/protocol.c **** 
  24:grbl/protocol.c **** // Define line flags. Includes comment type tracking and line overflow detection.
  25:grbl/protocol.c **** #define LINE_FLAG_OVERFLOW bit(0)
  26:grbl/protocol.c **** #define LINE_FLAG_COMMENT_PARENTHESES bit(1)
  27:grbl/protocol.c **** #define LINE_FLAG_COMMENT_SEMICOLON bit(2)
  28:grbl/protocol.c **** 
  29:grbl/protocol.c **** 
  30:grbl/protocol.c **** static char line[LINE_BUFFER_SIZE]; // Line to be executed. Zero-terminated.
  31:grbl/protocol.c **** 
  32:grbl/protocol.c **** static void protocol_exec_rt_suspend();
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 2


  33:grbl/protocol.c **** 
  34:grbl/protocol.c **** 
  35:grbl/protocol.c **** /*
  36:grbl/protocol.c ****   GRBL PRIMARY LOOP:
  37:grbl/protocol.c **** */
  38:grbl/protocol.c **** void protocol_main_loop()
  39:grbl/protocol.c **** {
  40:grbl/protocol.c ****   // Perform some machine checks to make sure everything is good to go.
  41:grbl/protocol.c ****   #ifdef CHECK_LIMITS_AT_INIT
  42:grbl/protocol.c ****     if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
  43:grbl/protocol.c ****       if (limits_get_state()) {
  44:grbl/protocol.c ****         sys.state = STATE_ALARM; // Ensure alarm state is active.
  45:grbl/protocol.c ****         report_feedback_message(MESSAGE_CHECK_LIMITS);
  46:grbl/protocol.c ****       }
  47:grbl/protocol.c ****     }
  48:grbl/protocol.c ****   #endif
  49:grbl/protocol.c ****   // Check for and report alarm state after a reset, error, or an initial power up.
  50:grbl/protocol.c ****   // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  51:grbl/protocol.c ****   // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  52:grbl/protocol.c ****   if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
  53:grbl/protocol.c ****     report_feedback_message(MESSAGE_ALARM_LOCK);
  54:grbl/protocol.c ****     sys.state = STATE_ALARM; // Ensure alarm state is set.
  55:grbl/protocol.c ****   } else {
  56:grbl/protocol.c ****     // Check if the safety door is open.
  57:grbl/protocol.c ****     sys.state = STATE_IDLE;
  58:grbl/protocol.c ****     if (system_check_safety_door_ajar()) {
  59:grbl/protocol.c ****       bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
  60:grbl/protocol.c ****       protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
  61:grbl/protocol.c ****     }
  62:grbl/protocol.c ****     // All systems go!
  63:grbl/protocol.c ****     system_execute_startup(line); // Execute startup script.
  64:grbl/protocol.c ****   }
  65:grbl/protocol.c **** 
  66:grbl/protocol.c ****   // ---------------------------------------------------------------------------------
  67:grbl/protocol.c ****   // Primary loop! Upon a system abort, this exits back to main() to reset the system.
  68:grbl/protocol.c ****   // This is also where Grbl idles while waiting for something to do.
  69:grbl/protocol.c ****   // ---------------------------------------------------------------------------------
  70:grbl/protocol.c **** 
  71:grbl/protocol.c ****   uint8_t line_flags = 0;
  72:grbl/protocol.c ****   uint8_t char_counter = 0;
  73:grbl/protocol.c ****   uint8_t c;
  74:grbl/protocol.c ****   for (;;) {
  75:grbl/protocol.c **** 
  76:grbl/protocol.c ****     // Process one line of incoming serial data, as the data becomes available. Performs an
  77:grbl/protocol.c ****     // initial filtering by removing spaces and comments and capitalizing all letters.
  78:grbl/protocol.c ****     while((c = serial_read()) != SERIAL_NO_DATA) {
  79:grbl/protocol.c ****       if ((c == '\n') || (c == '\r')) { // End of line reached
  80:grbl/protocol.c **** 
  81:grbl/protocol.c ****         protocol_execute_realtime(); // Runtime command check point.
  82:grbl/protocol.c ****         if (sys.abort) { return; } // Bail to calling function upon system abort
  83:grbl/protocol.c **** 
  84:grbl/protocol.c ****         line[char_counter] = 0; // Set string termination character.
  85:grbl/protocol.c ****         #ifdef REPORT_ECHO_LINE_RECEIVED
  86:grbl/protocol.c ****           report_echo_line_received(line);
  87:grbl/protocol.c ****         #endif
  88:grbl/protocol.c **** 
  89:grbl/protocol.c ****         // Direct and execute one line of formatted input, and report status of execution.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 3


  90:grbl/protocol.c ****         if (line_flags & LINE_FLAG_OVERFLOW) {
  91:grbl/protocol.c ****           // Report line overflow error.
  92:grbl/protocol.c ****           report_status_message(STATUS_OVERFLOW);
  93:grbl/protocol.c ****         } else if (line[0] == 0) {
  94:grbl/protocol.c ****           // Empty or comment line. For syncing purposes.
  95:grbl/protocol.c ****           report_status_message(STATUS_OK);
  96:grbl/protocol.c ****         } else if (line[0] == '$') {
  97:grbl/protocol.c ****           // Grbl '$' system command
  98:grbl/protocol.c ****           report_status_message(system_execute_line(line));
  99:grbl/protocol.c ****         } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
 100:grbl/protocol.c ****           // Everything else is gcode. Block if in alarm or jog mode.
 101:grbl/protocol.c ****           report_status_message(STATUS_SYSTEM_GC_LOCK);
 102:grbl/protocol.c ****         } else {
 103:grbl/protocol.c ****           // Parse and execute g-code block.
 104:grbl/protocol.c ****           report_status_message(gc_execute_line(line));
 105:grbl/protocol.c ****         }
 106:grbl/protocol.c **** 
 107:grbl/protocol.c ****         // Reset tracking data for next line.
 108:grbl/protocol.c ****         line_flags = 0;
 109:grbl/protocol.c ****         char_counter = 0;
 110:grbl/protocol.c **** 
 111:grbl/protocol.c ****       } else {
 112:grbl/protocol.c **** 
 113:grbl/protocol.c ****         if (line_flags) {
 114:grbl/protocol.c ****           // Throw away all (except EOL) comment characters and overflow characters.
 115:grbl/protocol.c ****           if (c == ')') {
 116:grbl/protocol.c ****             // End of '()' comment. Resume line allowed.
 117:grbl/protocol.c ****             if (line_flags & LINE_FLAG_COMMENT_PARENTHESES) { line_flags &= ~(LINE_FLAG_COMMENT_PAR
 118:grbl/protocol.c ****           }
 119:grbl/protocol.c ****         } else {
 120:grbl/protocol.c ****           if (c <= ' ') {
 121:grbl/protocol.c ****             // Throw away whitepace and control characters
 122:grbl/protocol.c ****           } else if (c == '/') {
 123:grbl/protocol.c ****             // Block delete NOT SUPPORTED. Ignore character.
 124:grbl/protocol.c ****             // NOTE: If supported, would simply need to check the system if block delete is enabled
 125:grbl/protocol.c ****           } else if (c == '(') {
 126:grbl/protocol.c ****             // Enable comments flag and ignore all characters until ')' or EOL.
 127:grbl/protocol.c ****             // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
 128:grbl/protocol.c ****             // In the future, we could simply remove the items within the comments, but retain the
 129:grbl/protocol.c ****             // comment control characters, so that the g-code parser can error-check it.
 130:grbl/protocol.c ****             line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
 131:grbl/protocol.c ****           } else if (c == ';') {
 132:grbl/protocol.c ****             // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
 133:grbl/protocol.c ****             line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
 134:grbl/protocol.c ****           // TODO: Install '%' feature
 135:grbl/protocol.c ****           // } else if (c == '%') {
 136:grbl/protocol.c ****             // Program start-end percent sign NOT SUPPORTED.
 137:grbl/protocol.c ****             // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
 138:grbl/protocol.c ****             // where, during a program, the system auto-cycle start will continue to execute
 139:grbl/protocol.c ****             // everything until the next '%' sign. This will help fix resuming issues with certain
 140:grbl/protocol.c ****             // functions that empty the planner buffer to execute its task on-time.
 141:grbl/protocol.c ****           } else if (char_counter >= (LINE_BUFFER_SIZE-1)) {
 142:grbl/protocol.c ****             // Detect line buffer overflow and set flag.
 143:grbl/protocol.c ****             line_flags |= LINE_FLAG_OVERFLOW;
 144:grbl/protocol.c ****           } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
 145:grbl/protocol.c ****             line[char_counter++] = c-'a'+'A';
 146:grbl/protocol.c ****           } else {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 4


 147:grbl/protocol.c ****             line[char_counter++] = c;
 148:grbl/protocol.c ****           }
 149:grbl/protocol.c ****         }
 150:grbl/protocol.c **** 
 151:grbl/protocol.c ****       }
 152:grbl/protocol.c ****     }
 153:grbl/protocol.c **** 
 154:grbl/protocol.c ****     // If there are no more characters in the serial read buffer to be processed and executed,
 155:grbl/protocol.c ****     // this indicates that g-code streaming has either filled the planner buffer or has
 156:grbl/protocol.c ****     // completed. In either case, auto-cycle start, if enabled, any queued moves.
 157:grbl/protocol.c ****     protocol_auto_cycle_start();
 158:grbl/protocol.c **** 
 159:grbl/protocol.c ****     protocol_execute_realtime();  // Runtime command check point.
 160:grbl/protocol.c ****     if (sys.abort) { return; } // Bail to main() program loop to reset system.
 161:grbl/protocol.c ****   }
 162:grbl/protocol.c **** 
 163:grbl/protocol.c ****   return; /* Never reached */
 164:grbl/protocol.c **** }
 165:grbl/protocol.c **** 
 166:grbl/protocol.c **** 
 167:grbl/protocol.c **** // Block until all buffered steps are executed or in a cycle state. Works with feed hold
 168:grbl/protocol.c **** // during a synchronize call, if it should happen. Also, waits for clean cycle end.
 169:grbl/protocol.c **** void protocol_buffer_synchronize()
 170:grbl/protocol.c **** {
 171:grbl/protocol.c ****   // If system is queued, ensure cycle resumes if the auto start flag is present.
 172:grbl/protocol.c ****   protocol_auto_cycle_start();
 173:grbl/protocol.c ****   do {
 174:grbl/protocol.c ****     protocol_execute_realtime();   // Check and execute run-time commands
 175:grbl/protocol.c ****     if (sys.abort) { return; } // Check for system abort
 176:grbl/protocol.c ****   } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
 177:grbl/protocol.c **** }
 178:grbl/protocol.c **** 
 179:grbl/protocol.c **** 
 180:grbl/protocol.c **** // Auto-cycle start triggers when there is a motion ready to execute and if the main program is not
 181:grbl/protocol.c **** // actively parsing commands.
 182:grbl/protocol.c **** // NOTE: This function is called from the main loop, buffer sync, and mc_line() only and executes
 183:grbl/protocol.c **** // when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
 184:grbl/protocol.c **** // is finished, single commands), a command that needs to wait for the motions in the buffer to
 185:grbl/protocol.c **** // execute calls a buffer sync, or the planner buffer is full and ready to go.
 186:grbl/protocol.c **** void protocol_auto_cycle_start()
 187:grbl/protocol.c **** {
  27              		.loc 1 187 0
  28              		.cfi_startproc
  29              		@ args = 0, pretend = 0, frame = 0
  30              		@ frame_needed = 0, uses_anonymous_args = 0
  31 0000 08B5     		push	{r3, lr}
  32              	.LCFI0:
  33              		.cfi_def_cfa_offset 8
  34              		.cfi_offset 3, -8
  35              		.cfi_offset 14, -4
 188:grbl/protocol.c ****   if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
  36              		.loc 1 188 0
  37 0002 FFF7FEFF 		bl	plan_get_current_block
  38              	.LVL0:
  39 0006 20B1     		cbz	r0, .L1
 189:grbl/protocol.c ****     system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 190:grbl/protocol.c ****   }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 5


 191:grbl/protocol.c **** }
  40              		.loc 1 191 0
  41 0008 BDE80840 		pop	{r3, lr}
  42              	.LCFI1:
  43              		.cfi_remember_state
  44              		.cfi_restore 14
  45              		.cfi_restore 3
  46              		.cfi_def_cfa_offset 0
 189:grbl/protocol.c ****     system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
  47              		.loc 1 189 0
  48 000c 0220     		movs	r0, #2
  49 000e FFF7FEBF 		b	system_set_exec_state_flag
  50              	.LVL1:
  51              	.L1:
  52              	.LCFI2:
  53              		.cfi_restore_state
  54              		.loc 1 191 0
  55 0012 08BD     		pop	{r3, pc}
  56              		.cfi_endproc
  57              	.LFE705:
  59              		.section	.text.protocol_exec_rt_system,"ax",%progbits
  60              		.align	1
  61              		.p2align 2,,3
  62              		.global	protocol_exec_rt_system
  63              		.syntax unified
  64              		.thumb
  65              		.thumb_func
  66              		.fpu softvfp
  68              	protocol_exec_rt_system:
  69              	.LFB707:
 192:grbl/protocol.c **** 
 193:grbl/protocol.c **** 
 194:grbl/protocol.c **** // This function is the general interface to Grbl's real-time command execution system. It is calle
 195:grbl/protocol.c **** // from various check points in the main program, primarily where there may be a while loop waiting
 196:grbl/protocol.c **** // for a buffer to clear space or any point where the execution time from the last check point may
 197:grbl/protocol.c **** // be more than a fraction of a second. This is a way to execute realtime commands asynchronously
 198:grbl/protocol.c **** // (aka multitasking) with grbl's g-code parsing and planning functions. This function also serves
 199:grbl/protocol.c **** // as an interface for the interrupts to set the system realtime flags, where only the main program
 200:grbl/protocol.c **** // handles them, removing the need to define more computationally-expensive volatile variables. Thi
 201:grbl/protocol.c **** // also provides a controlled way to execute certain tasks without having two or more instances of
 202:grbl/protocol.c **** // the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
 203:grbl/protocol.c **** // NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pi
 204:grbl/protocol.c **** // limit switches, or the main program.
 205:grbl/protocol.c **** void protocol_execute_realtime()
 206:grbl/protocol.c **** {
 207:grbl/protocol.c ****   protocol_exec_rt_system();
 208:grbl/protocol.c ****   if (sys.suspend) { protocol_exec_rt_suspend(); }
 209:grbl/protocol.c **** }
 210:grbl/protocol.c **** 
 211:grbl/protocol.c **** 
 212:grbl/protocol.c **** // Executes run-time commands, when required. This function primarily operates as Grbl's state
 213:grbl/protocol.c **** // machine and controls the various real-time features Grbl has to offer.
 214:grbl/protocol.c **** // NOTE: Do not alter this unless you know exactly what you are doing!
 215:grbl/protocol.c **** void protocol_exec_rt_system()
 216:grbl/protocol.c **** {
  70              		.loc 1 216 0
  71              		.cfi_startproc
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 6


  72              		@ args = 0, pretend = 0, frame = 0
  73              		@ frame_needed = 0, uses_anonymous_args = 0
  74 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
  75              	.LCFI3:
  76              		.cfi_def_cfa_offset 24
  77              		.cfi_offset 3, -24
  78              		.cfi_offset 4, -20
  79              		.cfi_offset 5, -16
  80              		.cfi_offset 6, -12
  81              		.cfi_offset 7, -8
  82              		.cfi_offset 14, -4
 217:grbl/protocol.c ****   uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
 218:grbl/protocol.c ****   rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
  83              		.loc 1 218 0
  84 0002 AE4B     		ldr	r3, .L198
  85 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  86              	.LVL2:
 219:grbl/protocol.c ****   if (rt_exec) { // Enter only if any bit flag is true
  87              		.loc 1 219 0
  88 0006 002B     		cmp	r3, #0
  89 0008 40F0B280 		bne	.L179
  90 000c AC4C     		ldr	r4, .L198+4
  91 000e AD4D     		ldr	r5, .L198+8
  92              	.LVL3:
  93              	.L6:
 220:grbl/protocol.c ****     // System alarm. Everything has shutdown by something that has gone severely wrong. Report
 221:grbl/protocol.c ****     // the source of the error to the user. If critical, Grbl disables by entering an infinite
 222:grbl/protocol.c ****     // loop until system reset/abort.
 223:grbl/protocol.c ****     sys.state = STATE_ALARM; // Set system alarm state
 224:grbl/protocol.c ****     report_alarm_message(rt_exec);
 225:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 226:grbl/protocol.c ****     if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
 227:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 228:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 229:grbl/protocol.c ****       do {
 230:grbl/protocol.c ****         // Block everything, except reset and status reports, until user issues reset or power
 231:grbl/protocol.c ****         // cycles. Hard limits typically occur while unattended or not paying attention. Gives
 232:grbl/protocol.c ****         // the user and a GUI time to do what is needed before resetting, like killing the
 233:grbl/protocol.c ****         // incoming stream. The same could be said about soft limits. While the position is not
 234:grbl/protocol.c ****         // lost, continued streaming could cause a serious crash if by chance it gets executed.
 235:grbl/protocol.c ****       } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
 236:grbl/protocol.c ****     }
 237:grbl/protocol.c ****     system_clear_exec_alarm(); // Clear alarm
 238:grbl/protocol.c ****   }
 239:grbl/protocol.c **** 
 240:grbl/protocol.c ****   rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
  94              		.loc 1 240 0
  95 0010 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
  96              	.LVL4:
 241:grbl/protocol.c ****   if (rt_exec) {
  97              		.loc 1 241 0
  98 0012 03F0FF05 		and	r5, r3, #255
  99 0016 002B     		cmp	r3, #0
 100 0018 5BD0     		beq	.L10
 242:grbl/protocol.c **** 
 243:grbl/protocol.c ****     // Execute system abort.
 244:grbl/protocol.c ****     if (rt_exec & EXEC_RESET) {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 7


 101              		.loc 1 244 0
 102 001a E806     		lsls	r0, r5, #27
 103 001c 00F1A580 		bmi	.L184
 245:grbl/protocol.c ****       sys.abort = true;  // Only place this is set true.
 246:grbl/protocol.c ****       return; // Nothing else to do but exit.
 247:grbl/protocol.c ****     }
 248:grbl/protocol.c **** 
 249:grbl/protocol.c ****     // Execute and serial print status
 250:grbl/protocol.c ****     if (rt_exec & EXEC_STATUS_REPORT) {
 104              		.loc 1 250 0
 105 0020 E907     		lsls	r1, r5, #31
 106 0022 00F12381 		bmi	.L185
 107              	.LVL5:
 108              	.L13:
 251:grbl/protocol.c ****       report_realtime_status();
 252:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 253:grbl/protocol.c ****     }
 254:grbl/protocol.c **** 
 255:grbl/protocol.c ****     // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
 256:grbl/protocol.c ****     // main program processes until either reset or resumed. This ensures a hold completes safely.
 257:grbl/protocol.c ****     if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
 109              		.loc 1 257 0
 110 0026 15F0E80F 		tst	r5, #232
 111 002a 33D0     		beq	.L14
 258:grbl/protocol.c **** 
 259:grbl/protocol.c ****       // State check for allowable states for hold methods.
 260:grbl/protocol.c ****       if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
 112              		.loc 1 260 0
 113 002c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 114 002e 6EB2     		sxtb	r6, r5
 115 0030 9A07     		lsls	r2, r3, #30
 116 0032 29D1     		bne	.L16
 261:grbl/protocol.c ****       
 262:grbl/protocol.c ****         // If in CYCLE or JOG states, immediately initiate a motion HOLD.
 263:grbl/protocol.c ****         if (sys.state & (STATE_CYCLE | STATE_JOG)) {
 117              		.loc 1 263 0
 118 0034 13F0280F 		tst	r3, #40
 119 0038 40F04C81 		bne	.L186
 120              	.L17:
 121 003c 05F04001 		and	r1, r5, #64
 122 0040 05F00802 		and	r2, r5, #8
 264:grbl/protocol.c ****           if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already
 265:grbl/protocol.c ****             st_update_plan_block_parameters(); // Notify stepper module to recompute for hold decel
 266:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active fla
 267:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 268:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 269:grbl/protocol.c ****             }
 270:grbl/protocol.c ****           }
 271:grbl/protocol.c ****         }
 272:grbl/protocol.c ****         // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
 273:grbl/protocol.c ****         if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
 123              		.loc 1 273 0
 124 0044 002B     		cmp	r3, #0
 125 0046 40F04D81 		bne	.L20
 126              		.loc 1 273 0 is_stmt 0 discriminator 1
 127 004a 0120     		movs	r0, #1
 128 004c A070     		strb	r0, [r4, #2]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 8


 274:grbl/protocol.c **** 
 275:grbl/protocol.c ****         // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by
 276:grbl/protocol.c ****         // to halt and cancel the remainder of the motion.
 277:grbl/protocol.c ****         if (rt_exec & EXEC_MOTION_CANCEL) {
 129              		.loc 1 277 0 is_stmt 1 discriminator 1
 130 004e 0029     		cmp	r1, #0
 131 0050 00F06F81 		beq	.L187
 132              		.loc 1 277 0 is_stmt 0
 133 0054 4121     		movs	r1, #65
 278:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 279:grbl/protocol.c ****           // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, whil
 280:grbl/protocol.c ****           // will handle and clear multiple planner block motions.
 281:grbl/protocol.c ****           if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is
 134              		.loc 1 281 0 is_stmt 1
 135 0056 A170     		strb	r1, [r4, #2]
 136              	.L23:
 282:grbl/protocol.c ****         }
 283:grbl/protocol.c **** 
 284:grbl/protocol.c ****         // Execute a feed hold with deceleration, if required. Then, suspend system.
 285:grbl/protocol.c ****         if (rt_exec & EXEC_FEED_HOLD) {
 137              		.loc 1 285 0
 138 0058 1AB1     		cbz	r2, .L25
 286:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 287:grbl/protocol.c ****           if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOL
 139              		.loc 1 287 0
 140 005a 13F0E00F 		tst	r3, #224
 141 005e 00F06B81 		beq	.L82
 142              	.L25:
 288:grbl/protocol.c ****         }
 289:grbl/protocol.c **** 
 290:grbl/protocol.c ****         // Execute a safety door stop with a feed hold and disable spindle/coolant.
 291:grbl/protocol.c ****         // NOTE: Safety door differs from feed holds by stopping everything no matter state, disabl
 292:grbl/protocol.c ****         // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
 293:grbl/protocol.c ****         if (rt_exec & EXEC_SAFETY_DOOR) {
 143              		.loc 1 293 0
 144 0062 A806     		lsls	r0, r5, #26
 145 0064 10D5     		bpl	.L16
 294:grbl/protocol.c ****           report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 146              		.loc 1 294 0
 147 0066 0620     		movs	r0, #6
 148 0068 FFF7FEFF 		bl	report_feedback_message
 149              	.LVL6:
 295:grbl/protocol.c ****           // If jogging, block safety door methods until jog cancel is complete. Just flag that it 
 296:grbl/protocol.c ****           if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
 150              		.loc 1 296 0
 151 006c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 152 006e 1906     		lsls	r1, r3, #24
 153 0070 07D4     		bmi	.L28
 297:grbl/protocol.c ****             // Check if the safety re-opened during a restore parking motion only. Ignore if
 298:grbl/protocol.c ****             // already retracting, parked or in sleep state.
 299:grbl/protocol.c ****             if (sys.state == STATE_SAFETY_DOOR) {
 154              		.loc 1 299 0
 155 0072 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 156 0074 402A     		cmp	r2, #64
 157 0076 00F0A081 		beq	.L188
 300:grbl/protocol.c ****               if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 301:grbl/protocol.c ****                 #ifdef PARKING_ENABLE
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 9


 302:grbl/protocol.c ****                   // Set hold and reset appropriate control flags to restart parking sequence.
 303:grbl/protocol.c ****                   if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
 304:grbl/protocol.c ****                     st_update_plan_block_parameters(); // Notify stepper module to recompute for ho
 305:grbl/protocol.c ****                     sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION
 306:grbl/protocol.c ****                     sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
 307:grbl/protocol.c ****                   } // else NO_MOTION is active.
 308:grbl/protocol.c ****                 #endif
 309:grbl/protocol.c ****                 sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_REST
 310:grbl/protocol.c ****                 sys.suspend |= SUSPEND_RESTART_RETRACT;
 311:grbl/protocol.c ****               }
 312:grbl/protocol.c ****             }
 313:grbl/protocol.c ****             if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
 158              		.loc 1 313 0
 159 007a 802A     		cmp	r2, #128
 160 007c 01D0     		beq	.L28
 161              	.L30:
 162              		.loc 1 313 0 is_stmt 0 discriminator 1
 163 007e 4022     		movs	r2, #64
 164 0080 2270     		strb	r2, [r4]
 165              	.L28:
 314:grbl/protocol.c ****           }
 315:grbl/protocol.c ****           // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any par
 316:grbl/protocol.c ****           // are executed if the door switch closes and the state returns to HOLD.
 317:grbl/protocol.c ****           sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
 166              		.loc 1 317 0 is_stmt 1
 167 0082 43F02003 		orr	r3, r3, #32
 168 0086 A370     		strb	r3, [r4, #2]
 169              	.L16:
 318:grbl/protocol.c ****         }
 319:grbl/protocol.c ****         
 320:grbl/protocol.c ****       }
 321:grbl/protocol.c **** 
 322:grbl/protocol.c ****       if (rt_exec & EXEC_SLEEP) {
 170              		.loc 1 322 0
 171 0088 002E     		cmp	r6, #0
 172 008a C0F23F81 		blt	.L189
 173              	.L31:
 323:grbl/protocol.c ****         if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPL
 324:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 325:grbl/protocol.c ****       }
 326:grbl/protocol.c **** 
 327:grbl/protocol.c ****       system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_S
 174              		.loc 1 327 0
 175 008e E820     		movs	r0, #232
 176 0090 FFF7FEFF 		bl	system_clear_exec_state_flag
 177              	.LVL7:
 178              	.L14:
 328:grbl/protocol.c ****     }
 329:grbl/protocol.c **** 
 330:grbl/protocol.c ****     // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in que
 331:grbl/protocol.c ****     if (rt_exec & EXEC_CYCLE_START) {
 179              		.loc 1 331 0
 180 0094 AB07     		lsls	r3, r5, #30
 181 0096 19D5     		bpl	.L33
 332:grbl/protocol.c ****       // Block if called at same time as the hold commands: feed hold, motion cancel, and safety do
 333:grbl/protocol.c ****       // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
 334:grbl/protocol.c ****       if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 10


 182              		.loc 1 334 0
 183 0098 15F0680F 		tst	r5, #104
 184 009c 13D1     		bne	.L35
 335:grbl/protocol.c ****         // Resume door state when parking motion has retracted and door has been closed.
 336:grbl/protocol.c ****         if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
 185              		.loc 1 336 0
 186 009e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 187 00a0 402B     		cmp	r3, #64
 188 00a2 00F02A81 		beq	.L190
 337:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 338:grbl/protocol.c ****             sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 339:grbl/protocol.c ****           } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 340:grbl/protocol.c ****             // Flag to re-energize powered components and restore original position, if disabled by
 341:grbl/protocol.c ****             // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD s
 342:grbl/protocol.c ****             // the retraction execution is complete, which implies the initial feed hold is not act
 343:grbl/protocol.c ****             // restore normal operation, the restore procedures must be initiated by the following 
 344:grbl/protocol.c ****             // they are complete, it will call CYCLE_START automatically to resume and exit the sus
 345:grbl/protocol.c ****             sys.suspend |= SUSPEND_INITIATE_RESTORE;
 346:grbl/protocol.c ****           }
 347:grbl/protocol.c ****         }
 348:grbl/protocol.c ****         // Cycle start only when IDLE or when a hold is complete and ready to resume.
 349:grbl/protocol.c ****         if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_C
 189              		.loc 1 349 0
 190 00a6 002B     		cmp	r3, #0
 191 00a8 40F04981 		bne	.L191
 192              	.L39:
 350:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 351:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 352:grbl/protocol.c ****           } else {
 353:grbl/protocol.c ****             // Start cycle only if queued motions exist in planner buffer and the motion is not can
 354:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
 193              		.loc 1 354 0
 194 00ac 0023     		movs	r3, #0
 195 00ae 2371     		strb	r3, [r4, #4]
 355:grbl/protocol.c ****             if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 196              		.loc 1 355 0
 197 00b0 FFF7FEFF 		bl	plan_get_current_block
 198              	.LVL8:
 199 00b4 20B1     		cbz	r0, .L42
 200              		.loc 1 355 0 is_stmt 0 discriminator 1
 201 00b6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 202 00b8 13F04003 		ands	r3, r3, #64
 203 00bc 00F06E81 		beq	.L192
 204              	.L42:
 356:grbl/protocol.c ****               sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 357:grbl/protocol.c ****               sys.state = STATE_CYCLE;
 358:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 359:grbl/protocol.c ****               st_wake_up();
 360:grbl/protocol.c ****             } else { // Otherwise, do nothing. Set and resume IDLE state.
 361:grbl/protocol.c ****               sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 205              		.loc 1 361 0 is_stmt 1
 206 00c0 0023     		movs	r3, #0
 207 00c2 A370     		strb	r3, [r4, #2]
 362:grbl/protocol.c ****               sys.state = STATE_IDLE;
 208              		.loc 1 362 0
 209 00c4 2370     		strb	r3, [r4]
 210              	.L35:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 11


 363:grbl/protocol.c ****             }
 364:grbl/protocol.c ****           }
 365:grbl/protocol.c ****         }
 366:grbl/protocol.c ****       }
 367:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_CYCLE_START);
 211              		.loc 1 367 0
 212 00c6 0220     		movs	r0, #2
 213 00c8 FFF7FEFF 		bl	system_clear_exec_state_flag
 214              	.LVL9:
 215              	.L33:
 368:grbl/protocol.c ****     }
 369:grbl/protocol.c **** 
 370:grbl/protocol.c ****     if (rt_exec & EXEC_CYCLE_STOP) {
 216              		.loc 1 370 0
 217 00cc 6907     		lsls	r1, r5, #29
 218 00ce 00F1B580 		bmi	.L193
 219              	.L10:
 371:grbl/protocol.c ****       // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
 372:grbl/protocol.c ****       // realtime command execution in the main program, ensuring that the planner re-plans safely.
 373:grbl/protocol.c ****       // NOTE: Bresenham algorithm variables are still maintained through both the planner and step
 374:grbl/protocol.c ****       // cycle reinitializations. The stepper path should continue exactly as if nothing has happen
 375:grbl/protocol.c ****       // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
 376:grbl/protocol.c ****       if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.su
 377:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 378:grbl/protocol.c ****         // has issued a resume command or reset.
 379:grbl/protocol.c ****         plan_cycle_reinitialize();
 380:grbl/protocol.c ****         if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 381:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 382:grbl/protocol.c ****       } else {
 383:grbl/protocol.c ****         // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limi
 384:grbl/protocol.c ****         // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
 385:grbl/protocol.c ****         if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positio
 386:grbl/protocol.c ****           sys.step_control = STEP_CONTROL_NORMAL_OP;
 387:grbl/protocol.c ****           plan_reset();
 388:grbl/protocol.c ****           st_reset();
 389:grbl/protocol.c ****           gc_sync_position();
 390:grbl/protocol.c ****           plan_sync_position();
 391:grbl/protocol.c ****         }
 392:grbl/protocol.c ****         if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during 
 393:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 394:grbl/protocol.c ****           sys.suspend |= SUSPEND_HOLD_COMPLETE;
 395:grbl/protocol.c ****           sys.state = STATE_SAFETY_DOOR;
 396:grbl/protocol.c ****         } else {
 397:grbl/protocol.c ****           sys.suspend = SUSPEND_DISABLE;
 398:grbl/protocol.c ****           sys.state = STATE_IDLE;
 399:grbl/protocol.c ****         }
 400:grbl/protocol.c ****       }
 401:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_CYCLE_STOP);
 402:grbl/protocol.c ****     }
 403:grbl/protocol.c ****   }
 404:grbl/protocol.c **** 
 405:grbl/protocol.c ****   // Execute overrides.
 406:grbl/protocol.c ****   rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
 220              		.loc 1 406 0
 221 00d2 7D4B     		ldr	r3, .L198+12
 222 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 223              	.LVL10:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 12


 407:grbl/protocol.c ****   if (rt_exec) {
 224              		.loc 1 407 0
 225 00d6 03F0FF05 		and	r5, r3, #255
 226 00da 002B     		cmp	r3, #0
 227 00dc 73D1     		bne	.L194
 228              	.LVL11:
 229              	.L51:
 408:grbl/protocol.c ****     system_clear_exec_motion_overrides(); // Clear all motion override flags.
 409:grbl/protocol.c **** 
 410:grbl/protocol.c ****     uint8_t new_f_override =  sys.f_override;
 411:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 412:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
 413:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 414:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 415:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 416:grbl/protocol.c ****     new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 417:grbl/protocol.c ****     new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
 418:grbl/protocol.c **** 
 419:grbl/protocol.c ****     uint8_t new_r_override = sys.r_override;
 420:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 421:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
 422:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 423:grbl/protocol.c **** 
 424:grbl/protocol.c ****     if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
 425:grbl/protocol.c ****       sys.f_override = new_f_override;
 426:grbl/protocol.c ****       sys.r_override = new_r_override;
 427:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 428:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 429:grbl/protocol.c ****       plan_cycle_reinitialize();
 430:grbl/protocol.c ****     }
 431:grbl/protocol.c ****   }
 432:grbl/protocol.c **** 
 433:grbl/protocol.c ****   rt_exec = sys_rt_exec_accessory_override;
 230              		.loc 1 433 0
 231 00de 7B4B     		ldr	r3, .L198+16
 232 00e0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 233              	.LVL12:
 434:grbl/protocol.c ****   if (rt_exec) {
 234              		.loc 1 434 0
 235 00e2 03F0FF05 		and	r5, r3, #255
 236 00e6 23B9     		cbnz	r3, .L62
 237 00e8 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 238              	.LVL13:
 239              	.L63:
 435:grbl/protocol.c ****     system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 436:grbl/protocol.c **** 
 437:grbl/protocol.c ****     // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
 438:grbl/protocol.c ****     uint8_t last_s_override =  sys.spindle_speed_ovr;
 439:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 440:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREM
 441:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCRE
 442:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 443:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT
 444:grbl/protocol.c ****     last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 445:grbl/protocol.c ****     last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
 446:grbl/protocol.c **** 
 447:grbl/protocol.c ****     if (last_s_override != sys.spindle_speed_ovr) {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 13


 448:grbl/protocol.c ****       bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 449:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 450:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 451:grbl/protocol.c ****     }
 452:grbl/protocol.c **** 
 453:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
 454:grbl/protocol.c ****       // Spindle stop override allowed only while in HOLD state.
 455:grbl/protocol.c ****       // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
 456:grbl/protocol.c ****       if (sys.state == STATE_HOLD) {
 457:grbl/protocol.c ****         if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 458:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 459:grbl/protocol.c ****       }
 460:grbl/protocol.c ****     }
 461:grbl/protocol.c **** 
 462:grbl/protocol.c ****     // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
 463:grbl/protocol.c ****     // run state can be determined by checking the parser state.
 464:grbl/protocol.c ****     if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
 465:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 466:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 467:grbl/protocol.c ****         #ifdef ENABLE_M7
 468:grbl/protocol.c ****           if (rt_exec & EXEC_COOLANT_MIST_OVR_TOGGLE) {
 469:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 470:grbl/protocol.c ****             else { coolant_state |= COOLANT_MIST_ENABLE; }
 471:grbl/protocol.c ****           }
 472:grbl/protocol.c ****           if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
 473:grbl/protocol.c ****             if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABL
 474:grbl/protocol.c ****             else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 475:grbl/protocol.c ****           }
 476:grbl/protocol.c ****         #else
 477:grbl/protocol.c ****           if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE)
 478:grbl/protocol.c ****           else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 479:grbl/protocol.c ****         #endif
 480:grbl/protocol.c ****         coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
 481:grbl/protocol.c ****         gc_state.modal.coolant = coolant_state;
 482:grbl/protocol.c ****       }
 483:grbl/protocol.c ****     }
 484:grbl/protocol.c ****   }
 485:grbl/protocol.c **** 
 486:grbl/protocol.c ****   #ifdef DEBUG
 487:grbl/protocol.c ****     if (sys_rt_exec_debug) {
 488:grbl/protocol.c ****       report_realtime_debug();
 489:grbl/protocol.c ****       sys_rt_exec_debug = 0;
 490:grbl/protocol.c ****     }
 491:grbl/protocol.c ****   #endif
 492:grbl/protocol.c **** 
 493:grbl/protocol.c ****   // Reload step segment buffer
 494:grbl/protocol.c ****   if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE
 240              		.loc 1 494 0
 241 00ea 13F0FC0F 		tst	r3, #252
 242 00ee 38D1     		bne	.L81
 495:grbl/protocol.c ****     st_prep_buffer();
 496:grbl/protocol.c ****   }
 497:grbl/protocol.c **** 
 498:grbl/protocol.c **** }
 243              		.loc 1 498 0
 244 00f0 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 245              	.LVL14:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 14


 246              	.L62:
 247              	.LBB13:
 435:grbl/protocol.c ****     system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 248              		.loc 1 435 0
 249 00f2 FFF7FEFF 		bl	system_clear_exec_accessory_overrides
 250              	.LVL15:
 438:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 251              		.loc 1 438 0
 252 00f6 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
 253              	.LVL16:
 254 00f8 15F0010F 		tst	r5, #1
 255 00fc 0CBF     		ite	eq
 256 00fe 1346     		moveq	r3, r2
 257 0100 6423     		movne	r3, #100
 258              	.LVL17:
 440:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCRE
 259              		.loc 1 440 0
 260 0102 AE07     		lsls	r6, r5, #30
 261 0104 44BF     		itt	mi
 262 0106 0A33     		addmi	r3, r3, #10
 263              	.LVL18:
 264 0108 DBB2     		uxtbmi	r3, r3
 265              	.LVL19:
 441:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 266              		.loc 1 441 0
 267 010a 6807     		lsls	r0, r5, #29
 268 010c 44BF     		itt	mi
 269 010e 0A3B     		submi	r3, r3, #10
 270              	.LVL20:
 271 0110 DBB2     		uxtbmi	r3, r3
 272              	.LVL21:
 442:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT
 273              		.loc 1 442 0
 274 0112 2907     		lsls	r1, r5, #28
 275 0114 44BF     		itt	mi
 276 0116 0133     		addmi	r3, r3, #1
 277              	.LVL22:
 278 0118 DBB2     		uxtbmi	r3, r3
 279              	.LVL23:
 443:grbl/protocol.c ****     last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 280              		.loc 1 443 0
 281 011a EF06     		lsls	r7, r5, #27
 282 011c 44BF     		itt	mi
 283 011e 03F1FF33 		addmi	r3, r3, #-1
 284              	.LVL24:
 285 0122 DBB2     		uxtbmi	r3, r3
 286              	.LVL25:
 445:grbl/protocol.c **** 
 287              		.loc 1 445 0
 288 0124 C82B     		cmp	r3, #200
 289 0126 28BF     		it	cs
 290 0128 C823     		movcs	r3, #200
 291              	.LVL26:
 292 012a 0A2B     		cmp	r3, #10
 293 012c 38BF     		it	cc
 294 012e 0A23     		movcc	r3, #10
 295              	.LVL27:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 15


 447:grbl/protocol.c ****       bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 296              		.loc 1 447 0
 297 0130 9A42     		cmp	r2, r3
 298 0132 06D0     		beq	.L69
 450:grbl/protocol.c ****     }
 299              		.loc 1 450 0
 300 0134 0021     		movs	r1, #0
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 301              		.loc 1 448 0
 302 0136 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 449:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 303              		.loc 1 449 0
 304 0138 A372     		strb	r3, [r4, #10]
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 305              		.loc 1 448 0
 306 013a 42F00803 		orr	r3, r2, #8
 307              	.LVL28:
 308 013e 2371     		strb	r3, [r4, #4]
 450:grbl/protocol.c ****     }
 309              		.loc 1 450 0
 310 0140 2173     		strb	r1, [r4, #12]
 311              	.LVL29:
 312              	.L69:
 453:grbl/protocol.c ****       // Spindle stop override allowed only while in HOLD state.
 313              		.loc 1 453 0
 314 0142 AE06     		lsls	r6, r5, #26
 315 0144 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 316 0146 05F0C002 		and	r2, r5, #192
 317 014a 20D5     		bpl	.L70
 456:grbl/protocol.c ****         if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 318              		.loc 1 456 0
 319 014c 102B     		cmp	r3, #16
 320 014e 1ED1     		bne	.L70
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 321              		.loc 1 457 0
 322 0150 E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 323 0152 0029     		cmp	r1, #0
 324 0154 40F0E480 		bne	.L71
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 325              		.loc 1 457 0 is_stmt 0 discriminator 1
 326 0158 0221     		movs	r1, #2
 327 015a E172     		strb	r1, [r4, #11]
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 328              		.loc 1 464 0 is_stmt 1 discriminator 1
 329 015c 002A     		cmp	r2, #0
 330 015e 40F09980 		bne	.L72
 331              	.L81:
 332              	.LBE13:
 333              		.loc 1 498 0
 334 0162 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 335              	.LCFI4:
 336              		.cfi_remember_state
 337              		.cfi_restore 14
 338              		.cfi_restore 7
 339              		.cfi_restore 6
 340              		.cfi_restore 5
 341              		.cfi_restore 4
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 16


 342              		.cfi_restore 3
 343              		.cfi_def_cfa_offset 0
 495:grbl/protocol.c ****   }
 344              		.loc 1 495 0
 345 0166 FFF7FEBF 		b	st_prep_buffer
 346              	.LVL30:
 347              	.L184:
 348              	.LCFI5:
 349              		.cfi_restore_state
 245:grbl/protocol.c ****       return; // Nothing else to do but exit.
 350              		.loc 1 245 0
 351 016a 0123     		movs	r3, #1
 352              	.LVL31:
 353 016c 6370     		strb	r3, [r4, #1]
 354              		.loc 1 498 0
 355 016e F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 356              	.LVL32:
 357              	.L179:
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 358              		.loc 1 223 0
 359 0170 0126     		movs	r6, #1
 360 0172 03F0FF05 		and	r5, r3, #255
 361 0176 524C     		ldr	r4, .L198+4
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 362              		.loc 1 224 0
 363 0178 2846     		mov	r0, r5
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 364              		.loc 1 226 0
 365 017a 013D     		subs	r5, r5, #1
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 366              		.loc 1 223 0
 367 017c 2670     		strb	r6, [r4]
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 368              		.loc 1 224 0
 369 017e FFF7FEFF 		bl	report_alarm_message
 370              	.LVL33:
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 371              		.loc 1 226 0
 372 0182 B542     		cmp	r5, r6
 373 0184 78D9     		bls	.L180
 374 0186 4F4D     		ldr	r5, .L198+8
 375              	.L7:
 237:grbl/protocol.c ****   }
 376              		.loc 1 237 0
 377 0188 FFF7FEFF 		bl	system_clear_exec_alarm
 378              	.LVL34:
 379 018c 40E7     		b	.L6
 380              	.L70:
 381              	.LBB15:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 382              		.loc 1 464 0
 383 018e 002A     		cmp	r2, #0
 384 0190 ABD0     		beq	.L63
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 385              		.loc 1 465 0
 386 0192 002B     		cmp	r3, #0
 387 0194 7ED1     		bne	.L72
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 17


 388              	.L73:
 389              	.LBB14:
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 390              		.loc 1 466 0
 391 0196 4E4F     		ldr	r7, .L198+20
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 392              		.loc 1 468 0
 393 0198 2A06     		lsls	r2, r5, #24
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 394              		.loc 1 466 0
 395 019a 3E7A     		ldrb	r6, [r7, #8]	@ zero_extendqisi2
 396              	.LVL35:
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 397              		.loc 1 468 0
 398 019c 05D5     		bpl	.L77
 469:grbl/protocol.c ****             else { coolant_state |= COOLANT_MIST_ENABLE; }
 399              		.loc 1 469 0
 400 019e 3306     		lsls	r3, r6, #24
 401 01a0 4CBF     		ite	mi
 402 01a2 06F07F06 		andmi	r6, r6, #127
 403              	.LVL36:
 470:grbl/protocol.c ****           }
 404              		.loc 1 470 0
 405 01a6 46F08006 		orrpl	r6, r6, #128
 406              	.LVL37:
 407              	.L77:
 472:grbl/protocol.c ****             if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABL
 408              		.loc 1 472 0
 409 01aa 6806     		lsls	r0, r5, #25
 410 01ac 05D5     		bpl	.L79
 473:grbl/protocol.c ****             else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 411              		.loc 1 473 0
 412 01ae 7106     		lsls	r1, r6, #25
 413 01b0 4CBF     		ite	mi
 414 01b2 06F0BF06 		andmi	r6, r6, #191
 415              	.LVL38:
 474:grbl/protocol.c ****           }
 416              		.loc 1 474 0
 417 01b6 46F04006 		orrpl	r6, r6, #64
 418              	.LVL39:
 419              	.L79:
 480:grbl/protocol.c ****         gc_state.modal.coolant = coolant_state;
 420              		.loc 1 480 0
 421 01ba 3046     		mov	r0, r6
 422 01bc FFF7FEFF 		bl	coolant_set_state
 423              	.LVL40:
 424 01c0 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 481:grbl/protocol.c ****       }
 425              		.loc 1 481 0
 426 01c2 3E72     		strb	r6, [r7, #8]
 427 01c4 91E7     		b	.L63
 428              	.LVL41:
 429              	.L194:
 430              	.LBE14:
 431              	.LBE15:
 432              	.LBB16:
 408:grbl/protocol.c **** 
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 18


 433              		.loc 1 408 0
 434 01c6 FFF7FEFF 		bl	system_clear_exec_motion_overrides
 435              	.LVL42:
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 436              		.loc 1 410 0
 437 01ca 217A     		ldrb	r1, [r4, #8]	@ zero_extendqisi2
 438              	.LVL43:
 439 01cc 15F0010F 		tst	r5, #1
 440 01d0 0CBF     		ite	eq
 441 01d2 0B46     		moveq	r3, r1
 442 01d4 6423     		movne	r3, #100
 443              	.LVL44:
 412:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 444              		.loc 1 412 0
 445 01d6 AF07     		lsls	r7, r5, #30
 446 01d8 44BF     		itt	mi
 447 01da 0A33     		addmi	r3, r3, #10
 448              	.LVL45:
 449 01dc DBB2     		uxtbmi	r3, r3
 450              	.LVL46:
 413:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 451              		.loc 1 413 0
 452 01de 6E07     		lsls	r6, r5, #29
 453 01e0 44BF     		itt	mi
 454 01e2 0A3B     		submi	r3, r3, #10
 455              	.LVL47:
 456 01e4 DBB2     		uxtbmi	r3, r3
 457              	.LVL48:
 414:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 458              		.loc 1 414 0
 459 01e6 2807     		lsls	r0, r5, #28
 460 01e8 44BF     		itt	mi
 461 01ea 0133     		addmi	r3, r3, #1
 462              	.LVL49:
 463 01ec DBB2     		uxtbmi	r3, r3
 464              	.LVL50:
 415:grbl/protocol.c ****     new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 465              		.loc 1 415 0
 466 01ee EF06     		lsls	r7, r5, #27
 467 01f0 44BF     		itt	mi
 468 01f2 03F1FF33 		addmi	r3, r3, #-1
 469              	.LVL51:
 470 01f6 DBB2     		uxtbmi	r3, r3
 471              	.LVL52:
 417:grbl/protocol.c **** 
 472              		.loc 1 417 0
 473 01f8 C82B     		cmp	r3, #200
 474 01fa 28BF     		it	cs
 475 01fc C823     		movcs	r3, #200
 476              	.LVL53:
 477 01fe 0A2B     		cmp	r3, #10
 478 0200 38BF     		it	cc
 479 0202 0A23     		movcc	r3, #10
 480              	.LVL54:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 481              		.loc 1 419 0
 482 0204 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 19


 483              	.LVL55:
 484 0206 15F0200F 		tst	r5, #32
 485 020a 14BF     		ite	ne
 486 020c 6422     		movne	r2, #100
 487 020e 0246     		moveq	r2, r0
 488              	.LVL56:
 421:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 489              		.loc 1 421 0
 490 0210 15F0400F 		tst	r5, #64
 491 0214 18BF     		it	ne
 492 0216 3222     		movne	r2, #50
 493              	.LVL57:
 422:grbl/protocol.c **** 
 494              		.loc 1 422 0
 495 0218 15F0800F 		tst	r5, #128
 496 021c 18BF     		it	ne
 497 021e 1922     		movne	r2, #25
 498              	.LVL58:
 424:grbl/protocol.c ****       sys.f_override = new_f_override;
 499              		.loc 1 424 0
 500 0220 9942     		cmp	r1, r3
 501 0222 02D1     		bne	.L60
 424:grbl/protocol.c ****       sys.f_override = new_f_override;
 502              		.loc 1 424 0 is_stmt 0 discriminator 1
 503 0224 8242     		cmp	r2, r0
 504 0226 3FF45AAF 		beq	.L51
 505              	.L60:
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 506              		.loc 1 427 0 is_stmt 1
 507 022a 0021     		movs	r1, #0
 425:grbl/protocol.c ****       sys.r_override = new_r_override;
 508              		.loc 1 425 0
 509 022c 2372     		strb	r3, [r4, #8]
 426:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 510              		.loc 1 426 0
 511 022e 6272     		strb	r2, [r4, #9]
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 512              		.loc 1 427 0
 513 0230 2173     		strb	r1, [r4, #12]
 428:grbl/protocol.c ****       plan_cycle_reinitialize();
 514              		.loc 1 428 0
 515 0232 FFF7FEFF 		bl	plan_update_velocity_profile_parameters
 516              	.LVL59:
 429:grbl/protocol.c ****     }
 517              		.loc 1 429 0
 518 0236 FFF7FEFF 		bl	plan_cycle_reinitialize
 519              	.LVL60:
 520 023a 50E7     		b	.L51
 521              	.L193:
 522              	.LBE16:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 523              		.loc 1 376 0
 524 023c 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 525 023e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 526 0240 12F0D00F 		tst	r2, #208
 527 0244 59B2     		sxtb	r1, r3
 528 0246 01D0     		beq	.L44
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 20


 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 529              		.loc 1 376 0 is_stmt 0 discriminator 1
 530 0248 E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 531 024a 42B3     		cbz	r2, .L195
 532              	.L44:
 385:grbl/protocol.c ****           sys.step_control = STEP_CONTROL_NORMAL_OP;
 533              		.loc 1 385 0 is_stmt 1
 534 024c 0029     		cmp	r1, #0
 535 024e 28DB     		blt	.L45
 536              	.L48:
 392:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 537              		.loc 1 392 0
 538 0250 13F02002 		ands	r2, r3, #32
 539 0254 1BD0     		beq	.L49
 395:grbl/protocol.c ****         } else {
 540              		.loc 1 395 0
 541 0256 4022     		movs	r2, #64
 393:grbl/protocol.c ****           sys.suspend |= SUSPEND_HOLD_COMPLETE;
 542              		.loc 1 393 0
 543 0258 03F07F03 		and	r3, r3, #127
 394:grbl/protocol.c ****           sys.state = STATE_SAFETY_DOOR;
 544              		.loc 1 394 0
 545 025c 43F00103 		orr	r3, r3, #1
 546 0260 A370     		strb	r3, [r4, #2]
 395:grbl/protocol.c ****         } else {
 547              		.loc 1 395 0
 548 0262 2270     		strb	r2, [r4]
 549              	.L47:
 401:grbl/protocol.c ****     }
 550              		.loc 1 401 0
 551 0264 0420     		movs	r0, #4
 552 0266 FFF7FEFF 		bl	system_clear_exec_state_flag
 553              	.LVL61:
 554 026a 32E7     		b	.L10
 555              	.LVL62:
 556              	.L185:
 251:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 557              		.loc 1 251 0
 558 026c FFF7FEFF 		bl	report_realtime_status
 559              	.LVL63:
 252:grbl/protocol.c ****     }
 560              		.loc 1 252 0
 561 0270 0120     		movs	r0, #1
 562 0272 FFF7FEFF 		bl	system_clear_exec_state_flag
 563              	.LVL64:
 564 0276 D6E6     		b	.L13
 565              	.L180:
 227:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 566              		.loc 1 227 0
 567 0278 3046     		mov	r0, r6
 568 027a FFF7FEFF 		bl	report_feedback_message
 569              	.LVL65:
 228:grbl/protocol.c ****       do {
 570              		.loc 1 228 0
 571 027e 1020     		movs	r0, #16
 572 0280 FFF7FEFF 		bl	system_clear_exec_state_flag
 573              	.LVL66:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 21


 574 0284 0F4D     		ldr	r5, .L198+8
 575              	.L8:
 235:grbl/protocol.c ****     }
 576              		.loc 1 235 0 discriminator 1
 577 0286 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 578 0288 DE06     		lsls	r6, r3, #27
 579 028a FCD5     		bpl	.L8
 580 028c 7CE7     		b	.L7
 581              	.L49:
 397:grbl/protocol.c ****           sys.state = STATE_IDLE;
 582              		.loc 1 397 0
 583 028e A270     		strb	r2, [r4, #2]
 398:grbl/protocol.c ****         }
 584              		.loc 1 398 0
 585 0290 2270     		strb	r2, [r4]
 586 0292 E7E7     		b	.L47
 587              	.L72:
 588              	.LBB17:
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 589              		.loc 1 465 0 discriminator 1
 590 0294 13F0180F 		tst	r3, #24
 591 0298 3FF427AF 		beq	.L63
 592 029c 7BE7     		b	.L73
 593              	.L195:
 594              	.LBE17:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 595              		.loc 1 376 0 discriminator 2
 596 029e 0029     		cmp	r1, #0
 597 02a0 5FDA     		bge	.L196
 598              	.L45:
 386:grbl/protocol.c ****           plan_reset();
 599              		.loc 1 386 0
 600 02a2 0023     		movs	r3, #0
 601 02a4 2371     		strb	r3, [r4, #4]
 387:grbl/protocol.c ****           st_reset();
 602              		.loc 1 387 0
 603 02a6 FFF7FEFF 		bl	plan_reset
 604              	.LVL67:
 388:grbl/protocol.c ****           gc_sync_position();
 605              		.loc 1 388 0
 606 02aa FFF7FEFF 		bl	st_reset
 607              	.LVL68:
 389:grbl/protocol.c ****           plan_sync_position();
 608              		.loc 1 389 0
 609 02ae FFF7FEFF 		bl	gc_sync_position
 610              	.LVL69:
 390:grbl/protocol.c ****         }
 611              		.loc 1 390 0
 612 02b2 FFF7FEFF 		bl	plan_sync_position
 613              	.LVL70:
 614 02b6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 615 02b8 CAE7     		b	.L48
 616              	.L199:
 617 02ba 00BF     		.align	2
 618              	.L198:
 619 02bc 00000000 		.word	sys_rt_exec_alarm
 620 02c0 00000000 		.word	sys
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 22


 621 02c4 00000000 		.word	sys_rt_exec_state
 622 02c8 00000000 		.word	sys_rt_exec_motion_override
 623 02cc 00000000 		.word	sys_rt_exec_accessory_override
 624 02d0 00000000 		.word	gc_state
 625              	.L186:
 264:grbl/protocol.c ****             st_update_plan_block_parameters(); // Notify stepper module to recompute for hold decel
 626              		.loc 1 264 0
 627 02d4 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 628 02d6 12F0C00F 		tst	r2, #192
 629 02da 4FD0     		beq	.L197
 630 02dc 05F04001 		and	r1, r5, #64
 631 02e0 05F00802 		and	r2, r5, #8
 632              	.L20:
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 633              		.loc 1 277 0
 634 02e4 0029     		cmp	r1, #0
 635 02e6 3FF4B7AE 		beq	.L23
 281:grbl/protocol.c ****         }
 636              		.loc 1 281 0
 637 02ea 9F06     		lsls	r7, r3, #26
 638 02ec 3FF5B4AE 		bmi	.L23
 639 02f0 A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 640 02f2 41F04001 		orr	r1, r1, #64
 641 02f6 A170     		strb	r1, [r4, #2]
 642 02f8 AEE6     		b	.L23
 643              	.L190:
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 644              		.loc 1 336 0 discriminator 1
 645 02fa A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 646 02fc 13F02002 		ands	r2, r3, #32
 647 0300 7FF4E1AE 		bne	.L35
 337:grbl/protocol.c ****             sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 648              		.loc 1 337 0
 649 0304 DF06     		lsls	r7, r3, #27
 650 0306 51D5     		bpl	.L38
 338:grbl/protocol.c ****           } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 651              		.loc 1 338 0
 652 0308 2270     		strb	r2, [r4]
 653 030a CFE6     		b	.L39
 654              	.L189:
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 655              		.loc 1 323 0
 656 030c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 657 030e 012B     		cmp	r3, #1
 658 0310 03D1     		bne	.L32
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 659              		.loc 1 323 0 is_stmt 0 discriminator 1
 660 0312 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 661 0314 43F00503 		orr	r3, r3, #5
 662 0318 A370     		strb	r3, [r4, #2]
 663              	.L32:
 324:grbl/protocol.c ****       }
 664              		.loc 1 324 0 is_stmt 1
 665 031a 8023     		movs	r3, #128
 666 031c 2370     		strb	r3, [r4]
 667 031e B6E6     		b	.L31
 668              	.L71:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 23


 669              	.LBB18:
 458:grbl/protocol.c ****       }
 670              		.loc 1 458 0
 671 0320 C807     		lsls	r0, r1, #31
 672 0322 02D5     		bpl	.L74
 458:grbl/protocol.c ****       }
 673              		.loc 1 458 0 is_stmt 0 discriminator 1
 674 0324 41F00401 		orr	r1, r1, #4
 675 0328 E172     		strb	r1, [r4, #11]
 676              	.L74:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 677              		.loc 1 464 0 is_stmt 1
 678 032a 002A     		cmp	r2, #0
 679 032c 7FF433AF 		bne	.L73
 680 0330 17E7     		b	.L81
 681              	.L187:
 682              	.LBE18:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 683              		.loc 1 285 0
 684 0332 002A     		cmp	r2, #0
 685 0334 3FF495AE 		beq	.L25
 686              	.L82:
 287:grbl/protocol.c ****         }
 687              		.loc 1 287 0
 688 0338 1023     		movs	r3, #16
 689 033a 2370     		strb	r3, [r4]
 690 033c 91E6     		b	.L25
 691              	.L191:
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 692              		.loc 1 349 0
 693 033e DA06     		lsls	r2, r3, #27
 694 0340 7FF5C1AE 		bpl	.L35
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 695              		.loc 1 349 0 is_stmt 0 discriminator 2
 696 0344 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 697 0346 D007     		lsls	r0, r2, #31
 698 0348 7FF5BDAE 		bpl	.L35
 350:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 699              		.loc 1 350 0 is_stmt 1
 700 034c 102B     		cmp	r3, #16
 701 034e 7FF4ADAE 		bne	.L39
 350:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 702              		.loc 1 350 0 is_stmt 0 discriminator 1
 703 0352 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 704 0354 002B     		cmp	r3, #0
 705 0356 3FF4A9AE 		beq	.L39
 351:grbl/protocol.c ****           } else {
 706              		.loc 1 351 0 is_stmt 1
 707 035a 43F00803 		orr	r3, r3, #8
 708 035e E372     		strb	r3, [r4, #11]
 709 0360 B1E6     		b	.L35
 710              	.L196:
 379:grbl/protocol.c ****         if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 711              		.loc 1 379 0
 712 0362 FFF7FEFF 		bl	plan_cycle_reinitialize
 713              	.LVL71:
 380:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 24


 714              		.loc 1 380 0
 715 0366 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 716 0368 9A07     		lsls	r2, r3, #30
 717 036a 03D5     		bpl	.L46
 380:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 718              		.loc 1 380 0 is_stmt 0 discriminator 1
 719 036c A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 720 036e 42F00102 		orr	r2, r2, #1
 721 0372 A270     		strb	r2, [r4, #2]
 722              	.L46:
 381:grbl/protocol.c ****       } else {
 723              		.loc 1 381 0 is_stmt 1
 724 0374 23F00603 		bic	r3, r3, #6
 725 0378 2371     		strb	r3, [r4, #4]
 726 037a 73E7     		b	.L47
 727              	.L197:
 265:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active fla
 728              		.loc 1 265 0
 729 037c FFF7FEFF 		bl	st_update_plan_block_parameters
 730              	.LVL72:
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 731              		.loc 1 266 0
 732 0380 0222     		movs	r2, #2
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 733              		.loc 1 267 0
 734 0382 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 735              		.loc 1 266 0
 736 0384 2271     		strb	r2, [r4, #4]
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 737              		.loc 1 267 0
 738 0386 202B     		cmp	r3, #32
 739 0388 7FF458AE 		bne	.L17
 268:grbl/protocol.c ****             }
 740              		.loc 1 268 0
 741 038c 002E     		cmp	r6, #0
 742 038e FFF668AE 		blt	.L25
 268:grbl/protocol.c ****             }
 743              		.loc 1 268 0 is_stmt 0 discriminator 1
 744 0392 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 745 0394 63F07F03 		orn	r3, r3, #127
 746 0398 A370     		strb	r3, [r4, #2]
 747 039a 62E6     		b	.L25
 748              	.L192:
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 749              		.loc 1 357 0 is_stmt 1
 750 039c 0822     		movs	r2, #8
 356:grbl/protocol.c ****               sys.state = STATE_CYCLE;
 751              		.loc 1 356 0
 752 039e A370     		strb	r3, [r4, #2]
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 753              		.loc 1 357 0
 754 03a0 2270     		strb	r2, [r4]
 358:grbl/protocol.c ****               st_wake_up();
 755              		.loc 1 358 0
 756 03a2 FFF7FEFF 		bl	st_prep_buffer
 757              	.LVL73:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 25


 359:grbl/protocol.c ****             } else { // Otherwise, do nothing. Set and resume IDLE state.
 758              		.loc 1 359 0
 759 03a6 FFF7FEFF 		bl	st_wake_up
 760              	.LVL74:
 761 03aa 8CE6     		b	.L35
 762              	.L38:
 339:grbl/protocol.c ****             // Flag to re-energize powered components and restore original position, if disabled by
 763              		.loc 1 339 0
 764 03ac 5E07     		lsls	r6, r3, #29
 765 03ae 7FF58AAE 		bpl	.L35
 345:grbl/protocol.c ****           }
 766              		.loc 1 345 0
 767 03b2 43F00803 		orr	r3, r3, #8
 768 03b6 A370     		strb	r3, [r4, #2]
 769 03b8 85E6     		b	.L35
 770              	.L188:
 300:grbl/protocol.c ****                 #ifdef PARKING_ENABLE
 771              		.loc 1 300 0
 772 03ba 1A07     		lsls	r2, r3, #28
 773 03bc 7FF55FAE 		bpl	.L30
 309:grbl/protocol.c ****                 sys.suspend |= SUSPEND_RESTART_RETRACT;
 774              		.loc 1 309 0
 775 03c0 23F01C03 		bic	r3, r3, #28
 310:grbl/protocol.c ****               }
 776              		.loc 1 310 0
 777 03c4 43F00203 		orr	r3, r3, #2
 778 03c8 59E6     		b	.L30
 779              		.cfi_endproc
 780              	.LFE707:
 782 03ca 00BF     		.section	.text.protocol_exec_rt_suspend,"ax",%progbits
 783              		.align	1
 784              		.p2align 2,,3
 785              		.syntax unified
 786              		.thumb
 787              		.thumb_func
 788              		.fpu softvfp
 790              	protocol_exec_rt_suspend:
 791              	.LFB708:
 499:grbl/protocol.c **** 
 500:grbl/protocol.c **** 
 501:grbl/protocol.c **** // Handles Grbl system suspend procedures, such as feed hold, safety door, and parking motion.
 502:grbl/protocol.c **** // The system will enter this loop, create local variables for suspend tasks, and return to
 503:grbl/protocol.c **** // whatever function that invoked the suspend, such that Grbl resumes normal operation.
 504:grbl/protocol.c **** // This function is written in a way to promote custom parking motions. Simply use this as a
 505:grbl/protocol.c **** // template
 506:grbl/protocol.c **** static void protocol_exec_rt_suspend()
 507:grbl/protocol.c **** {
 792              		.loc 1 507 0
 793              		.cfi_startproc
 794              		@ args = 0, pretend = 0, frame = 8
 795              		@ frame_needed = 0, uses_anonymous_args = 0
 796 0000 2DE9F04F 		push	{r4, r5, r6, r7, r8, r9, r10, fp, lr}
 797              	.LCFI6:
 798              		.cfi_def_cfa_offset 36
 799              		.cfi_offset 4, -36
 800              		.cfi_offset 5, -32
 801              		.cfi_offset 6, -28
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 26


 802              		.cfi_offset 7, -24
 803              		.cfi_offset 8, -20
 804              		.cfi_offset 9, -16
 805              		.cfi_offset 10, -12
 806              		.cfi_offset 11, -8
 807              		.cfi_offset 14, -4
 808 0004 83B0     		sub	sp, sp, #12
 809              	.LCFI7:
 810              		.cfi_def_cfa_offset 48
 508:grbl/protocol.c ****   #ifdef PARKING_ENABLE
 509:grbl/protocol.c ****     // Declare and initialize parking local variables
 510:grbl/protocol.c ****     float restore_target[N_AXIS];
 511:grbl/protocol.c ****     float parking_target[N_AXIS];
 512:grbl/protocol.c ****     float retract_waypoint = PARKING_PULLOUT_INCREMENT;
 513:grbl/protocol.c ****     plan_line_data_t plan_data;
 514:grbl/protocol.c ****     plan_line_data_t *pl_data = &plan_data;
 515:grbl/protocol.c ****     memset(pl_data,0,sizeof(plan_line_data_t));
 516:grbl/protocol.c ****     pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
 517:grbl/protocol.c ****     #ifdef USE_LINE_NUMBERS
 518:grbl/protocol.c ****       pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
 519:grbl/protocol.c ****     #endif
 520:grbl/protocol.c ****   #endif
 521:grbl/protocol.c **** 
 522:grbl/protocol.c ****   plan_block_t *block = plan_get_current_block();
 811              		.loc 1 522 0
 812 0006 FFF7FEFF 		bl	plan_get_current_block
 813              	.LVL75:
 523:grbl/protocol.c ****   uint8_t restore_condition;
 524:grbl/protocol.c ****   #ifdef VARIABLE_SPINDLE
 525:grbl/protocol.c ****     float restore_spindle_speed;
 526:grbl/protocol.c ****     if (block == NULL) {
 814              		.loc 1 526 0
 815 000a 0028     		cmp	r0, #0
 816 000c 00F07882 		beq	.L443
 527:grbl/protocol.c ****       restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
 528:grbl/protocol.c ****       restore_spindle_speed = gc_state.spindle_speed;
 529:grbl/protocol.c ****     } else {
 530:grbl/protocol.c ****       restore_condition = block->condition;
 817              		.loc 1 530 0
 818 0010 467C     		ldrb	r6, [r0, #17]	@ zero_extendqisi2
 819              	.LVL76:
 531:grbl/protocol.c ****       restore_spindle_speed = block->spindle_speed;
 820              		.loc 1 531 0
 821 0012 D0F83080 		ldr	r8, [r0, #48]	@ float
 822              	.LVL77:
 823              	.L202:
 532:grbl/protocol.c ****     }
 533:grbl/protocol.c ****     #ifdef DISABLE_LASER_DURING_HOLD
 534:grbl/protocol.c ****       if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
 824              		.loc 1 534 0
 825 0016 BE4D     		ldr	r5, .L468
 826 0018 95F84830 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 827 001c 9807     		lsls	r0, r3, #30
 828              	.LVL78:
 829 001e 00F16B82 		bmi	.L444
 830              	.L203:
 535:grbl/protocol.c ****         system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 27


 536:grbl/protocol.c ****       }
 537:grbl/protocol.c ****     #endif
 538:grbl/protocol.c ****   #else
 539:grbl/protocol.c ****     if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
 540:grbl/protocol.c ****     else { restore_condition = block->condition; }
 541:grbl/protocol.c ****   #endif
 542:grbl/protocol.c **** 
 543:grbl/protocol.c ****   while (sys.suspend) {
 544:grbl/protocol.c **** 
 545:grbl/protocol.c ****     if (sys.abort) { return; }
 546:grbl/protocol.c **** 
 547:grbl/protocol.c ****     // Block until initial hold is complete and the machine has stopped motion.
 548:grbl/protocol.c ****     if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
 549:grbl/protocol.c **** 
 550:grbl/protocol.c ****       // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
 551:grbl/protocol.c ****       // the safety door and sleep states.
 552:grbl/protocol.c ****       if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
 553:grbl/protocol.c ****       
 554:grbl/protocol.c ****         // Handles retraction motions and de-energizing.
 555:grbl/protocol.c ****         if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
 556:grbl/protocol.c **** 
 557:grbl/protocol.c ****           // Ensure any prior spindle stop override is disabled at start of safety door routine.
 558:grbl/protocol.c ****           sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
 559:grbl/protocol.c **** 
 560:grbl/protocol.c ****           #ifndef PARKING_ENABLE
 561:grbl/protocol.c **** 
 562:grbl/protocol.c ****             spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 563:grbl/protocol.c ****             coolant_set_state(COOLANT_DISABLE);     // De-energize
 564:grbl/protocol.c **** 
 565:grbl/protocol.c ****           #else
 566:grbl/protocol.c **** 					
 567:grbl/protocol.c ****             // Get current position and store restore location and spindle retract waypoint.
 568:grbl/protocol.c ****             system_convert_array_steps_to_mpos(parking_target,sys_position);
 569:grbl/protocol.c ****             if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 570:grbl/protocol.c ****               memcpy(restore_target,parking_target,sizeof(parking_target));
 571:grbl/protocol.c ****               retract_waypoint += restore_target[PARKING_AXIS];
 572:grbl/protocol.c ****               retract_waypoint = min(retract_waypoint,PARKING_TARGET);
 573:grbl/protocol.c ****             }
 574:grbl/protocol.c **** 
 575:grbl/protocol.c ****             // Execute slow pull-out parking retract motion. Parking requires homing enabled, the
 576:grbl/protocol.c ****             // current location not exceeding the parking target location, and laser mode disabled.
 577:grbl/protocol.c ****             // NOTE: State is will remain DOOR, until the de-energizing and retract is complete.
 578:grbl/protocol.c ****             #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
 579:grbl/protocol.c ****             if ((bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) &&
 580:grbl/protocol.c ****                             (parking_target[PARKING_AXIS] < PARKING_TARGET) &&
 581:grbl/protocol.c ****                             bit_isfalse(settings.flags,BITFLAG_LASER_MODE) &&
 582:grbl/protocol.c ****                             (sys.override_ctrl == OVERRIDE_PARKING_MOTION)) {
 583:grbl/protocol.c ****             #else
 584:grbl/protocol.c ****             if ((bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) &&
 585:grbl/protocol.c ****                             (parking_target[PARKING_AXIS] < PARKING_TARGET) &&
 586:grbl/protocol.c ****                             bit_isfalse(settings.flags,BITFLAG_LASER_MODE)) {
 587:grbl/protocol.c ****             #endif
 588:grbl/protocol.c ****               // Retract spindle by pullout distance. Ensure retraction motion moves away from
 589:grbl/protocol.c ****               // the workpiece and waypoint motion doesn't exceed the parking target location.
 590:grbl/protocol.c ****               if (parking_target[PARKING_AXIS] < retract_waypoint) {
 591:grbl/protocol.c ****                 parking_target[PARKING_AXIS] = retract_waypoint;
 592:grbl/protocol.c ****                 pl_data->feed_rate = PARKING_PULLOUT_RATE;
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 28


 593:grbl/protocol.c ****                 pl_data->condition |= (restore_condition & PL_COND_ACCESSORY_MASK); // Retain acces
 594:grbl/protocol.c ****                 pl_data->spindle_speed = restore_spindle_speed;
 595:grbl/protocol.c ****                 mc_parking_motion(parking_target, pl_data);
 596:grbl/protocol.c ****               }
 597:grbl/protocol.c **** 
 598:grbl/protocol.c ****               // NOTE: Clear accessory state after retract and after an aborted restore motion.
 599:grbl/protocol.c ****               pl_data->condition = (PL_COND_FLAG_SYSTEM_MOTION|PL_COND_FLAG_NO_FEED_OVERRIDE);
 600:grbl/protocol.c ****               pl_data->spindle_speed = 0.0;
 601:grbl/protocol.c ****               spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 602:grbl/protocol.c ****               coolant_set_state(COOLANT_DISABLE); // De-energize
 603:grbl/protocol.c **** 
 604:grbl/protocol.c ****               // Execute fast parking retract motion to parking target location.
 605:grbl/protocol.c ****               if (parking_target[PARKING_AXIS] < PARKING_TARGET) {
 606:grbl/protocol.c ****                 parking_target[PARKING_AXIS] = PARKING_TARGET;
 607:grbl/protocol.c ****                 pl_data->feed_rate = PARKING_RATE;
 608:grbl/protocol.c ****                 mc_parking_motion(parking_target, pl_data);
 609:grbl/protocol.c ****               }
 610:grbl/protocol.c **** 
 611:grbl/protocol.c ****             } else {
 612:grbl/protocol.c **** 
 613:grbl/protocol.c ****               // Parking motion not possible. Just disable the spindle and coolant.
 614:grbl/protocol.c ****               // NOTE: Laser mode does not start a parking motion to ensure the laser stops immedia
 615:grbl/protocol.c ****               spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 616:grbl/protocol.c ****               coolant_set_state(COOLANT_DISABLE);     // De-energize
 617:grbl/protocol.c **** 
 618:grbl/protocol.c ****             }
 619:grbl/protocol.c **** 
 620:grbl/protocol.c ****           #endif
 621:grbl/protocol.c **** 
 622:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
 623:grbl/protocol.c ****           sys.suspend |= SUSPEND_RETRACT_COMPLETE;
 624:grbl/protocol.c **** 
 625:grbl/protocol.c ****         } else {
 626:grbl/protocol.c **** 
 627:grbl/protocol.c ****           
 628:grbl/protocol.c ****           if (sys.state == STATE_SLEEP) {
 629:grbl/protocol.c ****             report_feedback_message(MESSAGE_SLEEP_MODE);
 630:grbl/protocol.c ****             // Spindle and coolant should already be stopped, but do it again just to be sure.
 631:grbl/protocol.c ****             spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 632:grbl/protocol.c ****             coolant_set_state(COOLANT_DISABLE); // De-energize
 633:grbl/protocol.c ****             st_go_idle(); // Disable steppers
 634:grbl/protocol.c ****             while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
 635:grbl/protocol.c ****             return; // Abort received. Return to re-initialize.
 636:grbl/protocol.c ****           }    
 637:grbl/protocol.c ****           
 638:grbl/protocol.c ****           // Allows resuming from parking/safety door. Actively checks if safety door is closed and
 639:grbl/protocol.c ****           if (sys.state == STATE_SAFETY_DOOR) {
 640:grbl/protocol.c ****             if (!(system_check_safety_door_ajar())) {
 641:grbl/protocol.c ****               sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready t
 642:grbl/protocol.c ****             }
 643:grbl/protocol.c ****           }
 644:grbl/protocol.c **** 
 645:grbl/protocol.c ****           // Handles parking restore and safety door resume.
 646:grbl/protocol.c ****           if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
 647:grbl/protocol.c **** 
 648:grbl/protocol.c ****             #ifdef PARKING_ENABLE
 649:grbl/protocol.c ****               // Execute fast restore motion to the pull-out position. Parking requires homing enab
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 29


 650:grbl/protocol.c ****               // NOTE: State is will remain DOOR, until the de-energizing and retract is complete.
 651:grbl/protocol.c ****               #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
 652:grbl/protocol.c ****               if (((settings.flags & (BITFLAG_HOMING_ENABLE|BITFLAG_LASER_MODE)) == BITFLAG_HOMING_
 653:grbl/protocol.c ****                    (sys.override_ctrl == OVERRIDE_PARKING_MOTION)) {
 654:grbl/protocol.c ****               #else
 655:grbl/protocol.c ****               if ((settings.flags & (BITFLAG_HOMING_ENABLE|BITFLAG_LASER_MODE)) == BITFLAG_HOMING_E
 656:grbl/protocol.c ****               #endif
 657:grbl/protocol.c ****                 // Check to ensure the motion doesn't move below pull-out position.
 658:grbl/protocol.c ****                 if (parking_target[PARKING_AXIS] <= PARKING_TARGET) {
 659:grbl/protocol.c ****                   parking_target[PARKING_AXIS] = retract_waypoint;
 660:grbl/protocol.c ****                   pl_data->feed_rate = PARKING_RATE;
 661:grbl/protocol.c ****                   mc_parking_motion(parking_target, pl_data);
 662:grbl/protocol.c ****                 }
 663:grbl/protocol.c ****               }
 664:grbl/protocol.c ****             #endif
 665:grbl/protocol.c **** 
 666:grbl/protocol.c ****             // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
 667:grbl/protocol.c ****             if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 668:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 669:grbl/protocol.c ****               if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 670:grbl/protocol.c ****                 if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 671:grbl/protocol.c ****                   // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cy
 672:grbl/protocol.c ****                   bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 673:grbl/protocol.c ****                 } else {
 674:grbl/protocol.c ****                   spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SP
 675:grbl/protocol.c ****                   delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
 676:grbl/protocol.c ****                 }
 677:grbl/protocol.c ****               }
 678:grbl/protocol.c ****             }
 679:grbl/protocol.c ****             if (gc_state.modal.coolant != COOLANT_DISABLE) {
 680:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 681:grbl/protocol.c ****               if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 682:grbl/protocol.c ****                 // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by
 683:grbl/protocol.c ****                 coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_C
 684:grbl/protocol.c ****                 delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
 685:grbl/protocol.c ****               }
 686:grbl/protocol.c ****             }
 687:grbl/protocol.c **** 
 688:grbl/protocol.c ****             #ifdef PARKING_ENABLE
 689:grbl/protocol.c ****               // Execute slow plunge motion from pull-out position to resume position.
 690:grbl/protocol.c ****               #ifdef ENABLE_PARKING_OVERRIDE_CONTROL
 691:grbl/protocol.c ****               if (((settings.flags & (BITFLAG_HOMING_ENABLE|BITFLAG_LASER_MODE)) == BITFLAG_HOMING_
 692:grbl/protocol.c ****                    (sys.override_ctrl == OVERRIDE_PARKING_MOTION)) {
 693:grbl/protocol.c ****               #else
 694:grbl/protocol.c ****               if ((settings.flags & (BITFLAG_HOMING_ENABLE|BITFLAG_LASER_MODE)) == BITFLAG_HOMING_E
 695:grbl/protocol.c ****               #endif
 696:grbl/protocol.c ****                 // Block if safety door re-opened during prior restore actions.
 697:grbl/protocol.c ****                 if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 698:grbl/protocol.c ****                   // Regardless if the retract parking motion was a valid/safe motion or not, the
 699:grbl/protocol.c ****                   // restore parking motion should logically be valid, either by returning to the
 700:grbl/protocol.c ****                   // original position through valid machine space or by not moving at all.
 701:grbl/protocol.c ****                   pl_data->feed_rate = PARKING_PULLOUT_RATE;
 702:grbl/protocol.c **** 									pl_data->condition |= (restore_condition & PL_COND_ACCESSORY_MASK); // Restore accessory s
 703:grbl/protocol.c **** 									pl_data->spindle_speed = restore_spindle_speed;
 704:grbl/protocol.c ****                   mc_parking_motion(restore_target, pl_data);
 705:grbl/protocol.c ****                 }
 706:grbl/protocol.c ****               }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 30


 707:grbl/protocol.c ****             #endif
 708:grbl/protocol.c **** 
 709:grbl/protocol.c ****             if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
 710:grbl/protocol.c ****               sys.suspend |= SUSPEND_RESTORE_COMPLETE;
 711:grbl/protocol.c ****               system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
 712:grbl/protocol.c ****             }
 713:grbl/protocol.c ****           }
 714:grbl/protocol.c **** 
 715:grbl/protocol.c ****         }
 716:grbl/protocol.c **** 
 717:grbl/protocol.c **** 
 718:grbl/protocol.c ****       } else {
 719:grbl/protocol.c **** 
 720:grbl/protocol.c ****         // Feed hold manager. Controls spindle stop override states.
 721:grbl/protocol.c ****         // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
 722:grbl/protocol.c ****         if (sys.spindle_stop_ovr) {
 723:grbl/protocol.c ****           // Handles beginning of spindle stop
 724:grbl/protocol.c ****           if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
 725:grbl/protocol.c ****             if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 726:grbl/protocol.c ****               spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 831              		.loc 1 726 0
 832 0022 0027     		movs	r7, #0
 833 0024 BB4C     		ldr	r4, .L468+4
 834              	.L204:
 543:grbl/protocol.c **** 
 835              		.loc 1 543 0
 836 0026 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 837 0028 002B     		cmp	r3, #0
 838 002a 00F0D780 		beq	.L200
 839              	.L301:
 545:grbl/protocol.c **** 
 840              		.loc 1 545 0
 841 002e 6278     		ldrb	r2, [r4, #1]	@ zero_extendqisi2
 842 0030 002A     		cmp	r2, #0
 843 0032 40F0D380 		bne	.L200
 548:grbl/protocol.c **** 
 844              		.loc 1 548 0
 845 0036 D907     		lsls	r1, r3, #31
 846 0038 39D5     		bpl	.L207
 552:grbl/protocol.c ****       
 847              		.loc 1 552 0
 848 003a 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 849 003c 11F0C000 		ands	r0, r1, #192
 850 0040 00F0FC80 		beq	.L208
 555:grbl/protocol.c **** 
 851              		.loc 1 555 0
 852 0044 13F0040B 		ands	fp, r3, #4
 853 0048 00F0C181 		beq	.L445
 628:grbl/protocol.c ****             report_feedback_message(MESSAGE_SLEEP_MODE);
 854              		.loc 1 628 0
 855 004c 8029     		cmp	r1, #128
 856 004e 00F0C982 		beq	.L446
 639:grbl/protocol.c ****             if (!(system_check_safety_door_ajar())) {
 857              		.loc 1 639 0
 858 0052 4029     		cmp	r1, #64
 859 0054 00F04682 		beq	.L447
 860              	.L213:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 31


 646:grbl/protocol.c **** 
 861              		.loc 1 646 0
 862 0058 1807     		lsls	r0, r3, #28
 863 005a 28D5     		bpl	.L207
 667:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 864              		.loc 1 667 0
 865 005c DFF8C4A2 		ldr	r10, .L468+20
 866 0060 03F00201 		and	r1, r3, #2
 867 0064 9AF80900 		ldrb	r0, [r10, #9]	@ zero_extendqisi2
 868 0068 0028     		cmp	r0, #0
 869 006a 00F0C780 		beq	.L216
 669:grbl/protocol.c ****                 if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 870              		.loc 1 669 0
 871 006e F1B9     		cbnz	r1, .L207
 670:grbl/protocol.c ****                   // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cy
 872              		.loc 1 670 0
 873 0070 95F84810 		ldrb	r1, [r5, #72]	@ zero_extendqisi2
 874 0074 8907     		lsls	r1, r1, #30
 875 0076 40F1B480 		bpl	.L217
 672:grbl/protocol.c ****                 } else {
 876              		.loc 1 672 0
 877 007a 2179     		ldrb	r1, [r4, #4]	@ zero_extendqisi2
 679:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 878              		.loc 1 679 0
 879 007c 9AF80800 		ldrb	r0, [r10, #8]	@ zero_extendqisi2
 672:grbl/protocol.c ****                 } else {
 880              		.loc 1 672 0
 881 0080 41F00802 		orr	r2, r1, #8
 882 0084 2271     		strb	r2, [r4, #4]
 679:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 883              		.loc 1 679 0
 884 0086 60B1     		cbz	r0, .L218
 885              	.L220:
 683:grbl/protocol.c ****                 delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
 886              		.loc 1 683 0
 887 0088 06F04000 		and	r0, r6, #64
 888 008c FFF7FEFF 		bl	coolant_set_state
 889              	.LVL79:
 684:grbl/protocol.c ****               }
 890              		.loc 1 684 0
 891 0090 0121     		movs	r1, #1
 892 0092 4FF07E50 		mov	r0, #1065353216
 893 0096 FFF7FEFF 		bl	delay_sec
 894              	.LVL80:
 895 009a A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 896 009c 03F00201 		and	r1, r3, #2
 897              	.L219:
 709:grbl/protocol.c ****               sys.suspend |= SUSPEND_RESTORE_COMPLETE;
 898              		.loc 1 709 0
 899 00a0 29B9     		cbnz	r1, .L207
 900              	.L218:
 710:grbl/protocol.c ****               system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
 901              		.loc 1 710 0
 902 00a2 43F01003 		orr	r3, r3, #16
 711:grbl/protocol.c ****             }
 903              		.loc 1 711 0
 904 00a6 0220     		movs	r0, #2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 32


 710:grbl/protocol.c ****               system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
 905              		.loc 1 710 0
 906 00a8 A370     		strb	r3, [r4, #2]
 711:grbl/protocol.c ****             }
 907              		.loc 1 711 0
 908 00aa FFF7FEFF 		bl	system_set_exec_state_flag
 909              	.LVL81:
 910              	.L207:
 911              	.LBB24:
 912              	.LBB25:
 218:grbl/protocol.c ****   if (rt_exec) { // Enter only if any bit flag is true
 913              		.loc 1 218 0
 914 00ae 9A4B     		ldr	r3, .L468+8
 915 00b0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 916              	.LVL82:
 219:grbl/protocol.c ****     // System alarm. Everything has shutdown by something that has gone severely wrong. Report
 917              		.loc 1 219 0
 918 00b2 03F0FF0B 		and	fp, r3, #255
 919 00b6 002B     		cmp	r3, #0
 920 00b8 40F0AF80 		bne	.L437
 921              	.L459:
 922 00bc DFF868B2 		ldr	fp, .L468+24
 923              	.LVL83:
 924              	.L226:
 240:grbl/protocol.c ****   if (rt_exec) {
 925              		.loc 1 240 0
 926 00c0 9BF80030 		ldrb	r3, [fp]	@ zero_extendqisi2
 927              	.LVL84:
 241:grbl/protocol.c **** 
 928              		.loc 1 241 0
 929 00c4 03F0FF0B 		and	fp, r3, #255
 930 00c8 002B     		cmp	r3, #0
 931 00ca 6FD0     		beq	.L230
 244:grbl/protocol.c ****       sys.abort = true;  // Only place this is set true.
 932              		.loc 1 244 0
 933 00cc 1BF0100F 		tst	fp, #16
 934 00d0 40F06C81 		bne	.L448
 250:grbl/protocol.c ****       report_realtime_status();
 935              		.loc 1 250 0
 936 00d4 1BF0010F 		tst	fp, #1
 937 00d8 40F08981 		bne	.L449
 938              	.LVL85:
 939              	.L233:
 257:grbl/protocol.c **** 
 940              		.loc 1 257 0
 941 00dc 1BF0E80F 		tst	fp, #232
 942 00e0 28D0     		beq	.L234
 260:grbl/protocol.c ****       
 943              		.loc 1 260 0
 944 00e2 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 945 00e4 4FFA8BF2 		sxtb	r2, fp
 946 00e8 9907     		lsls	r1, r3, #30
 947 00ea 1DD1     		bne	.L236
 263:grbl/protocol.c ****           if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already
 948              		.loc 1 263 0
 949 00ec 13F0280F 		tst	r3, #40
 950 00f0 40F0B581 		bne	.L450
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 33


 951              	.L237:
 952 00f4 0BF04000 		and	r0, fp, #64
 953 00f8 0BF00801 		and	r1, fp, #8
 273:grbl/protocol.c **** 
 954              		.loc 1 273 0
 955 00fc 002B     		cmp	r3, #0
 956 00fe 40F0B781 		bne	.L240
 957 0102 4FF0010C 		mov	ip, #1
 958 0106 84F802C0 		strb	ip, [r4, #2]
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 959              		.loc 1 277 0
 960 010a 0028     		cmp	r0, #0
 961 010c 00F01F82 		beq	.L451
 962 0110 4120     		movs	r0, #65
 281:grbl/protocol.c ****         }
 963              		.loc 1 281 0
 964 0112 A070     		strb	r0, [r4, #2]
 965              	.L243:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 966              		.loc 1 285 0
 967 0114 21B1     		cbz	r1, .L245
 287:grbl/protocol.c ****         }
 968              		.loc 1 287 0
 969 0116 13F0E00F 		tst	r3, #224
 970 011a 01D1     		bne	.L245
 971              	.L302:
 972 011c 1023     		movs	r3, #16
 973 011e 2370     		strb	r3, [r4]
 974              	.L245:
 293:grbl/protocol.c ****           report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 975              		.loc 1 293 0
 976 0120 1BF0200F 		tst	fp, #32
 977 0124 40F00182 		bne	.L452
 978              	.L236:
 322:grbl/protocol.c ****         if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPL
 979              		.loc 1 322 0
 980 0128 002A     		cmp	r2, #0
 981 012a C0F2D181 		blt	.L453
 982              	.L251:
 327:grbl/protocol.c ****     }
 983              		.loc 1 327 0
 984 012e E820     		movs	r0, #232
 985 0130 FFF7FEFF 		bl	system_clear_exec_state_flag
 986              	.LVL86:
 987              	.L234:
 331:grbl/protocol.c ****       // Block if called at same time as the hold commands: feed hold, motion cancel, and safety do
 988              		.loc 1 331 0
 989 0134 1BF0020F 		tst	fp, #2
 990 0138 1FD0     		beq	.L253
 334:grbl/protocol.c ****         // Resume door state when parking motion has retracted and door has been closed.
 991              		.loc 1 334 0
 992 013a 1BF0680F 		tst	fp, #104
 993 013e 19D1     		bne	.L255
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 994              		.loc 1 336 0
 995 0140 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 996 0142 402B     		cmp	r3, #64
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 34


 997 0144 00F0E381 		beq	.L454
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 998              		.loc 1 349 0
 999 0148 002B     		cmp	r3, #0
 1000 014a 40F02C82 		bne	.L455
 1001              	.L259:
 354:grbl/protocol.c ****             if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 1002              		.loc 1 354 0
 1003 014e 0023     		movs	r3, #0
 1004 0150 2371     		strb	r3, [r4, #4]
 355:grbl/protocol.c ****               sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 1005              		.loc 1 355 0
 1006 0152 FFF7FEFF 		bl	plan_get_current_block
 1007              	.LVL87:
 1008 0156 0028     		cmp	r0, #0
 1009 0158 00F0A981 		beq	.L262
 1010 015c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1011 015e 13F04003 		ands	r3, r3, #64
 1012 0162 40F0A481 		bne	.L262
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 1013              		.loc 1 357 0
 1014 0166 0822     		movs	r2, #8
 356:grbl/protocol.c ****               sys.state = STATE_CYCLE;
 1015              		.loc 1 356 0
 1016 0168 A370     		strb	r3, [r4, #2]
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 1017              		.loc 1 357 0
 1018 016a 2270     		strb	r2, [r4]
 358:grbl/protocol.c ****               st_wake_up();
 1019              		.loc 1 358 0
 1020 016c FFF7FEFF 		bl	st_prep_buffer
 1021              	.LVL88:
 359:grbl/protocol.c ****             } else { // Otherwise, do nothing. Set and resume IDLE state.
 1022              		.loc 1 359 0
 1023 0170 FFF7FEFF 		bl	st_wake_up
 1024              	.LVL89:
 1025              	.L255:
 367:grbl/protocol.c ****     }
 1026              		.loc 1 367 0
 1027 0174 0220     		movs	r0, #2
 1028 0176 FFF7FEFF 		bl	system_clear_exec_state_flag
 1029              	.LVL90:
 1030              	.L253:
 370:grbl/protocol.c ****       // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
 1031              		.loc 1 370 0
 1032 017a 1BF0040F 		tst	fp, #4
 1033 017e 15D0     		beq	.L230
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 1034              		.loc 1 376 0
 1035 0180 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 1036 0182 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1037 0184 11F0D00F 		tst	r1, #208
 1038 0188 5AB2     		sxtb	r2, r3
 1039 018a 03D0     		beq	.L264
 1040 018c E178     		ldrb	r1, [r4, #3]	@ zero_extendqisi2
 1041 018e 0029     		cmp	r1, #0
 1042 0190 00F07981 		beq	.L456
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 35


 1043              	.L264:
 385:grbl/protocol.c ****           sys.step_control = STEP_CONTROL_NORMAL_OP;
 1044              		.loc 1 385 0
 1045 0194 002A     		cmp	r2, #0
 1046 0196 C0F27881 		blt	.L265
 1047              	.L268:
 392:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 1048              		.loc 1 392 0
 1049 019a 13F02002 		ands	r2, r3, #32
 1050 019e 40F04B81 		bne	.L457
 397:grbl/protocol.c ****           sys.state = STATE_IDLE;
 1051              		.loc 1 397 0
 1052 01a2 A270     		strb	r2, [r4, #2]
 398:grbl/protocol.c ****         }
 1053              		.loc 1 398 0
 1054 01a4 2270     		strb	r2, [r4]
 1055              	.L267:
 401:grbl/protocol.c ****     }
 1056              		.loc 1 401 0
 1057 01a6 0420     		movs	r0, #4
 1058 01a8 FFF7FEFF 		bl	system_clear_exec_state_flag
 1059              	.LVL91:
 1060              	.L230:
 406:grbl/protocol.c ****   if (rt_exec) {
 1061              		.loc 1 406 0
 1062 01ac 5B4B     		ldr	r3, .L468+12
 1063 01ae 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1064              	.LVL92:
 407:grbl/protocol.c ****     system_clear_exec_motion_overrides(); // Clear all motion override flags.
 1065              		.loc 1 407 0
 1066 01b0 03F0FF0B 		and	fp, r3, #255
 1067 01b4 002B     		cmp	r3, #0
 1068 01b6 40F0B980 		bne	.L458
 1069              	.LVL93:
 1070              	.L271:
 433:grbl/protocol.c ****   if (rt_exec) {
 1071              		.loc 1 433 0
 1072 01ba 594B     		ldr	r3, .L468+16
 1073 01bc 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1074              	.LVL94:
 434:grbl/protocol.c ****     system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 1075              		.loc 1 434 0
 1076 01be 03F0FF0B 		and	fp, r3, #255
 1077 01c2 002B     		cmp	r3, #0
 1078 01c4 49D1     		bne	.L282
 1079 01c6 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1080              	.LVL95:
 1081              	.L283:
 494:grbl/protocol.c ****     st_prep_buffer();
 1082              		.loc 1 494 0
 1083 01c8 13F0FC0F 		tst	r3, #252
 1084 01cc 3FF42BAF 		beq	.L204
 1085              	.L294:
 495:grbl/protocol.c ****   }
 1086              		.loc 1 495 0
 1087 01d0 FFF7FEFF 		bl	st_prep_buffer
 1088              	.LVL96:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 36


 1089              	.LBE25:
 1090              	.LBE24:
 543:grbl/protocol.c **** 
 1091              		.loc 1 543 0
 1092 01d4 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1093 01d6 002B     		cmp	r3, #0
 1094 01d8 7FF429AF 		bne	.L301
 1095              	.L200:
 727:grbl/protocol.c ****               sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enable
 728:grbl/protocol.c ****             } else {
 729:grbl/protocol.c ****               sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 730:grbl/protocol.c ****             }
 731:grbl/protocol.c ****           // Handles restoring of spindle state
 732:grbl/protocol.c ****           } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CY
 733:grbl/protocol.c ****             if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 734:grbl/protocol.c ****               report_feedback_message(MESSAGE_SPINDLE_RESTORE);
 735:grbl/protocol.c ****               if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 736:grbl/protocol.c ****                 // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycl
 737:grbl/protocol.c ****                 bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 738:grbl/protocol.c ****               } else {
 739:grbl/protocol.c ****                 spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPIN
 740:grbl/protocol.c ****               }
 741:grbl/protocol.c ****             }
 742:grbl/protocol.c ****             if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
 743:grbl/protocol.c ****               system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
 744:grbl/protocol.c ****             }
 745:grbl/protocol.c ****             sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
 746:grbl/protocol.c ****           }
 747:grbl/protocol.c ****         } else {
 748:grbl/protocol.c ****           // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during
 749:grbl/protocol.c ****           // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step gener
 750:grbl/protocol.c ****           if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
 751:grbl/protocol.c ****             spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_
 752:grbl/protocol.c ****             bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 753:grbl/protocol.c ****           }
 754:grbl/protocol.c ****         }
 755:grbl/protocol.c **** 
 756:grbl/protocol.c ****       }
 757:grbl/protocol.c ****     }
 758:grbl/protocol.c **** 
 759:grbl/protocol.c ****     protocol_exec_rt_system();
 760:grbl/protocol.c **** 
 761:grbl/protocol.c ****   }
 762:grbl/protocol.c **** }
 1096              		.loc 1 762 0
 1097 01dc 03B0     		add	sp, sp, #12
 1098              	.LCFI8:
 1099              		.cfi_remember_state
 1100              		.cfi_def_cfa_offset 36
 1101              		@ sp needed
 1102 01de BDE8F08F 		pop	{r4, r5, r6, r7, r8, r9, r10, fp, pc}
 1103              	.LVL97:
 1104              	.L217:
 1105              	.LCFI9:
 1106              		.cfi_restore_state
 674:grbl/protocol.c ****                   delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
 1107              		.loc 1 674 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 37


 1108 01e2 4146     		mov	r1, r8
 1109 01e4 06F03000 		and	r0, r6, #48
 1110 01e8 FFF7FEFF 		bl	spindle_set_state
 1111              	.LVL98:
 675:grbl/protocol.c ****                 }
 1112              		.loc 1 675 0
 1113 01ec 0121     		movs	r1, #1
 1114 01ee 4FF08140 		mov	r0, #1082130432
 1115 01f2 FFF7FEFF 		bl	delay_sec
 1116              	.LVL99:
 1117 01f6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1118 01f8 03F00201 		and	r1, r3, #2
 1119              	.L216:
 679:grbl/protocol.c ****               // Block if safety door re-opened during prior restore actions.
 1120              		.loc 1 679 0
 1121 01fc 9AF80820 		ldrb	r2, [r10, #8]	@ zero_extendqisi2
 1122 0200 002A     		cmp	r2, #0
 1123 0202 3FF44DAF 		beq	.L219
 681:grbl/protocol.c ****                 // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by
 1124              		.loc 1 681 0
 1125 0206 0029     		cmp	r1, #0
 1126 0208 3FF43EAF 		beq	.L220
 1127              	.LBB38:
 1128              	.LBB31:
 218:grbl/protocol.c ****   if (rt_exec) { // Enter only if any bit flag is true
 1129              		.loc 1 218 0
 1130 020c 424B     		ldr	r3, .L468+8
 1131 020e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1132              	.LVL100:
 219:grbl/protocol.c ****     // System alarm. Everything has shutdown by something that has gone severely wrong. Report
 1133              		.loc 1 219 0
 1134 0210 03F0FF0B 		and	fp, r3, #255
 1135 0214 002B     		cmp	r3, #0
 1136 0216 3FF451AF 		beq	.L459
 1137              	.L437:
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 1138              		.loc 1 223 0
 1139 021a 4FF00109 		mov	r9, #1
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 1140              		.loc 1 224 0
 1141 021e 5846     		mov	r0, fp
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 1142              		.loc 1 226 0
 1143 0220 0BF1FF3B 		add	fp, fp, #-1
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 1144              		.loc 1 223 0
 1145 0224 84F80090 		strb	r9, [r4]
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 1146              		.loc 1 224 0
 1147 0228 FFF7FEFF 		bl	report_alarm_message
 1148              	.LVL101:
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 1149              		.loc 1 226 0
 1150 022c CB45     		cmp	fp, r9
 1151 022e 40F2F680 		bls	.L438
 1152 0232 DFF8F4B0 		ldr	fp, .L468+24
 1153              	.L227:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 38


 237:grbl/protocol.c ****   }
 1154              		.loc 1 237 0
 1155 0236 FFF7FEFF 		bl	system_clear_exec_alarm
 1156              	.LVL102:
 1157 023a 41E7     		b	.L226
 1158              	.L208:
 1159              	.LBE31:
 1160              	.LBE38:
 722:grbl/protocol.c ****           // Handles beginning of spindle stop
 1161              		.loc 1 722 0
 1162 023c E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 1163 023e 002B     		cmp	r3, #0
 1164 0240 00F0B780 		beq	.L221
 724:grbl/protocol.c ****             if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 1165              		.loc 1 724 0
 1166 0244 9A07     		lsls	r2, r3, #30
 1167 0246 40F1D880 		bpl	.L222
 725:grbl/protocol.c ****               spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
 1168              		.loc 1 725 0
 1169 024a 364B     		ldr	r3, .L468+20
 1170 024c 5B7A     		ldrb	r3, [r3, #9]	@ zero_extendqisi2
 1171 024e 002B     		cmp	r3, #0
 1172 0250 40F02781 		bne	.L460
 1173              	.L223:
 729:grbl/protocol.c ****             }
 1174              		.loc 1 729 0
 1175 0254 0023     		movs	r3, #0
 1176 0256 E372     		strb	r3, [r4, #11]
 1177 0258 29E7     		b	.L207
 1178              	.LVL103:
 1179              	.L282:
 1180              	.LBB39:
 1181              	.LBB32:
 1182              	.LBB26:
 435:grbl/protocol.c **** 
 1183              		.loc 1 435 0
 1184 025a FFF7FEFF 		bl	system_clear_exec_accessory_overrides
 1185              	.LVL104:
 438:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 1186              		.loc 1 438 0
 1187 025e 1BF0010F 		tst	fp, #1
 1188 0262 18BF     		it	ne
 1189 0264 6423     		movne	r3, #100
 1190 0266 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
 1191              	.LVL105:
 1192 0268 08BF     		it	eq
 1193 026a 1346     		moveq	r3, r2
 1194              	.LVL106:
 440:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCRE
 1195              		.loc 1 440 0
 1196 026c 1BF0020F 		tst	fp, #2
 1197 0270 1CBF     		itt	ne
 1198 0272 0A33     		addne	r3, r3, #10
 1199              	.LVL107:
 1200 0274 DBB2     		uxtbne	r3, r3
 1201              	.LVL108:
 441:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 39


 1202              		.loc 1 441 0
 1203 0276 1BF0040F 		tst	fp, #4
 1204 027a 1CBF     		itt	ne
 1205 027c 0A3B     		subne	r3, r3, #10
 1206              	.LVL109:
 1207 027e DBB2     		uxtbne	r3, r3
 1208              	.LVL110:
 442:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT
 1209              		.loc 1 442 0
 1210 0280 1BF0080F 		tst	fp, #8
 1211 0284 1CBF     		itt	ne
 1212 0286 0133     		addne	r3, r3, #1
 1213              	.LVL111:
 1214 0288 DBB2     		uxtbne	r3, r3
 1215              	.LVL112:
 443:grbl/protocol.c ****     last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 1216              		.loc 1 443 0
 1217 028a 1BF0100F 		tst	fp, #16
 1218 028e 1CBF     		itt	ne
 1219 0290 03F1FF33 		addne	r3, r3, #-1
 1220              	.LVL113:
 1221 0294 DBB2     		uxtbne	r3, r3
 1222              	.LVL114:
 445:grbl/protocol.c **** 
 1223              		.loc 1 445 0
 1224 0296 C82B     		cmp	r3, #200
 1225 0298 28BF     		it	cs
 1226 029a C823     		movcs	r3, #200
 1227              	.LVL115:
 1228 029c 0A2B     		cmp	r3, #10
 1229 029e 38BF     		it	cc
 1230 02a0 0A23     		movcc	r3, #10
 1231              	.LVL116:
 447:grbl/protocol.c ****       bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 1232              		.loc 1 447 0
 1233 02a2 9A42     		cmp	r2, r3
 1234 02a4 06D0     		beq	.L289
 450:grbl/protocol.c ****     }
 1235              		.loc 1 450 0
 1236 02a6 0021     		movs	r1, #0
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 1237              		.loc 1 448 0
 1238 02a8 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 449:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 1239              		.loc 1 449 0
 1240 02aa A372     		strb	r3, [r4, #10]
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 1241              		.loc 1 448 0
 1242 02ac 42F00803 		orr	r3, r2, #8
 1243              	.LVL117:
 1244 02b0 2371     		strb	r3, [r4, #4]
 450:grbl/protocol.c ****     }
 1245              		.loc 1 450 0
 1246 02b2 2173     		strb	r1, [r4, #12]
 1247              	.LVL118:
 1248              	.L289:
 453:grbl/protocol.c ****       // Spindle stop override allowed only while in HOLD state.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 40


 1249              		.loc 1 453 0
 1250 02b4 1BF0200F 		tst	fp, #32
 1251 02b8 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1252 02ba 0BF0C002 		and	r2, fp, #192
 1253 02be 02D0     		beq	.L290
 456:grbl/protocol.c ****         if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 1254              		.loc 1 456 0
 1255 02c0 102B     		cmp	r3, #16
 1256 02c2 00F0C180 		beq	.L461
 1257              	.L290:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 1258              		.loc 1 464 0
 1259 02c6 002A     		cmp	r2, #0
 1260 02c8 3FF47EAF 		beq	.L283
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 1261              		.loc 1 465 0
 1262 02cc 002B     		cmp	r3, #0
 1263 02ce 40F0FA80 		bne	.L295
 1264              	.L293:
 1265              	.LBB27:
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 1266              		.loc 1 466 0
 1267 02d2 DFF850A0 		ldr	r10, .L468+20
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 1268              		.loc 1 468 0
 1269 02d6 1BF0800F 		tst	fp, #128
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 1270              		.loc 1 466 0
 1271 02da 9AF80890 		ldrb	r9, [r10, #8]	@ zero_extendqisi2
 1272              	.LVL119:
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 1273              		.loc 1 468 0
 1274 02de 06D0     		beq	.L297
 469:grbl/protocol.c ****             else { coolant_state |= COOLANT_MIST_ENABLE; }
 1275              		.loc 1 469 0
 1276 02e0 19F0800F 		tst	r9, #128
 1277 02e4 14BF     		ite	ne
 1278 02e6 09F07F09 		andne	r9, r9, #127
 1279              	.LVL120:
 470:grbl/protocol.c ****           }
 1280              		.loc 1 470 0
 1281 02ea 49F08009 		orreq	r9, r9, #128
 1282              	.LVL121:
 1283              	.L297:
 472:grbl/protocol.c ****             if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABL
 1284              		.loc 1 472 0
 1285 02ee 1BF0400F 		tst	fp, #64
 1286 02f2 06D0     		beq	.L299
 473:grbl/protocol.c ****             else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 1287              		.loc 1 473 0
 1288 02f4 19F0400F 		tst	r9, #64
 1289 02f8 14BF     		ite	ne
 1290 02fa 09F0BF09 		andne	r9, r9, #191
 1291              	.LVL122:
 474:grbl/protocol.c ****           }
 1292              		.loc 1 474 0
 1293 02fe 49F04009 		orreq	r9, r9, #64
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 41


 1294              	.LVL123:
 1295              	.L299:
 480:grbl/protocol.c ****         gc_state.modal.coolant = coolant_state;
 1296              		.loc 1 480 0
 1297 0302 4846     		mov	r0, r9
 1298 0304 FFF7FEFF 		bl	coolant_set_state
 1299              	.LVL124:
 1300 0308 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 481:grbl/protocol.c ****       }
 1301              		.loc 1 481 0
 1302 030a 8AF80890 		strb	r9, [r10, #8]
 1303 030e 5BE7     		b	.L283
 1304              	.L469:
 1305              		.align	2
 1306              	.L468:
 1307 0310 00000000 		.word	settings
 1308 0314 00000000 		.word	sys
 1309 0318 00000000 		.word	sys_rt_exec_alarm
 1310 031c 00000000 		.word	sys_rt_exec_motion_override
 1311 0320 00000000 		.word	sys_rt_exec_accessory_override
 1312 0324 00000000 		.word	gc_state
 1313 0328 00000000 		.word	sys_rt_exec_state
 1314              	.LVL125:
 1315              	.L458:
 1316              	.LBE27:
 1317              	.LBE26:
 1318              	.LBB28:
 408:grbl/protocol.c **** 
 1319              		.loc 1 408 0
 1320 032c FFF7FEFF 		bl	system_clear_exec_motion_overrides
 1321              	.LVL126:
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 1322              		.loc 1 410 0
 1323 0330 1BF0010F 		tst	fp, #1
 1324 0334 18BF     		it	ne
 1325 0336 6423     		movne	r3, #100
 1326 0338 227A     		ldrb	r2, [r4, #8]	@ zero_extendqisi2
 1327              	.LVL127:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 1328              		.loc 1 419 0
 1329 033a 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 1330              		.loc 1 410 0
 1331 033c 08BF     		it	eq
 1332 033e 1346     		moveq	r3, r2
 1333              	.LVL128:
 412:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 1334              		.loc 1 412 0
 1335 0340 1BF0020F 		tst	fp, #2
 1336 0344 1CBF     		itt	ne
 1337 0346 0A33     		addne	r3, r3, #10
 1338              	.LVL129:
 1339 0348 DBB2     		uxtbne	r3, r3
 1340              	.LVL130:
 413:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 1341              		.loc 1 413 0
 1342 034a 1BF0040F 		tst	fp, #4
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 42


 1343 034e 1CBF     		itt	ne
 1344 0350 0A3B     		subne	r3, r3, #10
 1345              	.LVL131:
 1346 0352 DBB2     		uxtbne	r3, r3
 1347              	.LVL132:
 414:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 1348              		.loc 1 414 0
 1349 0354 1BF0080F 		tst	fp, #8
 1350 0358 1CBF     		itt	ne
 1351 035a 0133     		addne	r3, r3, #1
 1352              	.LVL133:
 1353 035c DBB2     		uxtbne	r3, r3
 1354              	.LVL134:
 415:grbl/protocol.c ****     new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 1355              		.loc 1 415 0
 1356 035e 1BF0100F 		tst	fp, #16
 1357 0362 1CBF     		itt	ne
 1358 0364 03F1FF33 		addne	r3, r3, #-1
 1359              	.LVL135:
 1360 0368 DBB2     		uxtbne	r3, r3
 1361              	.LVL136:
 417:grbl/protocol.c **** 
 1362              		.loc 1 417 0
 1363 036a C82B     		cmp	r3, #200
 1364 036c 28BF     		it	cs
 1365 036e C823     		movcs	r3, #200
 1366              	.LVL137:
 1367 0370 0A2B     		cmp	r3, #10
 1368 0372 38BF     		it	cc
 1369 0374 0A23     		movcc	r3, #10
 1370              	.LVL138:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 1371              		.loc 1 419 0
 1372 0376 1BF0200F 		tst	fp, #32
 1373 037a 14BF     		ite	ne
 1374 037c 6421     		movne	r1, #100
 1375 037e 0146     		moveq	r1, r0
 1376              	.LVL139:
 421:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 1377              		.loc 1 421 0
 1378 0380 1BF0400F 		tst	fp, #64
 1379 0384 18BF     		it	ne
 1380 0386 3221     		movne	r1, #50
 1381              	.LVL140:
 422:grbl/protocol.c **** 
 1382              		.loc 1 422 0
 1383 0388 1BF0800F 		tst	fp, #128
 1384 038c 18BF     		it	ne
 1385 038e 1921     		movne	r1, #25
 1386              	.LVL141:
 424:grbl/protocol.c ****       sys.f_override = new_f_override;
 1387              		.loc 1 424 0
 1388 0390 9A42     		cmp	r2, r3
 1389 0392 02D1     		bne	.L280
 1390 0394 8842     		cmp	r0, r1
 1391 0396 3FF410AF 		beq	.L271
 1392              	.L280:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 43


 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 1393              		.loc 1 427 0
 1394 039a 0022     		movs	r2, #0
 425:grbl/protocol.c ****       sys.r_override = new_r_override;
 1395              		.loc 1 425 0
 1396 039c 2372     		strb	r3, [r4, #8]
 426:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 1397              		.loc 1 426 0
 1398 039e 6172     		strb	r1, [r4, #9]
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 1399              		.loc 1 427 0
 1400 03a0 2273     		strb	r2, [r4, #12]
 428:grbl/protocol.c ****       plan_cycle_reinitialize();
 1401              		.loc 1 428 0
 1402 03a2 FFF7FEFF 		bl	plan_update_velocity_profile_parameters
 1403              	.LVL142:
 429:grbl/protocol.c ****     }
 1404              		.loc 1 429 0
 1405 03a6 FFF7FEFF 		bl	plan_cycle_reinitialize
 1406              	.LVL143:
 1407 03aa 06E7     		b	.L271
 1408              	.LVL144:
 1409              	.L448:
 1410              	.LBE28:
 245:grbl/protocol.c ****       return; // Nothing else to do but exit.
 1411              		.loc 1 245 0
 1412 03ac 0123     		movs	r3, #1
 1413              	.LVL145:
 1414 03ae 6370     		strb	r3, [r4, #1]
 1415 03b0 39E6     		b	.L204
 1416              	.L221:
 1417              	.LBE32:
 1418              	.LBE39:
 750:grbl/protocol.c ****             spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_
 1419              		.loc 1 750 0
 1420 03b2 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1421 03b4 1B07     		lsls	r3, r3, #28
 1422 03b6 7FF57AAE 		bpl	.L207
 751:grbl/protocol.c ****             bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 1423              		.loc 1 751 0
 1424 03ba 4146     		mov	r1, r8
 1425 03bc 06F03000 		and	r0, r6, #48
 1426 03c0 FFF7FEFF 		bl	spindle_set_state
 1427              	.LVL146:
 752:grbl/protocol.c ****           }
 1428              		.loc 1 752 0
 1429 03c4 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1430 03c6 23F00803 		bic	r3, r3, #8
 1431 03ca 2371     		strb	r3, [r4, #4]
 1432 03cc 6FE6     		b	.L207
 1433              	.L445:
 562:grbl/protocol.c ****             coolant_set_state(COOLANT_DISABLE);     // De-energize
 1434              		.loc 1 562 0
 1435 03ce 3946     		mov	r1, r7
 1436 03d0 5846     		mov	r0, fp
 558:grbl/protocol.c **** 
 1437              		.loc 1 558 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 44


 1438 03d2 84F80BB0 		strb	fp, [r4, #11]
 562:grbl/protocol.c ****             coolant_set_state(COOLANT_DISABLE);     // De-energize
 1439              		.loc 1 562 0
 1440 03d6 FFF7FEFF 		bl	spindle_set_state
 1441              	.LVL147:
 563:grbl/protocol.c **** 
 1442              		.loc 1 563 0
 1443 03da 5846     		mov	r0, fp
 1444 03dc FFF7FEFF 		bl	coolant_set_state
 1445              	.LVL148:
 622:grbl/protocol.c ****           sys.suspend |= SUSPEND_RETRACT_COMPLETE;
 1446              		.loc 1 622 0
 1447 03e0 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1448 03e2 23F00203 		bic	r3, r3, #2
 623:grbl/protocol.c **** 
 1449              		.loc 1 623 0
 1450 03e6 43F00403 		orr	r3, r3, #4
 1451 03ea A370     		strb	r3, [r4, #2]
 1452 03ec 5FE6     		b	.L207
 1453              	.LVL149:
 1454              	.L449:
 1455              	.LBB40:
 1456              	.LBB33:
 251:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 1457              		.loc 1 251 0
 1458 03ee FFF7FEFF 		bl	report_realtime_status
 1459              	.LVL150:
 252:grbl/protocol.c ****     }
 1460              		.loc 1 252 0
 1461 03f2 0120     		movs	r0, #1
 1462 03f4 FFF7FEFF 		bl	system_clear_exec_state_flag
 1463              	.LVL151:
 1464 03f8 70E6     		b	.L233
 1465              	.L222:
 1466              	.LBE33:
 1467              	.LBE40:
 732:grbl/protocol.c ****             if (gc_state.modal.spindle != SPINDLE_DISABLE) {
 1468              		.loc 1 732 0
 1469 03fa 13F00C0F 		tst	r3, #12
 1470 03fe 3FF456AE 		beq	.L207
 733:grbl/protocol.c ****               report_feedback_message(MESSAGE_SPINDLE_RESTORE);
 1471              		.loc 1 733 0
 1472 0402 894A     		ldr	r2, .L470
 1473 0404 527A     		ldrb	r2, [r2, #9]	@ zero_extendqisi2
 1474 0406 002A     		cmp	r2, #0
 1475 0408 40F0DF80 		bne	.L462
 1476              	.L224:
 742:grbl/protocol.c ****               system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
 1477              		.loc 1 742 0
 1478 040c 1A07     		lsls	r2, r3, #28
 1479 040e 7FF521AF 		bpl	.L223
 743:grbl/protocol.c ****             }
 1480              		.loc 1 743 0
 1481 0412 0220     		movs	r0, #2
 1482 0414 FFF7FEFF 		bl	system_set_exec_state_flag
 1483              	.LVL152:
 729:grbl/protocol.c ****             }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 45


 1484              		.loc 1 729 0
 1485 0418 0023     		movs	r3, #0
 1486 041a E372     		strb	r3, [r4, #11]
 1487 041c 47E6     		b	.L207
 1488              	.L438:
 1489              	.LBB41:
 1490              	.LBB34:
 227:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 1491              		.loc 1 227 0
 1492 041e 4846     		mov	r0, r9
 1493 0420 FFF7FEFF 		bl	report_feedback_message
 1494              	.LVL153:
 228:grbl/protocol.c ****       do {
 1495              		.loc 1 228 0
 1496 0424 1020     		movs	r0, #16
 1497 0426 FFF7FEFF 		bl	system_clear_exec_state_flag
 1498              	.LVL154:
 1499 042a DFF800B2 		ldr	fp, .L470+4
 1500              	.L228:
 235:grbl/protocol.c ****     }
 1501              		.loc 1 235 0
 1502 042e 9BF80030 		ldrb	r3, [fp]	@ zero_extendqisi2
 1503 0432 D806     		lsls	r0, r3, #27
 1504 0434 FBD5     		bpl	.L228
 1505 0436 FEE6     		b	.L227
 1506              	.L457:
 395:grbl/protocol.c ****         } else {
 1507              		.loc 1 395 0
 1508 0438 4022     		movs	r2, #64
 393:grbl/protocol.c ****           sys.suspend |= SUSPEND_HOLD_COMPLETE;
 1509              		.loc 1 393 0
 1510 043a 03F07F03 		and	r3, r3, #127
 394:grbl/protocol.c ****           sys.state = STATE_SAFETY_DOOR;
 1511              		.loc 1 394 0
 1512 043e 43F00103 		orr	r3, r3, #1
 1513 0442 A370     		strb	r3, [r4, #2]
 395:grbl/protocol.c ****         } else {
 1514              		.loc 1 395 0
 1515 0444 2270     		strb	r2, [r4]
 1516 0446 AEE6     		b	.L267
 1517              	.L461:
 1518              	.LBB29:
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 1519              		.loc 1 457 0
 1520 0448 E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 1521 044a B9B3     		cbz	r1, .L463
 458:grbl/protocol.c ****       }
 1522              		.loc 1 458 0
 1523 044c C807     		lsls	r0, r1, #31
 1524 044e 37D5     		bpl	.L292
 1525 0450 41F00401 		orr	r1, r1, #4
 1526 0454 E172     		strb	r1, [r4, #11]
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 1527              		.loc 1 464 0
 1528 0456 002A     		cmp	r2, #0
 1529 0458 7FF43BAF 		bne	.L293
 1530 045c B8E6     		b	.L294
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 46


 1531              	.L450:
 1532              	.LBE29:
 264:grbl/protocol.c ****             st_update_plan_block_parameters(); // Notify stepper module to recompute for hold decel
 1533              		.loc 1 264 0
 1534 045e A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 1535 0460 11F0C00F 		tst	r1, #192
 1536 0464 00F08480 		beq	.L464
 1537 0468 0BF04000 		and	r0, fp, #64
 1538 046c 0BF00801 		and	r1, fp, #8
 1539              	.L240:
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 1540              		.loc 1 277 0
 1541 0470 0028     		cmp	r0, #0
 1542 0472 3FF44FAE 		beq	.L243
 281:grbl/protocol.c ****         }
 1543              		.loc 1 281 0
 1544 0476 9806     		lsls	r0, r3, #26
 1545 0478 3FF54CAE 		bmi	.L243
 1546 047c A078     		ldrb	r0, [r4, #2]	@ zero_extendqisi2
 1547 047e 40F04000 		orr	r0, r0, #64
 1548 0482 A070     		strb	r0, [r4, #2]
 1549 0484 46E6     		b	.L243
 1550              	.L456:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 1551              		.loc 1 376 0
 1552 0486 002A     		cmp	r2, #0
 1553 0488 65DA     		bge	.L465
 1554              	.L265:
 386:grbl/protocol.c ****           plan_reset();
 1555              		.loc 1 386 0
 1556 048a 0023     		movs	r3, #0
 1557 048c 2371     		strb	r3, [r4, #4]
 387:grbl/protocol.c ****           st_reset();
 1558              		.loc 1 387 0
 1559 048e FFF7FEFF 		bl	plan_reset
 1560              	.LVL155:
 388:grbl/protocol.c ****           gc_sync_position();
 1561              		.loc 1 388 0
 1562 0492 FFF7FEFF 		bl	st_reset
 1563              	.LVL156:
 389:grbl/protocol.c ****           plan_sync_position();
 1564              		.loc 1 389 0
 1565 0496 FFF7FEFF 		bl	gc_sync_position
 1566              	.LVL157:
 390:grbl/protocol.c ****         }
 1567              		.loc 1 390 0
 1568 049a FFF7FEFF 		bl	plan_sync_position
 1569              	.LVL158:
 1570 049e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1571 04a0 7BE6     		b	.L268
 1572              	.L460:
 1573              	.LBE34:
 1574              	.LBE41:
 726:grbl/protocol.c ****               sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enable
 1575              		.loc 1 726 0
 1576 04a2 3946     		mov	r1, r7
 1577 04a4 FFF7FEFF 		bl	spindle_set_state
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 47


 1578              	.LVL159:
 727:grbl/protocol.c ****             } else {
 1579              		.loc 1 727 0
 1580 04a8 0123     		movs	r3, #1
 1581 04aa E372     		strb	r3, [r4, #11]
 1582 04ac FFE5     		b	.L207
 1583              	.L262:
 1584              	.LBB42:
 1585              	.LBB35:
 361:grbl/protocol.c ****               sys.state = STATE_IDLE;
 1586              		.loc 1 361 0
 1587 04ae 0023     		movs	r3, #0
 367:grbl/protocol.c ****     }
 1588              		.loc 1 367 0
 1589 04b0 0220     		movs	r0, #2
 361:grbl/protocol.c ****               sys.state = STATE_IDLE;
 1590              		.loc 1 361 0
 1591 04b2 A370     		strb	r3, [r4, #2]
 362:grbl/protocol.c ****             }
 1592              		.loc 1 362 0
 1593 04b4 2370     		strb	r3, [r4]
 367:grbl/protocol.c ****     }
 1594              		.loc 1 367 0
 1595 04b6 FFF7FEFF 		bl	system_clear_exec_state_flag
 1596              	.LVL160:
 1597 04ba 5EE6     		b	.L253
 1598              	.L463:
 1599              	.LBB30:
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 1600              		.loc 1 457 0
 1601 04bc 0221     		movs	r1, #2
 1602 04be E172     		strb	r1, [r4, #11]
 1603              	.L292:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 1604              		.loc 1 464 0
 1605 04c0 002A     		cmp	r2, #0
 1606 04c2 3FF485AE 		beq	.L294
 1607              	.L295:
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 1608              		.loc 1 465 0
 1609 04c6 13F0180F 		tst	r3, #24
 1610 04ca 3FF47DAE 		beq	.L283
 1611 04ce 00E7     		b	.L293
 1612              	.L453:
 1613              	.LBE30:
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 1614              		.loc 1 323 0
 1615 04d0 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1616 04d2 012B     		cmp	r3, #1
 1617 04d4 03D1     		bne	.L252
 1618 04d6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1619 04d8 43F00503 		orr	r3, r3, #5
 1620 04dc A370     		strb	r3, [r4, #2]
 1621              	.L252:
 324:grbl/protocol.c ****       }
 1622              		.loc 1 324 0
 1623 04de 8023     		movs	r3, #128
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 48


 1624 04e0 2370     		strb	r3, [r4]
 1625 04e2 24E6     		b	.L251
 1626              	.L447:
 1627              	.LBE35:
 1628              	.LBE42:
 640:grbl/protocol.c ****               sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready t
 1629              		.loc 1 640 0
 1630 04e4 FFF7FEFF 		bl	system_check_safety_door_ajar
 1631              	.LVL161:
 641:grbl/protocol.c ****             }
 1632              		.loc 1 641 0
 1633 04e8 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 640:grbl/protocol.c ****               sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready t
 1634              		.loc 1 640 0
 1635 04ea 0028     		cmp	r0, #0
 1636 04ec 7FF4B4AD 		bne	.L213
 641:grbl/protocol.c ****             }
 1637              		.loc 1 641 0
 1638 04f0 03F0DF03 		and	r3, r3, #223
 1639 04f4 A370     		strb	r3, [r4, #2]
 1640 04f6 AFE5     		b	.L213
 1641              	.L444:
 535:grbl/protocol.c ****       }
 1642              		.loc 1 535 0
 1643 04f8 2020     		movs	r0, #32
 1644 04fa FFF7FEFF 		bl	system_set_exec_accessory_override_flag
 1645              	.LVL162:
 1646 04fe 90E5     		b	.L203
 1647              	.LVL163:
 1648              	.L443:
 527:grbl/protocol.c ****       restore_spindle_speed = gc_state.spindle_speed;
 1649              		.loc 1 527 0
 1650 0500 494B     		ldr	r3, .L470
 1651 0502 5E7A     		ldrb	r6, [r3, #9]	@ zero_extendqisi2
 1652 0504 1A7A     		ldrb	r2, [r3, #8]	@ zero_extendqisi2
 528:grbl/protocol.c ****     } else {
 1653              		.loc 1 528 0
 1654 0506 D3F81080 		ldr	r8, [r3, #16]	@ float
 527:grbl/protocol.c ****       restore_spindle_speed = gc_state.spindle_speed;
 1655              		.loc 1 527 0
 1656 050a 1643     		orrs	r6, r6, r2
 1657              	.LVL164:
 1658 050c 83E5     		b	.L202
 1659              	.LVL165:
 1660              	.L454:
 1661              	.LBB43:
 1662              	.LBB36:
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 1663              		.loc 1 336 0
 1664 050e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1665 0510 13F02002 		ands	r2, r3, #32
 1666 0514 7FF42EAE 		bne	.L255
 337:grbl/protocol.c ****             sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 1667              		.loc 1 337 0
 1668 0518 D906     		lsls	r1, r3, #27
 1669 051a 7CD4     		bmi	.L466
 339:grbl/protocol.c ****             // Flag to re-energize powered components and restore original position, if disabled by
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 49


 1670              		.loc 1 339 0
 1671 051c 5807     		lsls	r0, r3, #29
 1672 051e 7FF529AE 		bpl	.L255
 345:grbl/protocol.c ****           }
 1673              		.loc 1 345 0
 1674 0522 43F00803 		orr	r3, r3, #8
 1675 0526 A370     		strb	r3, [r4, #2]
 1676 0528 24E6     		b	.L255
 1677              	.L452:
 294:grbl/protocol.c ****           // If jogging, block safety door methods until jog cancel is complete. Just flag that it 
 1678              		.loc 1 294 0
 1679 052a 0620     		movs	r0, #6
 1680 052c 0192     		str	r2, [sp, #4]
 1681 052e FFF7FEFF 		bl	report_feedback_message
 1682              	.LVL166:
 296:grbl/protocol.c ****             // Check if the safety re-opened during a restore parking motion only. Ignore if
 1683              		.loc 1 296 0
 1684 0532 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1685 0534 019A     		ldr	r2, [sp, #4]
 1686 0536 13F0800F 		tst	r3, #128
 1687 053a 04D1     		bne	.L248
 299:grbl/protocol.c ****               if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 1688              		.loc 1 299 0
 1689 053c 2178     		ldrb	r1, [r4]	@ zero_extendqisi2
 1690 053e 4029     		cmp	r1, #64
 1691 0540 28D0     		beq	.L467
 313:grbl/protocol.c ****           }
 1692              		.loc 1 313 0
 1693 0542 8029     		cmp	r1, #128
 1694 0544 2CD1     		bne	.L250
 1695              	.L248:
 317:grbl/protocol.c ****         }
 1696              		.loc 1 317 0
 1697 0546 43F02003 		orr	r3, r3, #32
 1698 054a A370     		strb	r3, [r4, #2]
 1699 054c ECE5     		b	.L236
 1700              	.L451:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 1701              		.loc 1 285 0
 1702 054e 0029     		cmp	r1, #0
 1703 0550 7FF4E4AD 		bne	.L302
 1704 0554 E4E5     		b	.L245
 1705              	.L465:
 379:grbl/protocol.c ****         if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 1706              		.loc 1 379 0
 1707 0556 FFF7FEFF 		bl	plan_cycle_reinitialize
 1708              	.LVL167:
 380:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 1709              		.loc 1 380 0
 1710 055a 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 1711 055c 9A07     		lsls	r2, r3, #30
 1712 055e 03D5     		bpl	.L266
 1713 0560 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 1714 0562 42F00102 		orr	r2, r2, #1
 1715 0566 A270     		strb	r2, [r4, #2]
 1716              	.L266:
 381:grbl/protocol.c ****       } else {
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 50


 1717              		.loc 1 381 0
 1718 0568 23F00603 		bic	r3, r3, #6
 1719 056c 2371     		strb	r3, [r4, #4]
 1720 056e 1AE6     		b	.L267
 1721              	.L464:
 1722 0570 0192     		str	r2, [sp, #4]
 265:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active fla
 1723              		.loc 1 265 0
 1724 0572 FFF7FEFF 		bl	st_update_plan_block_parameters
 1725              	.LVL168:
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 1726              		.loc 1 266 0
 1727 0576 0221     		movs	r1, #2
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 1728              		.loc 1 267 0
 1729 0578 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 1730              		.loc 1 266 0
 1731 057a 2171     		strb	r1, [r4, #4]
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 1732              		.loc 1 267 0
 1733 057c 202B     		cmp	r3, #32
 1734 057e 019A     		ldr	r2, [sp, #4]
 1735 0580 7FF4B8AD 		bne	.L237
 268:grbl/protocol.c ****             }
 1736              		.loc 1 268 0
 1737 0584 002A     		cmp	r2, #0
 1738 0586 FFF6CBAD 		blt	.L245
 1739 058a A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1740 058c 63F07F03 		orn	r3, r3, #127
 1741 0590 A370     		strb	r3, [r4, #2]
 1742 0592 C5E5     		b	.L245
 1743              	.L467:
 300:grbl/protocol.c ****                 #ifdef PARKING_ENABLE
 1744              		.loc 1 300 0
 1745 0594 1807     		lsls	r0, r3, #28
 1746 0596 03D5     		bpl	.L250
 309:grbl/protocol.c ****                 sys.suspend |= SUSPEND_RESTART_RETRACT;
 1747              		.loc 1 309 0
 1748 0598 23F01C03 		bic	r3, r3, #28
 310:grbl/protocol.c ****               }
 1749              		.loc 1 310 0
 1750 059c 43F00203 		orr	r3, r3, #2
 1751              	.L250:
 313:grbl/protocol.c ****           }
 1752              		.loc 1 313 0
 1753 05a0 4021     		movs	r1, #64
 1754 05a2 2170     		strb	r1, [r4]
 1755 05a4 CFE7     		b	.L248
 1756              	.L455:
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 1757              		.loc 1 349 0
 1758 05a6 DA06     		lsls	r2, r3, #27
 1759 05a8 7FF5E4AD 		bpl	.L255
 1760 05ac A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 1761 05ae D107     		lsls	r1, r2, #31
 1762 05b0 7FF5E0AD 		bpl	.L255
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 51


 350:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 1763              		.loc 1 350 0
 1764 05b4 102B     		cmp	r3, #16
 1765 05b6 7FF4CAAD 		bne	.L259
 1766 05ba E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 1767 05bc 002B     		cmp	r3, #0
 1768 05be 3FF4C6AD 		beq	.L259
 351:grbl/protocol.c ****           } else {
 1769              		.loc 1 351 0
 1770 05c2 43F00803 		orr	r3, r3, #8
 1771 05c6 E372     		strb	r3, [r4, #11]
 1772 05c8 D4E5     		b	.L255
 1773              	.L462:
 1774              	.LBE36:
 1775              	.LBE43:
 734:grbl/protocol.c ****               if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
 1776              		.loc 1 734 0
 1777 05ca 0A20     		movs	r0, #10
 1778 05cc FFF7FEFF 		bl	report_feedback_message
 1779              	.LVL169:
 735:grbl/protocol.c ****                 // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycl
 1780              		.loc 1 735 0
 1781 05d0 95F84830 		ldrb	r3, [r5, #72]	@ zero_extendqisi2
 1782 05d4 9907     		lsls	r1, r3, #30
 1783 05d6 20D5     		bpl	.L225
 737:grbl/protocol.c ****               } else {
 1784              		.loc 1 737 0
 1785 05d8 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 1786 05da E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 1787 05dc 42F00802 		orr	r2, r2, #8
 1788 05e0 2271     		strb	r2, [r4, #4]
 1789 05e2 13E7     		b	.L224
 1790              	.L446:
 629:grbl/protocol.c ****             // Spindle and coolant should already be stopped, but do it again just to be sure.
 1791              		.loc 1 629 0
 1792 05e4 0B20     		movs	r0, #11
 1793 05e6 0192     		str	r2, [sp, #4]
 1794 05e8 FFF7FEFF 		bl	report_feedback_message
 1795              	.LVL170:
 631:grbl/protocol.c ****             coolant_set_state(COOLANT_DISABLE); // De-energize
 1796              		.loc 1 631 0
 1797 05ec 019A     		ldr	r2, [sp, #4]
 1798 05ee 0021     		movs	r1, #0
 1799 05f0 1046     		mov	r0, r2
 1800 05f2 FFF7FEFF 		bl	spindle_set_state
 1801              	.LVL171:
 632:grbl/protocol.c ****             st_go_idle(); // Disable steppers
 1802              		.loc 1 632 0
 1803 05f6 019A     		ldr	r2, [sp, #4]
 1804 05f8 1046     		mov	r0, r2
 1805 05fa FFF7FEFF 		bl	coolant_set_state
 1806              	.LVL172:
 633:grbl/protocol.c ****             while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
 1807              		.loc 1 633 0
 1808 05fe FFF7FEFF 		bl	st_go_idle
 1809              	.LVL173:
 634:grbl/protocol.c ****             return; // Abort received. Return to re-initialize.
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 52


 1810              		.loc 1 634 0
 1811 0602 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1812 0604 002B     		cmp	r3, #0
 1813 0606 7FF4E9AD 		bne	.L200
 1814              	.L212:
 634:grbl/protocol.c ****             return; // Abort received. Return to re-initialize.
 1815              		.loc 1 634 0 is_stmt 0 discriminator 2
 1816 060a FFF7FEFF 		bl	protocol_exec_rt_system
 1817              	.LVL174:
 1818 060e 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 1819 0610 002B     		cmp	r3, #0
 1820 0612 FAD0     		beq	.L212
 1821 0614 E2E5     		b	.L200
 1822              	.L466:
 1823              	.LBB44:
 1824              	.LBB37:
 338:grbl/protocol.c ****           } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 1825              		.loc 1 338 0 is_stmt 1
 1826 0616 2270     		strb	r2, [r4]
 1827 0618 99E5     		b	.L259
 1828              	.L225:
 1829              	.LBE37:
 1830              	.LBE44:
 739:grbl/protocol.c ****               }
 1831              		.loc 1 739 0
 1832 061a 4146     		mov	r1, r8
 1833 061c 06F03000 		and	r0, r6, #48
 1834 0620 FFF7FEFF 		bl	spindle_set_state
 1835              	.LVL175:
 1836 0624 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 1837 0626 F1E6     		b	.L224
 1838              	.L471:
 1839              		.align	2
 1840              	.L470:
 1841 0628 00000000 		.word	gc_state
 1842 062c 00000000 		.word	sys_rt_exec_state
 1843              		.cfi_endproc
 1844              	.LFE708:
 1846              		.section	.text.protocol_execute_realtime,"ax",%progbits
 1847              		.align	1
 1848              		.p2align 2,,3
 1849              		.global	protocol_execute_realtime
 1850              		.syntax unified
 1851              		.thumb
 1852              		.thumb_func
 1853              		.fpu softvfp
 1855              	protocol_execute_realtime:
 1856              	.LFB706:
 206:grbl/protocol.c ****   protocol_exec_rt_system();
 1857              		.loc 1 206 0
 1858              		.cfi_startproc
 1859              		@ args = 0, pretend = 0, frame = 0
 1860              		@ frame_needed = 0, uses_anonymous_args = 0
 1861 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 1862              	.LCFI10:
 1863              		.cfi_def_cfa_offset 24
 1864              		.cfi_offset 3, -24
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 53


 1865              		.cfi_offset 4, -20
 1866              		.cfi_offset 5, -16
 1867              		.cfi_offset 6, -12
 1868              		.cfi_offset 7, -8
 1869              		.cfi_offset 14, -4
 1870              	.LBB50:
 1871              	.LBB51:
 218:grbl/protocol.c ****   if (rt_exec) { // Enter only if any bit flag is true
 1872              		.loc 1 218 0
 1873 0002 AB4B     		ldr	r3, .L667
 1874 0004 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 1875              	.LVL176:
 219:grbl/protocol.c ****     // System alarm. Everything has shutdown by something that has gone severely wrong. Report
 1876              		.loc 1 219 0
 1877 0006 002B     		cmp	r3, #0
 1878 0008 40F0BA80 		bne	.L647
 1879 000c A94C     		ldr	r4, .L667+4
 1880 000e AA4D     		ldr	r5, .L667+8
 1881              	.LVL177:
 1882              	.L473:
 240:grbl/protocol.c ****   if (rt_exec) {
 1883              		.loc 1 240 0
 1884 0010 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 1885              	.LVL178:
 241:grbl/protocol.c **** 
 1886              		.loc 1 241 0
 1887 0012 03F0FF05 		and	r5, r3, #255
 1888 0016 002B     		cmp	r3, #0
 1889 0018 5BD0     		beq	.L477
 244:grbl/protocol.c ****       sys.abort = true;  // Only place this is set true.
 1890              		.loc 1 244 0
 1891 001a E806     		lsls	r0, r5, #27
 1892 001c 00F1AD80 		bmi	.L652
 250:grbl/protocol.c ****       report_realtime_status();
 1893              		.loc 1 250 0
 1894 0020 E907     		lsls	r1, r5, #31
 1895 0022 00F12B81 		bmi	.L653
 1896              	.LVL179:
 1897              	.L480:
 257:grbl/protocol.c **** 
 1898              		.loc 1 257 0
 1899 0026 15F0E80F 		tst	r5, #232
 1900 002a 33D0     		beq	.L481
 260:grbl/protocol.c ****       
 1901              		.loc 1 260 0
 1902 002c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1903 002e 6EB2     		sxtb	r6, r5
 1904 0030 9A07     		lsls	r2, r3, #30
 1905 0032 29D1     		bne	.L483
 263:grbl/protocol.c ****           if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already
 1906              		.loc 1 263 0
 1907 0034 13F0280F 		tst	r3, #40
 1908 0038 40F05481 		bne	.L654
 1909              	.L484:
 1910 003c 05F04001 		and	r1, r5, #64
 1911 0040 05F00802 		and	r2, r5, #8
 273:grbl/protocol.c **** 
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 54


 1912              		.loc 1 273 0
 1913 0044 002B     		cmp	r3, #0
 1914 0046 40F05581 		bne	.L487
 1915 004a 0120     		movs	r0, #1
 1916 004c A070     		strb	r0, [r4, #2]
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 1917              		.loc 1 277 0
 1918 004e 0029     		cmp	r1, #0
 1919 0050 00F07781 		beq	.L655
 1920 0054 4121     		movs	r1, #65
 281:grbl/protocol.c ****         }
 1921              		.loc 1 281 0
 1922 0056 A170     		strb	r1, [r4, #2]
 1923              	.L490:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 1924              		.loc 1 285 0
 1925 0058 1AB1     		cbz	r2, .L492
 287:grbl/protocol.c ****         }
 1926              		.loc 1 287 0
 1927 005a 13F0E00F 		tst	r3, #224
 1928 005e 00F07381 		beq	.L550
 1929              	.L492:
 293:grbl/protocol.c ****           report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 1930              		.loc 1 293 0
 1931 0062 A806     		lsls	r0, r5, #26
 1932 0064 10D5     		bpl	.L483
 294:grbl/protocol.c ****           // If jogging, block safety door methods until jog cancel is complete. Just flag that it 
 1933              		.loc 1 294 0
 1934 0066 0620     		movs	r0, #6
 1935 0068 FFF7FEFF 		bl	report_feedback_message
 1936              	.LVL180:
 296:grbl/protocol.c ****             // Check if the safety re-opened during a restore parking motion only. Ignore if
 1937              		.loc 1 296 0
 1938 006c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1939 006e 1906     		lsls	r1, r3, #24
 1940 0070 07D4     		bmi	.L495
 299:grbl/protocol.c ****               if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 1941              		.loc 1 299 0
 1942 0072 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 1943 0074 402A     		cmp	r2, #64
 1944 0076 00F0A881 		beq	.L656
 313:grbl/protocol.c ****           }
 1945              		.loc 1 313 0
 1946 007a 802A     		cmp	r2, #128
 1947 007c 01D0     		beq	.L495
 1948              	.L497:
 1949 007e 4022     		movs	r2, #64
 1950 0080 2270     		strb	r2, [r4]
 1951              	.L495:
 317:grbl/protocol.c ****         }
 1952              		.loc 1 317 0
 1953 0082 43F02003 		orr	r3, r3, #32
 1954 0086 A370     		strb	r3, [r4, #2]
 1955              	.L483:
 322:grbl/protocol.c ****         if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPL
 1956              		.loc 1 322 0
 1957 0088 002E     		cmp	r6, #0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 55


 1958 008a C0F24781 		blt	.L657
 1959              	.L498:
 327:grbl/protocol.c ****     }
 1960              		.loc 1 327 0
 1961 008e E820     		movs	r0, #232
 1962 0090 FFF7FEFF 		bl	system_clear_exec_state_flag
 1963              	.LVL181:
 1964              	.L481:
 331:grbl/protocol.c ****       // Block if called at same time as the hold commands: feed hold, motion cancel, and safety do
 1965              		.loc 1 331 0
 1966 0094 AB07     		lsls	r3, r5, #30
 1967 0096 19D5     		bpl	.L500
 334:grbl/protocol.c ****         // Resume door state when parking motion has retracted and door has been closed.
 1968              		.loc 1 334 0
 1969 0098 15F0680F 		tst	r5, #104
 1970 009c 13D1     		bne	.L502
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 1971              		.loc 1 336 0
 1972 009e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 1973 00a0 402B     		cmp	r3, #64
 1974 00a2 00F03281 		beq	.L658
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 1975              		.loc 1 349 0
 1976 00a6 002B     		cmp	r3, #0
 1977 00a8 40F05181 		bne	.L659
 1978              	.L506:
 354:grbl/protocol.c ****             if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 1979              		.loc 1 354 0
 1980 00ac 0023     		movs	r3, #0
 1981 00ae 2371     		strb	r3, [r4, #4]
 355:grbl/protocol.c ****               sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 1982              		.loc 1 355 0
 1983 00b0 FFF7FEFF 		bl	plan_get_current_block
 1984              	.LVL182:
 1985 00b4 20B1     		cbz	r0, .L509
 1986 00b6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 1987 00b8 13F04003 		ands	r3, r3, #64
 1988 00bc 00F07681 		beq	.L660
 1989              	.L509:
 361:grbl/protocol.c ****               sys.state = STATE_IDLE;
 1990              		.loc 1 361 0
 1991 00c0 0023     		movs	r3, #0
 1992 00c2 A370     		strb	r3, [r4, #2]
 362:grbl/protocol.c ****             }
 1993              		.loc 1 362 0
 1994 00c4 2370     		strb	r3, [r4]
 1995              	.L502:
 367:grbl/protocol.c ****     }
 1996              		.loc 1 367 0
 1997 00c6 0220     		movs	r0, #2
 1998 00c8 FFF7FEFF 		bl	system_clear_exec_state_flag
 1999              	.LVL183:
 2000              	.L500:
 370:grbl/protocol.c ****       // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
 2001              		.loc 1 370 0
 2002 00cc 6907     		lsls	r1, r5, #29
 2003 00ce 00F1BD80 		bmi	.L661
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 56


 2004              	.L477:
 406:grbl/protocol.c ****   if (rt_exec) {
 2005              		.loc 1 406 0
 2006 00d2 7A4B     		ldr	r3, .L667+12
 2007 00d4 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2008              	.LVL184:
 407:grbl/protocol.c ****     system_clear_exec_motion_overrides(); // Clear all motion override flags.
 2009              		.loc 1 407 0
 2010 00d6 03F0FF05 		and	r5, r3, #255
 2011 00da 002B     		cmp	r3, #0
 2012 00dc 7BD1     		bne	.L662
 2013              	.LVL185:
 2014              	.L518:
 433:grbl/protocol.c ****   if (rt_exec) {
 2015              		.loc 1 433 0
 2016 00de 784B     		ldr	r3, .L667+16
 2017 00e0 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 2018              	.LVL186:
 434:grbl/protocol.c ****     system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 2019              		.loc 1 434 0
 2020 00e2 03F0FF05 		and	r5, r3, #255
 2021 00e6 3BB9     		cbnz	r3, .L529
 2022 00e8 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2023              	.LVL187:
 2024              	.L530:
 494:grbl/protocol.c ****     st_prep_buffer();
 2025              		.loc 1 494 0
 2026 00ea 13F0FC0F 		tst	r3, #252
 2027 00ee 3BD1     		bne	.L548
 2028              	.L479:
 2029              	.LBE51:
 2030              	.LBE50:
 208:grbl/protocol.c **** }
 2031              		.loc 1 208 0
 2032 00f0 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2033 00f2 002B     		cmp	r3, #0
 2034 00f4 3DD1     		bne	.L663
 2035              	.L472:
 209:grbl/protocol.c **** 
 2036              		.loc 1 209 0
 2037 00f6 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 2038              	.LVL188:
 2039              	.L529:
 2040              	.LBB60:
 2041              	.LBB58:
 2042              	.LBB52:
 435:grbl/protocol.c **** 
 2043              		.loc 1 435 0
 2044 00f8 FFF7FEFF 		bl	system_clear_exec_accessory_overrides
 2045              	.LVL189:
 438:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 2046              		.loc 1 438 0
 2047 00fc A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
 2048              	.LVL190:
 2049 00fe 15F0010F 		tst	r5, #1
 2050 0102 0CBF     		ite	eq
 2051 0104 1346     		moveq	r3, r2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 57


 2052 0106 6423     		movne	r3, #100
 2053              	.LVL191:
 440:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCRE
 2054              		.loc 1 440 0
 2055 0108 AE07     		lsls	r6, r5, #30
 2056 010a 44BF     		itt	mi
 2057 010c 0A33     		addmi	r3, r3, #10
 2058              	.LVL192:
 2059 010e DBB2     		uxtbmi	r3, r3
 2060              	.LVL193:
 441:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 2061              		.loc 1 441 0
 2062 0110 6807     		lsls	r0, r5, #29
 2063 0112 44BF     		itt	mi
 2064 0114 0A3B     		submi	r3, r3, #10
 2065              	.LVL194:
 2066 0116 DBB2     		uxtbmi	r3, r3
 2067              	.LVL195:
 442:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT
 2068              		.loc 1 442 0
 2069 0118 2907     		lsls	r1, r5, #28
 2070 011a 44BF     		itt	mi
 2071 011c 0133     		addmi	r3, r3, #1
 2072              	.LVL196:
 2073 011e DBB2     		uxtbmi	r3, r3
 2074              	.LVL197:
 443:grbl/protocol.c ****     last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 2075              		.loc 1 443 0
 2076 0120 EF06     		lsls	r7, r5, #27
 2077 0122 44BF     		itt	mi
 2078 0124 03F1FF33 		addmi	r3, r3, #-1
 2079              	.LVL198:
 2080 0128 DBB2     		uxtbmi	r3, r3
 2081              	.LVL199:
 445:grbl/protocol.c **** 
 2082              		.loc 1 445 0
 2083 012a C82B     		cmp	r3, #200
 2084 012c 28BF     		it	cs
 2085 012e C823     		movcs	r3, #200
 2086              	.LVL200:
 2087 0130 0A2B     		cmp	r3, #10
 2088 0132 38BF     		it	cc
 2089 0134 0A23     		movcc	r3, #10
 2090              	.LVL201:
 447:grbl/protocol.c ****       bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 2091              		.loc 1 447 0
 2092 0136 9A42     		cmp	r2, r3
 2093 0138 06D0     		beq	.L536
 450:grbl/protocol.c ****     }
 2094              		.loc 1 450 0
 2095 013a 0021     		movs	r1, #0
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 2096              		.loc 1 448 0
 2097 013c 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
 449:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 2098              		.loc 1 449 0
 2099 013e A372     		strb	r3, [r4, #10]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 58


 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 2100              		.loc 1 448 0
 2101 0140 42F00803 		orr	r3, r2, #8
 2102              	.LVL202:
 2103 0144 2371     		strb	r3, [r4, #4]
 450:grbl/protocol.c ****     }
 2104              		.loc 1 450 0
 2105 0146 2173     		strb	r1, [r4, #12]
 2106              	.LVL203:
 2107              	.L536:
 453:grbl/protocol.c ****       // Spindle stop override allowed only while in HOLD state.
 2108              		.loc 1 453 0
 2109 0148 AE06     		lsls	r6, r5, #26
 2110 014a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2111 014c 05F0C002 		and	r2, r5, #192
 2112 0150 25D5     		bpl	.L537
 456:grbl/protocol.c ****         if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 2113              		.loc 1 456 0
 2114 0152 102B     		cmp	r3, #16
 2115 0154 23D1     		bne	.L537
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 2116              		.loc 1 457 0
 2117 0156 E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 2118 0158 0029     		cmp	r1, #0
 2119 015a 40F0E980 		bne	.L538
 2120 015e 0221     		movs	r1, #2
 2121 0160 E172     		strb	r1, [r4, #11]
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 2122              		.loc 1 464 0
 2123 0162 002A     		cmp	r2, #0
 2124 0164 40F09E80 		bne	.L539
 2125              	.L548:
 2126              	.LBE52:
 495:grbl/protocol.c ****   }
 2127              		.loc 1 495 0
 2128 0168 FFF7FEFF 		bl	st_prep_buffer
 2129              	.LVL204:
 2130              	.LBE58:
 2131              	.LBE60:
 208:grbl/protocol.c **** }
 2132              		.loc 1 208 0
 2133 016c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2134 016e 002B     		cmp	r3, #0
 2135 0170 C1D0     		beq	.L472
 2136              	.L663:
 209:grbl/protocol.c **** 
 2137              		.loc 1 209 0 discriminator 1
 2138 0172 BDE8F840 		pop	{r3, r4, r5, r6, r7, lr}
 2139              	.LCFI11:
 2140              		.cfi_remember_state
 2141              		.cfi_restore 14
 2142              		.cfi_restore 7
 2143              		.cfi_restore 6
 2144              		.cfi_restore 5
 2145              		.cfi_restore 4
 2146              		.cfi_restore 3
 2147              		.cfi_def_cfa_offset 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 59


 208:grbl/protocol.c **** }
 2148              		.loc 1 208 0 discriminator 1
 2149 0176 FFF7FEBF 		b	protocol_exec_rt_suspend
 2150              	.LVL205:
 2151              	.L652:
 2152              	.LCFI12:
 2153              		.cfi_restore_state
 2154              	.LBB61:
 2155              	.LBB59:
 245:grbl/protocol.c ****       return; // Nothing else to do but exit.
 2156              		.loc 1 245 0
 2157 017a 0123     		movs	r3, #1
 2158              	.LVL206:
 2159 017c 6370     		strb	r3, [r4, #1]
 2160 017e B7E7     		b	.L479
 2161              	.LVL207:
 2162              	.L647:
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 2163              		.loc 1 223 0
 2164 0180 0126     		movs	r6, #1
 2165 0182 03F0FF05 		and	r5, r3, #255
 2166 0186 4B4C     		ldr	r4, .L667+4
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 2167              		.loc 1 224 0
 2168 0188 2846     		mov	r0, r5
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 2169              		.loc 1 226 0
 2170 018a 013D     		subs	r5, r5, #1
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 2171              		.loc 1 223 0
 2172 018c 2670     		strb	r6, [r4]
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 2173              		.loc 1 224 0
 2174 018e FFF7FEFF 		bl	report_alarm_message
 2175              	.LVL208:
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 2176              		.loc 1 226 0
 2177 0192 B542     		cmp	r5, r6
 2178 0194 78D9     		bls	.L648
 2179 0196 484D     		ldr	r5, .L667+8
 2180              	.L474:
 237:grbl/protocol.c ****   }
 2181              		.loc 1 237 0
 2182 0198 FFF7FEFF 		bl	system_clear_exec_alarm
 2183              	.LVL209:
 2184 019c 38E7     		b	.L473
 2185              	.L537:
 2186              	.LBB54:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 2187              		.loc 1 464 0
 2188 019e 002A     		cmp	r2, #0
 2189 01a0 A3D0     		beq	.L530
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 2190              		.loc 1 465 0
 2191 01a2 002B     		cmp	r3, #0
 2192 01a4 7ED1     		bne	.L539
 2193              	.L540:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 60


 2194              	.LBB53:
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 2195              		.loc 1 466 0
 2196 01a6 474F     		ldr	r7, .L667+20
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 2197              		.loc 1 468 0
 2198 01a8 2A06     		lsls	r2, r5, #24
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 2199              		.loc 1 466 0
 2200 01aa 3E7A     		ldrb	r6, [r7, #8]	@ zero_extendqisi2
 2201              	.LVL210:
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 2202              		.loc 1 468 0
 2203 01ac 05D5     		bpl	.L544
 469:grbl/protocol.c ****             else { coolant_state |= COOLANT_MIST_ENABLE; }
 2204              		.loc 1 469 0
 2205 01ae 3306     		lsls	r3, r6, #24
 2206 01b0 4CBF     		ite	mi
 2207 01b2 06F07F06 		andmi	r6, r6, #127
 2208              	.LVL211:
 470:grbl/protocol.c ****           }
 2209              		.loc 1 470 0
 2210 01b6 46F08006 		orrpl	r6, r6, #128
 2211              	.LVL212:
 2212              	.L544:
 472:grbl/protocol.c ****             if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABL
 2213              		.loc 1 472 0
 2214 01ba 6806     		lsls	r0, r5, #25
 2215 01bc 05D5     		bpl	.L546
 473:grbl/protocol.c ****             else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 2216              		.loc 1 473 0
 2217 01be 7106     		lsls	r1, r6, #25
 2218 01c0 4CBF     		ite	mi
 2219 01c2 06F0BF06 		andmi	r6, r6, #191
 2220              	.LVL213:
 474:grbl/protocol.c ****           }
 2221              		.loc 1 474 0
 2222 01c6 46F04006 		orrpl	r6, r6, #64
 2223              	.LVL214:
 2224              	.L546:
 480:grbl/protocol.c ****         gc_state.modal.coolant = coolant_state;
 2225              		.loc 1 480 0
 2226 01ca 3046     		mov	r0, r6
 2227 01cc FFF7FEFF 		bl	coolant_set_state
 2228              	.LVL215:
 2229 01d0 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 481:grbl/protocol.c ****       }
 2230              		.loc 1 481 0
 2231 01d2 3E72     		strb	r6, [r7, #8]
 2232 01d4 89E7     		b	.L530
 2233              	.LVL216:
 2234              	.L662:
 2235              	.LBE53:
 2236              	.LBE54:
 2237              	.LBB55:
 408:grbl/protocol.c **** 
 2238              		.loc 1 408 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 61


 2239 01d6 FFF7FEFF 		bl	system_clear_exec_motion_overrides
 2240              	.LVL217:
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 2241              		.loc 1 410 0
 2242 01da 217A     		ldrb	r1, [r4, #8]	@ zero_extendqisi2
 2243              	.LVL218:
 2244 01dc 15F0010F 		tst	r5, #1
 2245 01e0 0CBF     		ite	eq
 2246 01e2 0B46     		moveq	r3, r1
 2247 01e4 6423     		movne	r3, #100
 2248              	.LVL219:
 412:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 2249              		.loc 1 412 0
 2250 01e6 AF07     		lsls	r7, r5, #30
 2251 01e8 44BF     		itt	mi
 2252 01ea 0A33     		addmi	r3, r3, #10
 2253              	.LVL220:
 2254 01ec DBB2     		uxtbmi	r3, r3
 2255              	.LVL221:
 413:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 2256              		.loc 1 413 0
 2257 01ee 6E07     		lsls	r6, r5, #29
 2258 01f0 44BF     		itt	mi
 2259 01f2 0A3B     		submi	r3, r3, #10
 2260              	.LVL222:
 2261 01f4 DBB2     		uxtbmi	r3, r3
 2262              	.LVL223:
 414:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 2263              		.loc 1 414 0
 2264 01f6 2807     		lsls	r0, r5, #28
 2265 01f8 44BF     		itt	mi
 2266 01fa 0133     		addmi	r3, r3, #1
 2267              	.LVL224:
 2268 01fc DBB2     		uxtbmi	r3, r3
 2269              	.LVL225:
 415:grbl/protocol.c ****     new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 2270              		.loc 1 415 0
 2271 01fe EF06     		lsls	r7, r5, #27
 2272 0200 44BF     		itt	mi
 2273 0202 03F1FF33 		addmi	r3, r3, #-1
 2274              	.LVL226:
 2275 0206 DBB2     		uxtbmi	r3, r3
 2276              	.LVL227:
 417:grbl/protocol.c **** 
 2277              		.loc 1 417 0
 2278 0208 C82B     		cmp	r3, #200
 2279 020a 28BF     		it	cs
 2280 020c C823     		movcs	r3, #200
 2281              	.LVL228:
 2282 020e 0A2B     		cmp	r3, #10
 2283 0210 38BF     		it	cc
 2284 0212 0A23     		movcc	r3, #10
 2285              	.LVL229:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 2286              		.loc 1 419 0
 2287 0214 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 2288              	.LVL230:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 62


 2289 0216 15F0200F 		tst	r5, #32
 2290 021a 14BF     		ite	ne
 2291 021c 6422     		movne	r2, #100
 2292 021e 0246     		moveq	r2, r0
 2293              	.LVL231:
 421:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 2294              		.loc 1 421 0
 2295 0220 15F0400F 		tst	r5, #64
 2296 0224 18BF     		it	ne
 2297 0226 3222     		movne	r2, #50
 2298              	.LVL232:
 422:grbl/protocol.c **** 
 2299              		.loc 1 422 0
 2300 0228 15F0800F 		tst	r5, #128
 2301 022c 18BF     		it	ne
 2302 022e 1922     		movne	r2, #25
 2303              	.LVL233:
 424:grbl/protocol.c ****       sys.f_override = new_f_override;
 2304              		.loc 1 424 0
 2305 0230 9942     		cmp	r1, r3
 2306 0232 02D1     		bne	.L527
 2307 0234 9042     		cmp	r0, r2
 2308 0236 3FF452AF 		beq	.L518
 2309              	.L527:
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 2310              		.loc 1 427 0
 2311 023a 0021     		movs	r1, #0
 425:grbl/protocol.c ****       sys.r_override = new_r_override;
 2312              		.loc 1 425 0
 2313 023c 2372     		strb	r3, [r4, #8]
 426:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 2314              		.loc 1 426 0
 2315 023e 6272     		strb	r2, [r4, #9]
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 2316              		.loc 1 427 0
 2317 0240 2173     		strb	r1, [r4, #12]
 428:grbl/protocol.c ****       plan_cycle_reinitialize();
 2318              		.loc 1 428 0
 2319 0242 FFF7FEFF 		bl	plan_update_velocity_profile_parameters
 2320              	.LVL234:
 429:grbl/protocol.c ****     }
 2321              		.loc 1 429 0
 2322 0246 FFF7FEFF 		bl	plan_cycle_reinitialize
 2323              	.LVL235:
 2324 024a 48E7     		b	.L518
 2325              	.L661:
 2326              	.LBE55:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 2327              		.loc 1 376 0
 2328 024c 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 2329 024e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2330 0250 12F0D00F 		tst	r2, #208
 2331 0254 59B2     		sxtb	r1, r3
 2332 0256 01D0     		beq	.L511
 2333 0258 E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 2334 025a AAB3     		cbz	r2, .L664
 2335              	.L511:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 63


 385:grbl/protocol.c ****           sys.step_control = STEP_CONTROL_NORMAL_OP;
 2336              		.loc 1 385 0
 2337 025c 0029     		cmp	r1, #0
 2338 025e 35DB     		blt	.L512
 2339              	.L515:
 392:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 2340              		.loc 1 392 0
 2341 0260 13F02002 		ands	r2, r3, #32
 2342 0264 1BD0     		beq	.L516
 395:grbl/protocol.c ****         } else {
 2343              		.loc 1 395 0
 2344 0266 4022     		movs	r2, #64
 393:grbl/protocol.c ****           sys.suspend |= SUSPEND_HOLD_COMPLETE;
 2345              		.loc 1 393 0
 2346 0268 03F07F03 		and	r3, r3, #127
 394:grbl/protocol.c ****           sys.state = STATE_SAFETY_DOOR;
 2347              		.loc 1 394 0
 2348 026c 43F00103 		orr	r3, r3, #1
 2349 0270 A370     		strb	r3, [r4, #2]
 395:grbl/protocol.c ****         } else {
 2350              		.loc 1 395 0
 2351 0272 2270     		strb	r2, [r4]
 2352              	.L514:
 401:grbl/protocol.c ****     }
 2353              		.loc 1 401 0
 2354 0274 0420     		movs	r0, #4
 2355 0276 FFF7FEFF 		bl	system_clear_exec_state_flag
 2356              	.LVL236:
 2357 027a 2AE7     		b	.L477
 2358              	.LVL237:
 2359              	.L653:
 251:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 2360              		.loc 1 251 0
 2361 027c FFF7FEFF 		bl	report_realtime_status
 2362              	.LVL238:
 252:grbl/protocol.c ****     }
 2363              		.loc 1 252 0
 2364 0280 0120     		movs	r0, #1
 2365 0282 FFF7FEFF 		bl	system_clear_exec_state_flag
 2366              	.LVL239:
 2367 0286 CEE6     		b	.L480
 2368              	.L648:
 227:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 2369              		.loc 1 227 0
 2370 0288 3046     		mov	r0, r6
 2371 028a FFF7FEFF 		bl	report_feedback_message
 2372              	.LVL240:
 228:grbl/protocol.c ****       do {
 2373              		.loc 1 228 0
 2374 028e 1020     		movs	r0, #16
 2375 0290 FFF7FEFF 		bl	system_clear_exec_state_flag
 2376              	.LVL241:
 2377 0294 084D     		ldr	r5, .L667+8
 2378              	.L475:
 235:grbl/protocol.c ****     }
 2379              		.loc 1 235 0
 2380 0296 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 64


 2381 0298 DE06     		lsls	r6, r3, #27
 2382 029a FCD5     		bpl	.L475
 2383 029c 7CE7     		b	.L474
 2384              	.L516:
 397:grbl/protocol.c ****           sys.state = STATE_IDLE;
 2385              		.loc 1 397 0
 2386 029e A270     		strb	r2, [r4, #2]
 398:grbl/protocol.c ****         }
 2387              		.loc 1 398 0
 2388 02a0 2270     		strb	r2, [r4]
 2389 02a2 E7E7     		b	.L514
 2390              	.L539:
 2391              	.LBB56:
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 2392              		.loc 1 465 0
 2393 02a4 13F0180F 		tst	r3, #24
 2394 02a8 3FF41FAF 		beq	.L530
 2395 02ac 7BE7     		b	.L540
 2396              	.L668:
 2397 02ae 00BF     		.align	2
 2398              	.L667:
 2399 02b0 00000000 		.word	sys_rt_exec_alarm
 2400 02b4 00000000 		.word	sys
 2401 02b8 00000000 		.word	sys_rt_exec_state
 2402 02bc 00000000 		.word	sys_rt_exec_motion_override
 2403 02c0 00000000 		.word	sys_rt_exec_accessory_override
 2404 02c4 00000000 		.word	gc_state
 2405              	.L664:
 2406              	.LBE56:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 2407              		.loc 1 376 0
 2408 02c8 0029     		cmp	r1, #0
 2409 02ca 52DA     		bge	.L665
 2410              	.L512:
 386:grbl/protocol.c ****           plan_reset();
 2411              		.loc 1 386 0
 2412 02cc 0023     		movs	r3, #0
 2413 02ce 2371     		strb	r3, [r4, #4]
 387:grbl/protocol.c ****           st_reset();
 2414              		.loc 1 387 0
 2415 02d0 FFF7FEFF 		bl	plan_reset
 2416              	.LVL242:
 388:grbl/protocol.c ****           gc_sync_position();
 2417              		.loc 1 388 0
 2418 02d4 FFF7FEFF 		bl	st_reset
 2419              	.LVL243:
 389:grbl/protocol.c ****           plan_sync_position();
 2420              		.loc 1 389 0
 2421 02d8 FFF7FEFF 		bl	gc_sync_position
 2422              	.LVL244:
 390:grbl/protocol.c ****         }
 2423              		.loc 1 390 0
 2424 02dc FFF7FEFF 		bl	plan_sync_position
 2425              	.LVL245:
 2426 02e0 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2427 02e2 BDE7     		b	.L515
 2428              	.L654:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 65


 264:grbl/protocol.c ****             st_update_plan_block_parameters(); // Notify stepper module to recompute for hold decel
 2429              		.loc 1 264 0
 2430 02e4 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 2431 02e6 12F0C00F 		tst	r2, #192
 2432 02ea 4FD0     		beq	.L666
 2433 02ec 05F04001 		and	r1, r5, #64
 2434 02f0 05F00802 		and	r2, r5, #8
 2435              	.L487:
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 2436              		.loc 1 277 0
 2437 02f4 0029     		cmp	r1, #0
 2438 02f6 3FF4AFAE 		beq	.L490
 281:grbl/protocol.c ****         }
 2439              		.loc 1 281 0
 2440 02fa 9F06     		lsls	r7, r3, #26
 2441 02fc 3FF5ACAE 		bmi	.L490
 2442 0300 A178     		ldrb	r1, [r4, #2]	@ zero_extendqisi2
 2443 0302 41F04001 		orr	r1, r1, #64
 2444 0306 A170     		strb	r1, [r4, #2]
 2445 0308 A6E6     		b	.L490
 2446              	.L658:
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 2447              		.loc 1 336 0
 2448 030a A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2449 030c 13F02002 		ands	r2, r3, #32
 2450 0310 7FF4D9AE 		bne	.L502
 337:grbl/protocol.c ****             sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 2451              		.loc 1 337 0
 2452 0314 DF06     		lsls	r7, r3, #27
 2453 0316 51D5     		bpl	.L505
 338:grbl/protocol.c ****           } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 2454              		.loc 1 338 0
 2455 0318 2270     		strb	r2, [r4]
 2456 031a C7E6     		b	.L506
 2457              	.L657:
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 2458              		.loc 1 323 0
 2459 031c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2460 031e 012B     		cmp	r3, #1
 2461 0320 03D1     		bne	.L499
 2462 0322 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2463 0324 43F00503 		orr	r3, r3, #5
 2464 0328 A370     		strb	r3, [r4, #2]
 2465              	.L499:
 324:grbl/protocol.c ****       }
 2466              		.loc 1 324 0
 2467 032a 8023     		movs	r3, #128
 2468 032c 2370     		strb	r3, [r4]
 2469 032e AEE6     		b	.L498
 2470              	.L538:
 2471              	.LBB57:
 458:grbl/protocol.c ****       }
 2472              		.loc 1 458 0
 2473 0330 C807     		lsls	r0, r1, #31
 2474 0332 02D5     		bpl	.L541
 2475 0334 41F00401 		orr	r1, r1, #4
 2476 0338 E172     		strb	r1, [r4, #11]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 66


 2477              	.L541:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 2478              		.loc 1 464 0
 2479 033a 002A     		cmp	r2, #0
 2480 033c 7FF433AF 		bne	.L540
 2481 0340 12E7     		b	.L548
 2482              	.L655:
 2483              	.LBE57:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 2484              		.loc 1 285 0
 2485 0342 002A     		cmp	r2, #0
 2486 0344 3FF48DAE 		beq	.L492
 2487              	.L550:
 287:grbl/protocol.c ****         }
 2488              		.loc 1 287 0
 2489 0348 1023     		movs	r3, #16
 2490 034a 2370     		strb	r3, [r4]
 2491 034c 89E6     		b	.L492
 2492              	.L659:
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 2493              		.loc 1 349 0
 2494 034e DA06     		lsls	r2, r3, #27
 2495 0350 7FF5B9AE 		bpl	.L502
 2496 0354 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 2497 0356 D007     		lsls	r0, r2, #31
 2498 0358 7FF5B5AE 		bpl	.L502
 350:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 2499              		.loc 1 350 0
 2500 035c 102B     		cmp	r3, #16
 2501 035e 7FF4A5AE 		bne	.L506
 2502 0362 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 2503 0364 002B     		cmp	r3, #0
 2504 0366 3FF4A1AE 		beq	.L506
 351:grbl/protocol.c ****           } else {
 2505              		.loc 1 351 0
 2506 036a 43F00803 		orr	r3, r3, #8
 2507 036e E372     		strb	r3, [r4, #11]
 2508 0370 A9E6     		b	.L502
 2509              	.L665:
 379:grbl/protocol.c ****         if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 2510              		.loc 1 379 0
 2511 0372 FFF7FEFF 		bl	plan_cycle_reinitialize
 2512              	.LVL246:
 380:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 2513              		.loc 1 380 0
 2514 0376 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 2515 0378 9A07     		lsls	r2, r3, #30
 2516 037a 03D5     		bpl	.L513
 2517 037c A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 2518 037e 42F00102 		orr	r2, r2, #1
 2519 0382 A270     		strb	r2, [r4, #2]
 2520              	.L513:
 381:grbl/protocol.c ****       } else {
 2521              		.loc 1 381 0
 2522 0384 23F00603 		bic	r3, r3, #6
 2523 0388 2371     		strb	r3, [r4, #4]
 2524 038a 73E7     		b	.L514
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 67


 2525              	.L666:
 265:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active fla
 2526              		.loc 1 265 0
 2527 038c FFF7FEFF 		bl	st_update_plan_block_parameters
 2528              	.LVL247:
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 2529              		.loc 1 266 0
 2530 0390 0222     		movs	r2, #2
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 2531              		.loc 1 267 0
 2532 0392 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 2533              		.loc 1 266 0
 2534 0394 2271     		strb	r2, [r4, #4]
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 2535              		.loc 1 267 0
 2536 0396 202B     		cmp	r3, #32
 2537 0398 7FF450AE 		bne	.L484
 268:grbl/protocol.c ****             }
 2538              		.loc 1 268 0
 2539 039c 002E     		cmp	r6, #0
 2540 039e FFF660AE 		blt	.L492
 2541 03a2 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2542 03a4 63F07F03 		orn	r3, r3, #127
 2543 03a8 A370     		strb	r3, [r4, #2]
 2544 03aa 5AE6     		b	.L492
 2545              	.L660:
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 2546              		.loc 1 357 0
 2547 03ac 0822     		movs	r2, #8
 356:grbl/protocol.c ****               sys.state = STATE_CYCLE;
 2548              		.loc 1 356 0
 2549 03ae A370     		strb	r3, [r4, #2]
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 2550              		.loc 1 357 0
 2551 03b0 2270     		strb	r2, [r4]
 358:grbl/protocol.c ****               st_wake_up();
 2552              		.loc 1 358 0
 2553 03b2 FFF7FEFF 		bl	st_prep_buffer
 2554              	.LVL248:
 359:grbl/protocol.c ****             } else { // Otherwise, do nothing. Set and resume IDLE state.
 2555              		.loc 1 359 0
 2556 03b6 FFF7FEFF 		bl	st_wake_up
 2557              	.LVL249:
 2558 03ba 84E6     		b	.L502
 2559              	.L505:
 339:grbl/protocol.c ****             // Flag to re-energize powered components and restore original position, if disabled by
 2560              		.loc 1 339 0
 2561 03bc 5E07     		lsls	r6, r3, #29
 2562 03be 7FF582AE 		bpl	.L502
 345:grbl/protocol.c ****           }
 2563              		.loc 1 345 0
 2564 03c2 43F00803 		orr	r3, r3, #8
 2565 03c6 A370     		strb	r3, [r4, #2]
 2566 03c8 7DE6     		b	.L502
 2567              	.L656:
 300:grbl/protocol.c ****                 #ifdef PARKING_ENABLE
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 68


 2568              		.loc 1 300 0
 2569 03ca 1A07     		lsls	r2, r3, #28
 2570 03cc 7FF557AE 		bpl	.L497
 309:grbl/protocol.c ****                 sys.suspend |= SUSPEND_RESTART_RETRACT;
 2571              		.loc 1 309 0
 2572 03d0 23F01C03 		bic	r3, r3, #28
 310:grbl/protocol.c ****               }
 2573              		.loc 1 310 0
 2574 03d4 43F00203 		orr	r3, r3, #2
 2575 03d8 51E6     		b	.L497
 2576              	.LBE59:
 2577              	.LBE61:
 2578              		.cfi_endproc
 2579              	.LFE706:
 2581 03da 00BF     		.section	.text.protocol_buffer_synchronize,"ax",%progbits
 2582              		.align	1
 2583              		.p2align 2,,3
 2584              		.global	protocol_buffer_synchronize
 2585              		.syntax unified
 2586              		.thumb
 2587              		.thumb_func
 2588              		.fpu softvfp
 2590              	protocol_buffer_synchronize:
 2591              	.LFB704:
 170:grbl/protocol.c ****   // If system is queued, ensure cycle resumes if the auto start flag is present.
 2592              		.loc 1 170 0
 2593              		.cfi_startproc
 2594              		@ args = 0, pretend = 0, frame = 0
 2595              		@ frame_needed = 0, uses_anonymous_args = 0
 2596 0000 2DE9F84F 		push	{r3, r4, r5, r6, r7, r8, r9, r10, fp, lr}
 2597              	.LCFI13:
 2598              		.cfi_def_cfa_offset 40
 2599              		.cfi_offset 3, -40
 2600              		.cfi_offset 4, -36
 2601              		.cfi_offset 5, -32
 2602              		.cfi_offset 6, -28
 2603              		.cfi_offset 7, -24
 2604              		.cfi_offset 8, -20
 2605              		.cfi_offset 9, -16
 2606              		.cfi_offset 10, -12
 2607              		.cfi_offset 11, -8
 2608              		.cfi_offset 14, -4
 2609              	.LBB71:
 2610              	.LBB72:
 188:grbl/protocol.c ****     system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 2611              		.loc 1 188 0
 2612 0004 FFF7FEFF 		bl	plan_get_current_block
 2613              	.LVL250:
 2614 0008 10B1     		cbz	r0, .L670
 189:grbl/protocol.c ****   }
 2615              		.loc 1 189 0
 2616 000a 0220     		movs	r0, #2
 2617 000c FFF7FEFF 		bl	system_set_exec_state_flag
 2618              	.LVL251:
 2619              	.L670:
 2620 0010 BD4E     		ldr	r6, .L873
 2621 0012 BE4C     		ldr	r4, .L873+4
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 69


 2622 0014 BE4D     		ldr	r5, .L873+8
 2623              	.LBE72:
 2624              	.LBE71:
 2625              	.LBB73:
 2626              	.LBB74:
 2627              	.LBB75:
 2628              	.LBB76:
 406:grbl/protocol.c ****   if (rt_exec) {
 2629              		.loc 1 406 0
 2630 0016 DFF80083 		ldr	r8, .L873+16
 433:grbl/protocol.c ****   if (rt_exec) {
 2631              		.loc 1 433 0
 2632 001a BE4F     		ldr	r7, .L873+12
 2633              	.LBB77:
 2634              	.LBB78:
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
 2635              		.loc 1 466 0
 2636 001c DFF8FC92 		ldr	r9, .L873+20
 2637              	.L821:
 2638              	.LBE78:
 2639              	.LBE77:
 218:grbl/protocol.c ****   if (rt_exec) { // Enter only if any bit flag is true
 2640              		.loc 1 218 0
 2641 0020 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 2642              	.LVL252:
 219:grbl/protocol.c ****     // System alarm. Everything has shutdown by something that has gone severely wrong. Report
 2643              		.loc 1 219 0
 2644 0022 03F0FF0A 		and	r10, r3, #255
 2645 0026 002B     		cmp	r3, #0
 2646 0028 40F0A580 		bne	.L857
 2647              	.LVL253:
 2648              	.L671:
 240:grbl/protocol.c ****   if (rt_exec) {
 2649              		.loc 1 240 0
 2650 002c 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 2651              	.LVL254:
 241:grbl/protocol.c **** 
 2652              		.loc 1 241 0
 2653 002e 03F0FF0A 		and	r10, r3, #255
 2654 0032 002B     		cmp	r3, #0
 2655 0034 79D0     		beq	.L675
 244:grbl/protocol.c ****       sys.abort = true;  // Only place this is set true.
 2656              		.loc 1 244 0
 2657 0036 1AF0100F 		tst	r10, #16
 2658 003a 40F09480 		bne	.L858
 250:grbl/protocol.c ****       report_realtime_status();
 2659              		.loc 1 250 0
 2660 003e 1AF0010F 		tst	r10, #1
 2661 0042 40F04881 		bne	.L859
 2662              	.LVL255:
 2663              	.L679:
 257:grbl/protocol.c **** 
 2664              		.loc 1 257 0
 2665 0046 1AF0E80F 		tst	r10, #232
 2666 004a 33D0     		beq	.L680
 260:grbl/protocol.c ****       
 2667              		.loc 1 260 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 70


 2668 004c 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2669 004e 4FFA8AFB 		sxtb	fp, r10
 2670 0052 9A07     		lsls	r2, r3, #30
 2671 0054 27D1     		bne	.L682
 263:grbl/protocol.c ****           if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already
 2672              		.loc 1 263 0
 2673 0056 13F0280F 		tst	r3, #40
 2674 005a 00F06E81 		beq	.L683
 264:grbl/protocol.c ****             st_update_plan_block_parameters(); // Notify stepper module to recompute for hold decel
 2675              		.loc 1 264 0
 2676 005e A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 2677 0060 12F0C00F 		tst	r2, #192
 2678 0064 00F06281 		beq	.L860
 2679 0068 0AF04002 		and	r2, r10, #64
 2680 006c 0AF00801 		and	r1, r10, #8
 2681              	.L686:
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 2682              		.loc 1 277 0
 2683 0070 002A     		cmp	r2, #0
 2684 0072 40F0AB81 		bne	.L861
 2685              	.L689:
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 2686              		.loc 1 285 0
 2687 0076 19B1     		cbz	r1, .L691
 287:grbl/protocol.c ****         }
 2688              		.loc 1 287 0
 2689 0078 13F0E00F 		tst	r3, #224
 2690 007c 00F06A81 		beq	.L751
 2691              	.L691:
 293:grbl/protocol.c ****           report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
 2692              		.loc 1 293 0
 2693 0080 1AF0200F 		tst	r10, #32
 2694 0084 0FD0     		beq	.L682
 294:grbl/protocol.c ****           // If jogging, block safety door methods until jog cancel is complete. Just flag that it 
 2695              		.loc 1 294 0
 2696 0086 0620     		movs	r0, #6
 2697 0088 FFF7FEFF 		bl	report_feedback_message
 2698              	.LVL256:
 296:grbl/protocol.c ****             // Check if the safety re-opened during a restore parking motion only. Ignore if
 2699              		.loc 1 296 0
 2700 008c A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2701 008e 1A06     		lsls	r2, r3, #24
 2702 0090 06D4     		bmi	.L694
 299:grbl/protocol.c ****               if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
 2703              		.loc 1 299 0
 2704 0092 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 2705 0094 402A     		cmp	r2, #64
 2706 0096 00F0A981 		beq	.L862
 313:grbl/protocol.c ****           }
 2707              		.loc 1 313 0
 2708 009a 802A     		cmp	r2, #128
 2709 009c 40F0AC81 		bne	.L696
 2710              	.L694:
 317:grbl/protocol.c ****         }
 2711              		.loc 1 317 0
 2712 00a0 43F02003 		orr	r3, r3, #32
 2713 00a4 A370     		strb	r3, [r4, #2]
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 71


 2714              	.L682:
 322:grbl/protocol.c ****         if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPL
 2715              		.loc 1 322 0
 2716 00a6 BBF1000F 		cmp	fp, #0
 2717 00aa C0F23981 		blt	.L863
 2718              	.L697:
 327:grbl/protocol.c ****     }
 2719              		.loc 1 327 0
 2720 00ae E820     		movs	r0, #232
 2721 00b0 FFF7FEFF 		bl	system_clear_exec_state_flag
 2722              	.LVL257:
 2723              	.L680:
 331:grbl/protocol.c ****       // Block if called at same time as the hold commands: feed hold, motion cancel, and safety do
 2724              		.loc 1 331 0
 2725 00b4 1AF0020F 		tst	r10, #2
 2726 00b8 19D0     		beq	.L699
 334:grbl/protocol.c ****         // Resume door state when parking motion has retracted and door has been closed.
 2727              		.loc 1 334 0
 2728 00ba 1AF0680F 		tst	r10, #104
 2729 00be 13D1     		bne	.L701
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 2730              		.loc 1 336 0
 2731 00c0 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2732 00c2 402B     		cmp	r3, #64
 2733 00c4 00F05781 		beq	.L864
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 2734              		.loc 1 349 0
 2735 00c8 002B     		cmp	r3, #0
 2736 00ca 40F09881 		bne	.L865
 2737              	.L705:
 354:grbl/protocol.c ****             if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
 2738              		.loc 1 354 0
 2739 00ce 0023     		movs	r3, #0
 2740 00d0 2371     		strb	r3, [r4, #4]
 355:grbl/protocol.c ****               sys.suspend = SUSPEND_DISABLE; // Break suspend state.
 2741              		.loc 1 355 0
 2742 00d2 FFF7FEFF 		bl	plan_get_current_block
 2743              	.LVL258:
 2744 00d6 20B1     		cbz	r0, .L708
 2745 00d8 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2746 00da 13F04003 		ands	r3, r3, #64
 2747 00de 00F07D81 		beq	.L866
 2748              	.L708:
 361:grbl/protocol.c ****               sys.state = STATE_IDLE;
 2749              		.loc 1 361 0
 2750 00e2 0023     		movs	r3, #0
 2751 00e4 A370     		strb	r3, [r4, #2]
 362:grbl/protocol.c ****             }
 2752              		.loc 1 362 0
 2753 00e6 2370     		strb	r3, [r4]
 2754              	.L701:
 367:grbl/protocol.c ****     }
 2755              		.loc 1 367 0
 2756 00e8 0220     		movs	r0, #2
 2757 00ea FFF7FEFF 		bl	system_clear_exec_state_flag
 2758              	.LVL259:
 2759              	.L699:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 72


 370:grbl/protocol.c ****       // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
 2760              		.loc 1 370 0
 2761 00ee 1AF0040F 		tst	r10, #4
 2762 00f2 1AD0     		beq	.L675
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 2763              		.loc 1 376 0
 2764 00f4 2278     		ldrb	r2, [r4]	@ zero_extendqisi2
 2765 00f6 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2766 00f8 12F0D00F 		tst	r2, #208
 2767 00fc 59B2     		sxtb	r1, r3
 2768 00fe 03D0     		beq	.L710
 2769 0100 E278     		ldrb	r2, [r4, #3]	@ zero_extendqisi2
 2770 0102 002A     		cmp	r2, #0
 2771 0104 00F02981 		beq	.L867
 2772              	.L710:
 385:grbl/protocol.c ****           sys.step_control = STEP_CONTROL_NORMAL_OP;
 2773              		.loc 1 385 0
 2774 0108 0029     		cmp	r1, #0
 2775 010a C0F22881 		blt	.L711
 2776              	.L714:
 392:grbl/protocol.c ****           sys.suspend &= ~(SUSPEND_JOG_CANCEL);
 2777              		.loc 1 392 0
 2778 010e 13F02002 		ands	r2, r3, #32
 2779 0112 00F0F080 		beq	.L715
 395:grbl/protocol.c ****         } else {
 2780              		.loc 1 395 0
 2781 0116 4022     		movs	r2, #64
 393:grbl/protocol.c ****           sys.suspend |= SUSPEND_HOLD_COMPLETE;
 2782              		.loc 1 393 0
 2783 0118 03F07F03 		and	r3, r3, #127
 394:grbl/protocol.c ****           sys.state = STATE_SAFETY_DOOR;
 2784              		.loc 1 394 0
 2785 011c 43F00103 		orr	r3, r3, #1
 2786 0120 A370     		strb	r3, [r4, #2]
 395:grbl/protocol.c ****         } else {
 2787              		.loc 1 395 0
 2788 0122 2270     		strb	r2, [r4]
 2789              	.L713:
 401:grbl/protocol.c ****     }
 2790              		.loc 1 401 0
 2791 0124 0420     		movs	r0, #4
 2792 0126 FFF7FEFF 		bl	system_clear_exec_state_flag
 2793              	.LVL260:
 2794              	.L675:
 406:grbl/protocol.c ****   if (rt_exec) {
 2795              		.loc 1 406 0
 2796 012a 98F80030 		ldrb	r3, [r8]	@ zero_extendqisi2
 2797              	.LVL261:
 407:grbl/protocol.c ****     system_clear_exec_motion_overrides(); // Clear all motion override flags.
 2798              		.loc 1 407 0
 2799 012e 03F0FF0A 		and	r10, r3, #255
 2800 0132 002B     		cmp	r3, #0
 2801 0134 40F08F80 		bne	.L868
 2802              	.LVL262:
 2803              	.L717:
 433:grbl/protocol.c ****   if (rt_exec) {
 2804              		.loc 1 433 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 73


 2805 0138 3B78     		ldrb	r3, [r7]	@ zero_extendqisi2
 2806              	.LVL263:
 434:grbl/protocol.c ****     system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
 2807              		.loc 1 434 0
 2808 013a 03F0FF0A 		and	r10, r3, #255
 2809 013e 4BBB     		cbnz	r3, .L728
 2810 0140 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2811              	.LVL264:
 2812              	.L729:
 494:grbl/protocol.c ****     st_prep_buffer();
 2813              		.loc 1 494 0
 2814 0142 13F0FC0F 		tst	r3, #252
 2815 0146 62D1     		bne	.L748
 2816              	.L739:
 2817              	.LBE76:
 2818              	.LBE75:
 208:grbl/protocol.c **** }
 2819              		.loc 1 208 0
 2820 0148 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2821 014a 8BB9     		cbnz	r3, .L677
 2822              	.L678:
 2823              	.LBE74:
 2824              	.LBE73:
 175:grbl/protocol.c ****   } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
 2825              		.loc 1 175 0
 2826 014c 6378     		ldrb	r3, [r4, #1]	@ zero_extendqisi2
 2827 014e 43B9     		cbnz	r3, .L669
 176:grbl/protocol.c **** }
 2828              		.loc 1 176 0
 2829 0150 FFF7FEFF 		bl	plan_get_current_block
 2830              	.LVL265:
 2831 0154 0028     		cmp	r0, #0
 2832 0156 7FF463AF 		bne	.L821
 176:grbl/protocol.c **** }
 2833              		.loc 1 176 0 is_stmt 0 discriminator 1
 2834 015a 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2835 015c 082B     		cmp	r3, #8
 2836 015e 3FF45FAF 		beq	.L821
 2837              	.L669:
 177:grbl/protocol.c **** 
 2838              		.loc 1 177 0 is_stmt 1
 2839 0162 BDE8F88F 		pop	{r3, r4, r5, r6, r7, r8, r9, r10, fp, pc}
 2840              	.LVL266:
 2841              	.L858:
 2842              	.LBB92:
 2843              	.LBB91:
 2844              	.LBB88:
 2845              	.LBB85:
 245:grbl/protocol.c ****       return; // Nothing else to do but exit.
 2846              		.loc 1 245 0
 2847 0166 0122     		movs	r2, #1
 2848              	.LBE85:
 2849              	.LBE88:
 208:grbl/protocol.c **** }
 2850              		.loc 1 208 0
 2851 0168 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 2852              	.LVL267:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 74


 2853              	.LBB89:
 2854              	.LBB86:
 245:grbl/protocol.c ****       return; // Nothing else to do but exit.
 2855              		.loc 1 245 0
 2856 016a 6270     		strb	r2, [r4, #1]
 2857              	.LBE86:
 2858              	.LBE89:
 208:grbl/protocol.c **** }
 2859              		.loc 1 208 0
 2860 016c 002B     		cmp	r3, #0
 2861 016e F8D0     		beq	.L669
 2862              	.L677:
 2863 0170 FFF7FEFF 		bl	protocol_exec_rt_suspend
 2864              	.LVL268:
 2865 0174 EAE7     		b	.L678
 2866              	.LVL269:
 2867              	.L857:
 2868              	.LBB90:
 2869              	.LBB87:
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 2870              		.loc 1 223 0
 2871 0176 4FF0010B 		mov	fp, #1
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 2872              		.loc 1 224 0
 2873 017a 5046     		mov	r0, r10
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 2874              		.loc 1 226 0
 2875 017c 0AF1FF3A 		add	r10, r10, #-1
 223:grbl/protocol.c ****     report_alarm_message(rt_exec);
 2876              		.loc 1 223 0
 2877 0180 84F800B0 		strb	fp, [r4]
 224:grbl/protocol.c ****     // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
 2878              		.loc 1 224 0
 2879 0184 FFF7FEFF 		bl	report_alarm_message
 2880              	.LVL270:
 226:grbl/protocol.c ****       report_feedback_message(MESSAGE_CRITICAL_EVENT);
 2881              		.loc 1 226 0
 2882 0188 DA45     		cmp	r10, fp
 2883 018a 40F2AA80 		bls	.L869
 2884              	.L672:
 237:grbl/protocol.c ****   }
 2885              		.loc 1 237 0
 2886 018e FFF7FEFF 		bl	system_clear_exec_alarm
 2887              	.LVL271:
 2888 0192 4BE7     		b	.L671
 2889              	.LVL272:
 2890              	.L728:
 2891              	.LBB80:
 435:grbl/protocol.c **** 
 2892              		.loc 1 435 0
 2893 0194 FFF7FEFF 		bl	system_clear_exec_accessory_overrides
 2894              	.LVL273:
 438:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
 2895              		.loc 1 438 0
 2896 0198 1AF0010F 		tst	r10, #1
 2897 019c 18BF     		it	ne
 2898 019e 6423     		movne	r3, #100
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 75


 2899 01a0 A27A     		ldrb	r2, [r4, #10]	@ zero_extendqisi2
 2900              	.LVL274:
 2901 01a2 08BF     		it	eq
 2902 01a4 1346     		moveq	r3, r2
 2903              	.LVL275:
 440:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCRE
 2904              		.loc 1 440 0
 2905 01a6 1AF0020F 		tst	r10, #2
 2906 01aa 1CBF     		itt	ne
 2907 01ac 0A33     		addne	r3, r3, #10
 2908              	.LVL276:
 2909 01ae DBB2     		uxtbne	r3, r3
 2910              	.LVL277:
 441:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT;
 2911              		.loc 1 441 0
 2912 01b0 1AF0040F 		tst	r10, #4
 2913 01b4 1CBF     		itt	ne
 2914 01b6 0A3B     		subne	r3, r3, #10
 2915              	.LVL278:
 2916 01b8 DBB2     		uxtbne	r3, r3
 2917              	.LVL279:
 442:grbl/protocol.c ****     if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT
 2918              		.loc 1 442 0
 2919 01ba 1AF0080F 		tst	r10, #8
 2920 01be 1CBF     		itt	ne
 2921 01c0 0133     		addne	r3, r3, #1
 2922              	.LVL280:
 2923 01c2 DBB2     		uxtbne	r3, r3
 2924              	.LVL281:
 443:grbl/protocol.c ****     last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
 2925              		.loc 1 443 0
 2926 01c4 1AF0100F 		tst	r10, #16
 2927 01c8 1CBF     		itt	ne
 2928 01ca 03F1FF33 		addne	r3, r3, #-1
 2929              	.LVL282:
 2930 01ce DBB2     		uxtbne	r3, r3
 2931              	.LVL283:
 445:grbl/protocol.c **** 
 2932              		.loc 1 445 0
 2933 01d0 C82B     		cmp	r3, #200
 2934 01d2 28BF     		it	cs
 2935 01d4 C823     		movcs	r3, #200
 2936              	.LVL284:
 2937 01d6 0A2B     		cmp	r3, #10
 2938 01d8 38BF     		it	cc
 2939 01da 0A23     		movcc	r3, #10
 2940              	.LVL285:
 447:grbl/protocol.c ****       bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
 2941              		.loc 1 447 0
 2942 01dc 9A42     		cmp	r2, r3
 2943 01de 06D0     		beq	.L735
 450:grbl/protocol.c ****     }
 2944              		.loc 1 450 0
 2945 01e0 0021     		movs	r1, #0
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 2946              		.loc 1 448 0
 2947 01e2 2279     		ldrb	r2, [r4, #4]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 76


 449:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 2948              		.loc 1 449 0
 2949 01e4 A372     		strb	r3, [r4, #10]
 448:grbl/protocol.c ****       sys.spindle_speed_ovr = last_s_override;
 2950              		.loc 1 448 0
 2951 01e6 42F00803 		orr	r3, r2, #8
 2952              	.LVL286:
 2953 01ea 2371     		strb	r3, [r4, #4]
 450:grbl/protocol.c ****     }
 2954              		.loc 1 450 0
 2955 01ec 2173     		strb	r1, [r4, #12]
 2956              	.LVL287:
 2957              	.L735:
 453:grbl/protocol.c ****       // Spindle stop override allowed only while in HOLD state.
 2958              		.loc 1 453 0
 2959 01ee 1AF0200F 		tst	r10, #32
 2960 01f2 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 2961 01f4 0AF0C002 		and	r2, r10, #192
 2962 01f8 0CD0     		beq	.L736
 456:grbl/protocol.c ****         if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
 2963              		.loc 1 456 0
 2964 01fa 102B     		cmp	r3, #16
 2965 01fc 0AD1     		bne	.L736
 457:grbl/protocol.c ****         else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE
 2966              		.loc 1 457 0
 2967 01fe E17A     		ldrb	r1, [r4, #11]	@ zero_extendqisi2
 2968 0200 0029     		cmp	r1, #0
 2969 0202 40F0C180 		bne	.L737
 2970 0206 0221     		movs	r1, #2
 2971 0208 E172     		strb	r1, [r4, #11]
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 2972              		.loc 1 464 0
 2973 020a 002A     		cmp	r2, #0
 2974 020c 76D1     		bne	.L738
 2975              	.L748:
 2976              	.LBE80:
 495:grbl/protocol.c ****   }
 2977              		.loc 1 495 0
 2978 020e FFF7FEFF 		bl	st_prep_buffer
 2979              	.LVL288:
 2980 0212 99E7     		b	.L739
 2981              	.L736:
 2982              	.LBB81:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 2983              		.loc 1 464 0
 2984 0214 002A     		cmp	r2, #0
 2985 0216 94D0     		beq	.L729
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 2986              		.loc 1 465 0
 2987 0218 002B     		cmp	r3, #0
 2988 021a 6FD1     		bne	.L738
 2989              	.L740:
 2990              	.LBB79:
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 2991              		.loc 1 468 0
 2992 021c 1AF0800F 		tst	r10, #128
 466:grbl/protocol.c ****         #ifdef ENABLE_M7
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 77


 2993              		.loc 1 466 0
 2994 0220 99F808B0 		ldrb	fp, [r9, #8]	@ zero_extendqisi2
 2995              	.LVL289:
 468:grbl/protocol.c ****             if (coolant_state & COOLANT_MIST_ENABLE) { bit_false(coolant_state,COOLANT_MIST_ENABLE)
 2996              		.loc 1 468 0
 2997 0224 06D0     		beq	.L744
 469:grbl/protocol.c ****             else { coolant_state |= COOLANT_MIST_ENABLE; }
 2998              		.loc 1 469 0
 2999 0226 1BF0800F 		tst	fp, #128
 3000 022a 14BF     		ite	ne
 3001 022c 0BF07F0B 		andne	fp, fp, #127
 3002              	.LVL290:
 470:grbl/protocol.c ****           }
 3003              		.loc 1 470 0
 3004 0230 4BF0800B 		orreq	fp, fp, #128
 3005              	.LVL291:
 3006              	.L744:
 472:grbl/protocol.c ****             if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABL
 3007              		.loc 1 472 0
 3008 0234 1AF0400F 		tst	r10, #64
 3009 0238 06D0     		beq	.L746
 473:grbl/protocol.c ****             else { coolant_state |= COOLANT_FLOOD_ENABLE; }
 3010              		.loc 1 473 0
 3011 023a 1BF0400F 		tst	fp, #64
 3012 023e 14BF     		ite	ne
 3013 0240 0BF0BF0B 		andne	fp, fp, #191
 3014              	.LVL292:
 474:grbl/protocol.c ****           }
 3015              		.loc 1 474 0
 3016 0244 4BF0400B 		orreq	fp, fp, #64
 3017              	.LVL293:
 3018              	.L746:
 480:grbl/protocol.c ****         gc_state.modal.coolant = coolant_state;
 3019              		.loc 1 480 0
 3020 0248 5846     		mov	r0, fp
 3021 024a FFF7FEFF 		bl	coolant_set_state
 3022              	.LVL294:
 3023 024e 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 481:grbl/protocol.c ****       }
 3024              		.loc 1 481 0
 3025 0250 89F808B0 		strb	fp, [r9, #8]
 3026 0254 75E7     		b	.L729
 3027              	.LVL295:
 3028              	.L868:
 3029              	.LBE79:
 3030              	.LBE81:
 3031              	.LBB82:
 408:grbl/protocol.c **** 
 3032              		.loc 1 408 0
 3033 0256 FFF7FEFF 		bl	system_clear_exec_motion_overrides
 3034              	.LVL296:
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 3035              		.loc 1 410 0
 3036 025a 1AF0010F 		tst	r10, #1
 3037 025e 18BF     		it	ne
 3038 0260 6423     		movne	r3, #100
 3039 0262 227A     		ldrb	r2, [r4, #8]	@ zero_extendqisi2
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 78


 3040              	.LVL297:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 3041              		.loc 1 419 0
 3042 0264 607A     		ldrb	r0, [r4, #9]	@ zero_extendqisi2
 410:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
 3043              		.loc 1 410 0
 3044 0266 08BF     		it	eq
 3045 0268 1346     		moveq	r3, r2
 3046              	.LVL298:
 412:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
 3047              		.loc 1 412 0
 3048 026a 1AF0020F 		tst	r10, #2
 3049 026e 1CBF     		itt	ne
 3050 0270 0A33     		addne	r3, r3, #10
 3051              	.LVL299:
 3052 0272 DBB2     		uxtbne	r3, r3
 3053              	.LVL300:
 413:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
 3054              		.loc 1 413 0
 3055 0274 1AF0040F 		tst	r10, #4
 3056 0278 1CBF     		itt	ne
 3057 027a 0A3B     		subne	r3, r3, #10
 3058              	.LVL301:
 3059 027c DBB2     		uxtbne	r3, r3
 3060              	.LVL302:
 414:grbl/protocol.c ****     if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
 3061              		.loc 1 414 0
 3062 027e 1AF0080F 		tst	r10, #8
 3063 0282 1CBF     		itt	ne
 3064 0284 0133     		addne	r3, r3, #1
 3065              	.LVL303:
 3066 0286 DBB2     		uxtbne	r3, r3
 3067              	.LVL304:
 415:grbl/protocol.c ****     new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
 3068              		.loc 1 415 0
 3069 0288 1AF0100F 		tst	r10, #16
 3070 028c 1CBF     		itt	ne
 3071 028e 03F1FF33 		addne	r3, r3, #-1
 3072              	.LVL305:
 3073 0292 DBB2     		uxtbne	r3, r3
 3074              	.LVL306:
 417:grbl/protocol.c **** 
 3075              		.loc 1 417 0
 3076 0294 C82B     		cmp	r3, #200
 3077 0296 28BF     		it	cs
 3078 0298 C823     		movcs	r3, #200
 3079              	.LVL307:
 3080 029a 0A2B     		cmp	r3, #10
 3081 029c 38BF     		it	cc
 3082 029e 0A23     		movcc	r3, #10
 3083              	.LVL308:
 419:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
 3084              		.loc 1 419 0
 3085 02a0 1AF0200F 		tst	r10, #32
 3086 02a4 14BF     		ite	ne
 3087 02a6 6421     		movne	r1, #100
 3088 02a8 0146     		moveq	r1, r0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 79


 3089              	.LVL309:
 421:grbl/protocol.c ****     if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
 3090              		.loc 1 421 0
 3091 02aa 1AF0400F 		tst	r10, #64
 3092 02ae 18BF     		it	ne
 3093 02b0 3221     		movne	r1, #50
 3094              	.LVL310:
 422:grbl/protocol.c **** 
 3095              		.loc 1 422 0
 3096 02b2 1AF0800F 		tst	r10, #128
 3097 02b6 18BF     		it	ne
 3098 02b8 1921     		movne	r1, #25
 3099              	.LVL311:
 424:grbl/protocol.c ****       sys.f_override = new_f_override;
 3100              		.loc 1 424 0
 3101 02ba 9A42     		cmp	r2, r3
 3102 02bc 02D1     		bne	.L726
 3103 02be 8842     		cmp	r0, r1
 3104 02c0 3FF43AAF 		beq	.L717
 3105              	.L726:
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 3106              		.loc 1 427 0
 3107 02c4 0022     		movs	r2, #0
 425:grbl/protocol.c ****       sys.r_override = new_r_override;
 3108              		.loc 1 425 0
 3109 02c6 2372     		strb	r3, [r4, #8]
 426:grbl/protocol.c ****       sys.report_ovr_counter = 0; // Set to report change immediately
 3110              		.loc 1 426 0
 3111 02c8 6172     		strb	r1, [r4, #9]
 427:grbl/protocol.c ****       plan_update_velocity_profile_parameters();
 3112              		.loc 1 427 0
 3113 02ca 2273     		strb	r2, [r4, #12]
 428:grbl/protocol.c ****       plan_cycle_reinitialize();
 3114              		.loc 1 428 0
 3115 02cc FFF7FEFF 		bl	plan_update_velocity_profile_parameters
 3116              	.LVL312:
 429:grbl/protocol.c ****     }
 3117              		.loc 1 429 0
 3118 02d0 FFF7FEFF 		bl	plan_cycle_reinitialize
 3119              	.LVL313:
 3120 02d4 30E7     		b	.L717
 3121              	.LVL314:
 3122              	.L859:
 3123              	.LBE82:
 251:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_STATUS_REPORT);
 3124              		.loc 1 251 0
 3125 02d6 FFF7FEFF 		bl	report_realtime_status
 3126              	.LVL315:
 252:grbl/protocol.c ****     }
 3127              		.loc 1 252 0
 3128 02da 0120     		movs	r0, #1
 3129 02dc FFF7FEFF 		bl	system_clear_exec_state_flag
 3130              	.LVL316:
 3131 02e0 B1E6     		b	.L679
 3132              	.L869:
 227:grbl/protocol.c ****       system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
 3133              		.loc 1 227 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 80


 3134 02e2 5846     		mov	r0, fp
 3135 02e4 FFF7FEFF 		bl	report_feedback_message
 3136              	.LVL317:
 228:grbl/protocol.c ****       do {
 3137              		.loc 1 228 0
 3138 02e8 1020     		movs	r0, #16
 3139 02ea FFF7FEFF 		bl	system_clear_exec_state_flag
 3140              	.LVL318:
 3141              	.L673:
 235:grbl/protocol.c ****     }
 3142              		.loc 1 235 0
 3143 02ee 2B78     		ldrb	r3, [r5]	@ zero_extendqisi2
 3144 02f0 D906     		lsls	r1, r3, #27
 3145 02f2 FCD5     		bpl	.L673
 3146 02f4 4BE7     		b	.L672
 3147              	.L715:
 397:grbl/protocol.c ****           sys.state = STATE_IDLE;
 3148              		.loc 1 397 0
 3149 02f6 A270     		strb	r2, [r4, #2]
 398:grbl/protocol.c ****         }
 3150              		.loc 1 398 0
 3151 02f8 2270     		strb	r2, [r4]
 3152 02fa 13E7     		b	.L713
 3153              	.L738:
 3154              	.LBB83:
 465:grbl/protocol.c ****         uint8_t coolant_state = gc_state.modal.coolant;
 3155              		.loc 1 465 0
 3156 02fc 13F0180F 		tst	r3, #24
 3157 0300 3FF41FAF 		beq	.L729
 3158 0304 8AE7     		b	.L740
 3159              	.L874:
 3160 0306 00BF     		.align	2
 3161              	.L873:
 3162 0308 00000000 		.word	sys_rt_exec_alarm
 3163 030c 00000000 		.word	sys
 3164 0310 00000000 		.word	sys_rt_exec_state
 3165 0314 00000000 		.word	sys_rt_exec_accessory_override
 3166 0318 00000000 		.word	sys_rt_exec_motion_override
 3167 031c 00000000 		.word	gc_state
 3168              	.L863:
 3169              	.LBE83:
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 3170              		.loc 1 323 0
 3171 0320 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 3172 0322 012B     		cmp	r3, #1
 3173 0324 3ED0     		beq	.L870
 324:grbl/protocol.c ****       }
 3174              		.loc 1 324 0
 3175 0326 8023     		movs	r3, #128
 3176 0328 2370     		strb	r3, [r4]
 3177 032a C0E6     		b	.L697
 3178              	.L860:
 265:grbl/protocol.c ****             sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active fla
 3179              		.loc 1 265 0
 3180 032c FFF7FEFF 		bl	st_update_plan_block_parameters
 3181              	.LVL319:
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 81


 3182              		.loc 1 266 0
 3183 0330 0222     		movs	r2, #2
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 3184              		.loc 1 267 0
 3185 0332 2378     		ldrb	r3, [r4]	@ zero_extendqisi2
 266:grbl/protocol.c ****             if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping
 3186              		.loc 1 266 0
 3187 0334 2271     		strb	r2, [r4, #4]
 267:grbl/protocol.c ****               if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
 3188              		.loc 1 267 0
 3189 0336 202B     		cmp	r3, #32
 3190 0338 7DD0     		beq	.L871
 3191              	.L683:
 3192 033a 0AF04002 		and	r2, r10, #64
 3193 033e 0AF00801 		and	r1, r10, #8
 273:grbl/protocol.c **** 
 3194              		.loc 1 273 0
 3195 0342 002B     		cmp	r3, #0
 3196 0344 7FF494AE 		bne	.L686
 3197 0348 0120     		movs	r0, #1
 3198 034a A070     		strb	r0, [r4, #2]
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 3199              		.loc 1 277 0
 3200 034c 3ABB     		cbnz	r2, .L753
 285:grbl/protocol.c ****           // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
 3201              		.loc 1 285 0
 3202 034e 0029     		cmp	r1, #0
 3203 0350 3FF496AE 		beq	.L691
 3204              	.L751:
 287:grbl/protocol.c ****         }
 3205              		.loc 1 287 0
 3206 0354 1023     		movs	r3, #16
 3207 0356 2370     		strb	r3, [r4]
 3208 0358 92E6     		b	.L691
 3209              	.L867:
 376:grbl/protocol.c ****         // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until use
 3210              		.loc 1 376 0
 3211 035a 0029     		cmp	r1, #0
 3212 035c 29DA     		bge	.L872
 3213              	.L711:
 386:grbl/protocol.c ****           plan_reset();
 3214              		.loc 1 386 0
 3215 035e 0023     		movs	r3, #0
 3216 0360 2371     		strb	r3, [r4, #4]
 387:grbl/protocol.c ****           st_reset();
 3217              		.loc 1 387 0
 3218 0362 FFF7FEFF 		bl	plan_reset
 3219              	.LVL320:
 388:grbl/protocol.c ****           gc_sync_position();
 3220              		.loc 1 388 0
 3221 0366 FFF7FEFF 		bl	st_reset
 3222              	.LVL321:
 389:grbl/protocol.c ****           plan_sync_position();
 3223              		.loc 1 389 0
 3224 036a FFF7FEFF 		bl	gc_sync_position
 3225              	.LVL322:
 390:grbl/protocol.c ****         }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 82


 3226              		.loc 1 390 0
 3227 036e FFF7FEFF 		bl	plan_sync_position
 3228              	.LVL323:
 3229 0372 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 3230 0374 CBE6     		b	.L714
 3231              	.L864:
 336:grbl/protocol.c ****           if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
 3232              		.loc 1 336 0
 3233 0376 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 3234 0378 13F02002 		ands	r2, r3, #32
 3235 037c 7FF4B4AE 		bne	.L701
 337:grbl/protocol.c ****             sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
 3236              		.loc 1 337 0
 3237 0380 D906     		lsls	r1, r3, #27
 3238 0382 51D5     		bpl	.L704
 338:grbl/protocol.c ****           } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
 3239              		.loc 1 338 0
 3240 0384 2270     		strb	r2, [r4]
 3241 0386 A2E6     		b	.L705
 3242              	.L737:
 3243              	.LBB84:
 458:grbl/protocol.c ****       }
 3244              		.loc 1 458 0
 3245 0388 C807     		lsls	r0, r1, #31
 3246 038a 02D5     		bpl	.L741
 3247 038c 41F00401 		orr	r1, r1, #4
 3248 0390 E172     		strb	r1, [r4, #11]
 3249              	.L741:
 464:grbl/protocol.c ****       if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD))) {
 3250              		.loc 1 464 0
 3251 0392 002A     		cmp	r2, #0
 3252 0394 7FF442AF 		bne	.L740
 3253              	.LBE84:
 495:grbl/protocol.c ****   }
 3254              		.loc 1 495 0
 3255 0398 FFF7FEFF 		bl	st_prep_buffer
 3256              	.LVL324:
 3257 039c D4E6     		b	.L739
 3258              	.L753:
 277:grbl/protocol.c ****           // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiate
 3259              		.loc 1 277 0
 3260 039e 4122     		movs	r2, #65
 281:grbl/protocol.c ****         }
 3261              		.loc 1 281 0
 3262 03a0 A270     		strb	r2, [r4, #2]
 3263 03a2 68E6     		b	.L689
 3264              	.L870:
 323:grbl/protocol.c ****         sys.state = STATE_SLEEP; 
 3265              		.loc 1 323 0
 3266 03a4 A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 3267 03a6 43F00503 		orr	r3, r3, #5
 3268 03aa A370     		strb	r3, [r4, #2]
 324:grbl/protocol.c ****       }
 3269              		.loc 1 324 0
 3270 03ac 8023     		movs	r3, #128
 3271 03ae 2370     		strb	r3, [r4]
 3272 03b0 7DE6     		b	.L697
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 83


 3273              	.L872:
 379:grbl/protocol.c ****         if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
 3274              		.loc 1 379 0
 3275 03b2 FFF7FEFF 		bl	plan_cycle_reinitialize
 3276              	.LVL325:
 380:grbl/protocol.c ****         bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
 3277              		.loc 1 380 0
 3278 03b6 2379     		ldrb	r3, [r4, #4]	@ zero_extendqisi2
 3279 03b8 9A07     		lsls	r2, r3, #30
 3280 03ba 03D5     		bpl	.L712
 3281 03bc A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 3282 03be 42F00102 		orr	r2, r2, #1
 3283 03c2 A270     		strb	r2, [r4, #2]
 3284              	.L712:
 381:grbl/protocol.c ****       } else {
 3285              		.loc 1 381 0
 3286 03c4 23F00603 		bic	r3, r3, #6
 3287 03c8 2371     		strb	r3, [r4, #4]
 3288 03ca ABE6     		b	.L713
 3289              	.L861:
 281:grbl/protocol.c ****         }
 3290              		.loc 1 281 0
 3291 03cc 9806     		lsls	r0, r3, #26
 3292 03ce 3FF552AE 		bmi	.L689
 3293 03d2 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 3294 03d4 42F04002 		orr	r2, r2, #64
 3295 03d8 A270     		strb	r2, [r4, #2]
 3296 03da 4CE6     		b	.L689
 3297              	.L866:
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 3298              		.loc 1 357 0
 3299 03dc 0822     		movs	r2, #8
 356:grbl/protocol.c ****               sys.state = STATE_CYCLE;
 3300              		.loc 1 356 0
 3301 03de A370     		strb	r3, [r4, #2]
 357:grbl/protocol.c ****               st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
 3302              		.loc 1 357 0
 3303 03e0 2270     		strb	r2, [r4]
 358:grbl/protocol.c ****               st_wake_up();
 3304              		.loc 1 358 0
 3305 03e2 FFF7FEFF 		bl	st_prep_buffer
 3306              	.LVL326:
 359:grbl/protocol.c ****             } else { // Otherwise, do nothing. Set and resume IDLE state.
 3307              		.loc 1 359 0
 3308 03e6 FFF7FEFF 		bl	st_wake_up
 3309              	.LVL327:
 3310 03ea 7DE6     		b	.L701
 3311              	.L862:
 300:grbl/protocol.c ****                 #ifdef PARKING_ENABLE
 3312              		.loc 1 300 0
 3313 03ec 1807     		lsls	r0, r3, #28
 3314 03ee 03D5     		bpl	.L696
 309:grbl/protocol.c ****                 sys.suspend |= SUSPEND_RESTART_RETRACT;
 3315              		.loc 1 309 0
 3316 03f0 23F01C03 		bic	r3, r3, #28
 310:grbl/protocol.c ****               }
 3317              		.loc 1 310 0
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 84


 3318 03f4 43F00203 		orr	r3, r3, #2
 3319              	.L696:
 313:grbl/protocol.c ****           }
 3320              		.loc 1 313 0
 3321 03f8 4022     		movs	r2, #64
 3322 03fa 2270     		strb	r2, [r4]
 3323 03fc 50E6     		b	.L694
 3324              	.L865:
 349:grbl/protocol.c ****           if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
 3325              		.loc 1 349 0
 3326 03fe DA06     		lsls	r2, r3, #27
 3327 0400 7FF572AE 		bpl	.L701
 3328 0404 A278     		ldrb	r2, [r4, #2]	@ zero_extendqisi2
 3329 0406 D107     		lsls	r1, r2, #31
 3330 0408 7FF56EAE 		bpl	.L701
 350:grbl/protocol.c ****             sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend ro
 3331              		.loc 1 350 0
 3332 040c 102B     		cmp	r3, #16
 3333 040e 7FF45EAE 		bne	.L705
 3334 0412 E37A     		ldrb	r3, [r4, #11]	@ zero_extendqisi2
 3335 0414 002B     		cmp	r3, #0
 3336 0416 3FF45AAE 		beq	.L705
 351:grbl/protocol.c ****           } else {
 3337              		.loc 1 351 0
 3338 041a 43F00803 		orr	r3, r3, #8
 367:grbl/protocol.c ****     }
 3339              		.loc 1 367 0
 3340 041e 0220     		movs	r0, #2
 351:grbl/protocol.c ****           } else {
 3341              		.loc 1 351 0
 3342 0420 E372     		strb	r3, [r4, #11]
 367:grbl/protocol.c ****     }
 3343              		.loc 1 367 0
 3344 0422 FFF7FEFF 		bl	system_clear_exec_state_flag
 3345              	.LVL328:
 3346 0426 62E6     		b	.L699
 3347              	.L704:
 339:grbl/protocol.c ****             // Flag to re-energize powered components and restore original position, if disabled by
 3348              		.loc 1 339 0
 3349 0428 5807     		lsls	r0, r3, #29
 3350 042a 7FF55DAE 		bpl	.L701
 345:grbl/protocol.c ****           }
 3351              		.loc 1 345 0
 3352 042e 43F00803 		orr	r3, r3, #8
 3353 0432 A370     		strb	r3, [r4, #2]
 3354 0434 58E6     		b	.L701
 3355              	.L871:
 268:grbl/protocol.c ****             }
 3356              		.loc 1 268 0
 3357 0436 BBF1000F 		cmp	fp, #0
 3358 043a FFF621AE 		blt	.L691
 3359 043e A378     		ldrb	r3, [r4, #2]	@ zero_extendqisi2
 3360 0440 63F07F03 		orn	r3, r3, #127
 3361 0444 A370     		strb	r3, [r4, #2]
 3362 0446 1BE6     		b	.L691
 3363              	.LBE87:
 3364              	.LBE90:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 85


 3365              	.LBE91:
 3366              	.LBE92:
 3367              		.cfi_endproc
 3368              	.LFE704:
 3370              		.section	.text.protocol_main_loop,"ax",%progbits
 3371              		.align	1
 3372              		.p2align 2,,3
 3373              		.global	protocol_main_loop
 3374              		.syntax unified
 3375              		.thumb
 3376              		.thumb_func
 3377              		.fpu softvfp
 3379              	protocol_main_loop:
 3380              	.LFB703:
  39:grbl/protocol.c ****   // Perform some machine checks to make sure everything is good to go.
 3381              		.loc 1 39 0
 3382              		.cfi_startproc
 3383              		@ args = 0, pretend = 0, frame = 0
 3384              		@ frame_needed = 0, uses_anonymous_args = 0
 3385 0000 F8B5     		push	{r3, r4, r5, r6, r7, lr}
 3386              	.LCFI14:
 3387              		.cfi_def_cfa_offset 24
 3388              		.cfi_offset 3, -24
 3389              		.cfi_offset 4, -20
 3390              		.cfi_offset 5, -16
 3391              		.cfi_offset 6, -12
 3392              		.cfi_offset 7, -8
 3393              		.cfi_offset 14, -4
  42:grbl/protocol.c ****       if (limits_get_state()) {
 3394              		.loc 1 42 0
 3395 0002 544B     		ldr	r3, .L937
 3396 0004 93F84830 		ldrb	r3, [r3, #72]	@ zero_extendqisi2
 3397 0008 1A07     		lsls	r2, r3, #28
 3398 000a 00F18980 		bmi	.L876
 3399              	.L928:
 3400 000e 524E     		ldr	r6, .L937+4
 3401              	.L877:
  52:grbl/protocol.c ****     report_feedback_message(MESSAGE_ALARM_LOCK);
 3402              		.loc 1 52 0
 3403 0010 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3404 0012 13F08103 		ands	r3, r3, #129
 3405 0016 6DD0     		beq	.L879
  53:grbl/protocol.c ****     sys.state = STATE_ALARM; // Ensure alarm state is set.
 3406              		.loc 1 53 0
 3407 0018 0220     		movs	r0, #2
 3408 001a FFF7FEFF 		bl	report_feedback_message
 3409              	.LVL329:
  54:grbl/protocol.c ****   } else {
 3410              		.loc 1 54 0
 3411 001e 0123     		movs	r3, #1
 3412 0020 3370     		strb	r3, [r6]
 3413              	.L884:
 108:grbl/protocol.c ****         char_counter = 0;
 3414              		.loc 1 108 0
 3415 0022 0025     		movs	r5, #0
 3416 0024 2C46     		mov	r4, r5
  84:grbl/protocol.c ****         #ifdef REPORT_ECHO_LINE_RECEIVED
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 86


 3417              		.loc 1 84 0
 3418 0026 4D4F     		ldr	r7, .L937+8
 3419              	.L880:
 3420              	.LVL330:
  78:grbl/protocol.c ****       if ((c == '\n') || (c == '\r')) { // End of line reached
 3421              		.loc 1 78 0
 3422 0028 FFF7FEFF 		bl	serial_read
 3423              	.LVL331:
 3424 002c FF28     		cmp	r0, #255
 3425 002e 0ED0     		beq	.L929
 3426              	.L896:
  79:grbl/protocol.c **** 
 3427              		.loc 1 79 0
 3428 0030 0A28     		cmp	r0, #10
 3429 0032 1AD0     		beq	.L885
  79:grbl/protocol.c **** 
 3430              		.loc 1 79 0 is_stmt 0 discriminator 1
 3431 0034 0D28     		cmp	r0, #13
 3432 0036 18D0     		beq	.L885
 113:grbl/protocol.c ****           // Throw away all (except EOL) comment characters and overflow characters.
 3433              		.loc 1 113 0 is_stmt 1
 3434 0038 7CB3     		cbz	r4, .L894
 115:grbl/protocol.c ****             // End of '()' comment. Resume line allowed.
 3435              		.loc 1 115 0
 3436 003a 2928     		cmp	r0, #41
 3437 003c F4D1     		bne	.L880
 117:grbl/protocol.c ****           }
 3438              		.loc 1 117 0
 3439 003e A307     		lsls	r3, r4, #30
 3440 0040 F2D5     		bpl	.L880
  78:grbl/protocol.c ****       if ((c == '\n') || (c == '\r')) { // End of line reached
 3441              		.loc 1 78 0 discriminator 1
 3442 0042 FFF7FEFF 		bl	serial_read
 3443              	.LVL332:
 3444 0046 FF28     		cmp	r0, #255
 117:grbl/protocol.c ****           }
 3445              		.loc 1 117 0 discriminator 1
 3446 0048 04F0FD04 		and	r4, r4, #253
 3447              	.LVL333:
  78:grbl/protocol.c ****       if ((c == '\n') || (c == '\r')) { // End of line reached
 3448              		.loc 1 78 0 discriminator 1
 3449 004c F0D1     		bne	.L896
 3450              	.L929:
 3451              	.LBB101:
 3452              	.LBB102:
 188:grbl/protocol.c ****     system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
 3453              		.loc 1 188 0
 3454 004e FFF7FEFF 		bl	plan_get_current_block
 3455              	.LVL334:
 3456 0052 10B1     		cbz	r0, .L897
 189:grbl/protocol.c ****   }
 3457              		.loc 1 189 0
 3458 0054 0220     		movs	r0, #2
 3459 0056 FFF7FEFF 		bl	system_set_exec_state_flag
 3460              	.LVL335:
 3461              	.L897:
 3462              	.LBE102:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 87


 3463              	.LBE101:
 3464              	.LBB103:
 3465              	.LBB104:
 207:grbl/protocol.c ****   if (sys.suspend) { protocol_exec_rt_suspend(); }
 3466              		.loc 1 207 0
 3467 005a FFF7FEFF 		bl	protocol_exec_rt_system
 3468              	.LVL336:
 208:grbl/protocol.c **** }
 3469              		.loc 1 208 0
 3470 005e B378     		ldrb	r3, [r6, #2]	@ zero_extendqisi2
 3471 0060 ABBB     		cbnz	r3, .L930
 3472              	.L898:
 3473              	.LBE104:
 3474              	.LBE103:
 160:grbl/protocol.c ****   }
 3475              		.loc 1 160 0
 3476 0062 7378     		ldrb	r3, [r6, #1]	@ zero_extendqisi2
 3477 0064 002B     		cmp	r3, #0
 3478 0066 DFD0     		beq	.L880
 3479              	.L875:
 164:grbl/protocol.c **** 
 3480              		.loc 1 164 0
 3481 0068 F8BD     		pop	{r3, r4, r5, r6, r7, pc}
 3482              	.LVL337:
 3483              	.L885:
 3484              	.LBB106:
 3485              	.LBB107:
 207:grbl/protocol.c ****   if (sys.suspend) { protocol_exec_rt_suspend(); }
 3486              		.loc 1 207 0
 3487 006a FFF7FEFF 		bl	protocol_exec_rt_system
 3488              	.LVL338:
 208:grbl/protocol.c **** }
 3489              		.loc 1 208 0
 3490 006e B378     		ldrb	r3, [r6, #2]	@ zero_extendqisi2
 3491 0070 FBB9     		cbnz	r3, .L931
 3492              	.L887:
 3493              	.LBE107:
 3494              	.LBE106:
  82:grbl/protocol.c **** 
 3495              		.loc 1 82 0
 3496 0072 7378     		ldrb	r3, [r6, #1]	@ zero_extendqisi2
 3497 0074 002B     		cmp	r3, #0
 3498 0076 F7D1     		bne	.L875
  90:grbl/protocol.c ****           // Report line overflow error.
 3499              		.loc 1 90 0
 3500 0078 14F00104 		ands	r4, r4, #1
 3501              	.LVL339:
  84:grbl/protocol.c ****         #ifdef REPORT_ECHO_LINE_RECEIVED
 3502              		.loc 1 84 0
 3503 007c 7B55     		strb	r3, [r7, r5]
  90:grbl/protocol.c ****           // Report line overflow error.
 3504              		.loc 1 90 0
 3505 007e 1BD1     		bne	.L932
  93:grbl/protocol.c ****           // Empty or comment line. For syncing purposes.
 3506              		.loc 1 93 0
 3507 0080 3878     		ldrb	r0, [r7]	@ zero_extendqisi2
 3508 0082 F8B1     		cbz	r0, .L933
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 88


  96:grbl/protocol.c ****           // Grbl '$' system command
 3509              		.loc 1 96 0
 3510 0084 2428     		cmp	r0, #36
 3511 0086 2CD0     		beq	.L934
  99:grbl/protocol.c ****           // Everything else is gcode. Block if in alarm or jog mode.
 3512              		.loc 1 99 0
 3513 0088 3378     		ldrb	r3, [r6]	@ zero_extendqisi2
 3514 008a 13F02105 		ands	r5, r3, #33
 3515              	.LVL340:
 3516 008e 21D0     		beq	.L893
 101:grbl/protocol.c ****         } else {
 3517              		.loc 1 101 0
 3518 0090 0920     		movs	r0, #9
 109:grbl/protocol.c **** 
 3519              		.loc 1 109 0
 3520 0092 2546     		mov	r5, r4
 101:grbl/protocol.c ****         } else {
 3521              		.loc 1 101 0
 3522 0094 FFF7FEFF 		bl	report_status_message
 3523              	.LVL341:
 3524 0098 C6E7     		b	.L880
 3525              	.LVL342:
 3526              	.L894:
 120:grbl/protocol.c ****             // Throw away whitepace and control characters
 3527              		.loc 1 120 0
 3528 009a 2028     		cmp	r0, #32
 3529 009c C4D9     		bls	.L880
 122:grbl/protocol.c ****             // Block delete NOT SUPPORTED. Ignore character.
 3530              		.loc 1 122 0
 3531 009e 2F28     		cmp	r0, #47
 3532 00a0 C2D0     		beq	.L880
 125:grbl/protocol.c ****             // Enable comments flag and ignore all characters until ')' or EOL.
 3533              		.loc 1 125 0
 3534 00a2 2828     		cmp	r0, #40
 3535 00a4 24D0     		beq	.L900
 131:grbl/protocol.c ****             // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
 3536              		.loc 1 131 0
 3537 00a6 3B28     		cmp	r0, #59
 3538 00a8 38D0     		beq	.L901
 141:grbl/protocol.c ****             // Detect line buffer overflow and set flag.
 3539              		.loc 1 141 0
 3540 00aa 4E2D     		cmp	r5, #78
 3541 00ac 2AD9     		bls	.L935
 143:grbl/protocol.c ****           } else if (c >= 'a' && c <= 'z') { // Upcase lowercase
 3542              		.loc 1 143 0
 3543 00ae 0124     		movs	r4, #1
 3544              	.LVL343:
 3545 00b0 BAE7     		b	.L880
 3546              	.LVL344:
 3547              	.L931:
 3548              	.LBB109:
 3549              	.LBB108:
 208:grbl/protocol.c **** }
 3550              		.loc 1 208 0
 3551 00b2 FFF7FEFF 		bl	protocol_exec_rt_suspend
 3552              	.LVL345:
 3553 00b6 DCE7     		b	.L887
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 89


 3554              	.LVL346:
 3555              	.L932:
 3556              	.LBE108:
 3557              	.LBE109:
  92:grbl/protocol.c ****         } else if (line[0] == 0) {
 3558              		.loc 1 92 0
 3559 00b8 0B20     		movs	r0, #11
 109:grbl/protocol.c **** 
 3560              		.loc 1 109 0
 3561 00ba 1D46     		mov	r5, r3
 3562              	.LVL347:
 108:grbl/protocol.c ****         char_counter = 0;
 3563              		.loc 1 108 0
 3564 00bc 1C46     		mov	r4, r3
  92:grbl/protocol.c ****         } else if (line[0] == 0) {
 3565              		.loc 1 92 0
 3566 00be FFF7FEFF 		bl	report_status_message
 3567              	.LVL348:
 3568 00c2 B1E7     		b	.L880
 3569              	.LVL349:
 3570              	.L933:
 109:grbl/protocol.c **** 
 3571              		.loc 1 109 0
 3572 00c4 0546     		mov	r5, r0
 3573              	.LVL350:
  95:grbl/protocol.c ****         } else if (line[0] == '$') {
 3574              		.loc 1 95 0
 3575 00c6 FFF7FEFF 		bl	report_status_message
 3576              	.LVL351:
 108:grbl/protocol.c ****         char_counter = 0;
 3577              		.loc 1 108 0
 3578 00ca 2C46     		mov	r4, r5
 3579 00cc ACE7     		b	.L880
 3580              	.LVL352:
 3581              	.L930:
 3582              	.LBB110:
 3583              	.LBB105:
 208:grbl/protocol.c **** }
 3584              		.loc 1 208 0
 3585 00ce FFF7FEFF 		bl	protocol_exec_rt_suspend
 3586              	.LVL353:
 3587 00d2 C6E7     		b	.L898
 3588              	.LVL354:
 3589              	.L893:
 3590              	.LBE105:
 3591              	.LBE110:
 104:grbl/protocol.c ****         }
 3592              		.loc 1 104 0
 3593 00d4 3846     		mov	r0, r7
 3594 00d6 FFF7FEFF 		bl	gc_execute_line
 3595              	.LVL355:
 3596 00da FFF7FEFF 		bl	report_status_message
 3597              	.LVL356:
 108:grbl/protocol.c ****         char_counter = 0;
 3598              		.loc 1 108 0
 3599 00de 2C46     		mov	r4, r5
 3600 00e0 A2E7     		b	.L880
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 90


 3601              	.LVL357:
 3602              	.L934:
  98:grbl/protocol.c ****         } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
 3603              		.loc 1 98 0
 3604 00e2 3846     		mov	r0, r7
 109:grbl/protocol.c **** 
 3605              		.loc 1 109 0
 3606 00e4 2546     		mov	r5, r4
 3607              	.LVL358:
  98:grbl/protocol.c ****         } else if (sys.state & (STATE_ALARM | STATE_JOG)) {
 3608              		.loc 1 98 0
 3609 00e6 FFF7FEFF 		bl	system_execute_line
 3610              	.LVL359:
 3611 00ea FFF7FEFF 		bl	report_status_message
 3612              	.LVL360:
 3613 00ee 9BE7     		b	.L880
 3614              	.LVL361:
 3615              	.L900:
 130:grbl/protocol.c ****           } else if (c == ';') {
 3616              		.loc 1 130 0
 3617 00f0 0224     		movs	r4, #2
 3618              	.LVL362:
 3619 00f2 99E7     		b	.L880
 3620              	.LVL363:
 3621              	.L879:
  57:grbl/protocol.c ****     if (system_check_safety_door_ajar()) {
 3622              		.loc 1 57 0
 3623 00f4 3370     		strb	r3, [r6]
  58:grbl/protocol.c ****       bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
 3624              		.loc 1 58 0
 3625 00f6 FFF7FEFF 		bl	system_check_safety_door_ajar
 3626              	.LVL364:
 3627 00fa E8B9     		cbnz	r0, .L936
 3628              	.L882:
  63:grbl/protocol.c ****   }
 3629              		.loc 1 63 0
 3630 00fc 1748     		ldr	r0, .L937+8
 3631 00fe FFF7FEFF 		bl	system_execute_startup
 3632              	.LVL365:
 3633 0102 8EE7     		b	.L884
 3634              	.LVL366:
 3635              	.L935:
 3636 0104 2946     		mov	r1, r5
 144:grbl/protocol.c ****             line[char_counter++] = c-'a'+'A';
 3637              		.loc 1 144 0
 3638 0106 A0F16103 		sub	r3, r0, #97
 3639 010a DBB2     		uxtb	r3, r3
 3640 010c 192B     		cmp	r3, #25
 3641 010e 05F10102 		add	r2, r5, #1
 145:grbl/protocol.c ****           } else {
 3642              		.loc 1 145 0
 3643 0112 98BF     		it	ls
 3644 0114 2038     		subls	r0, r0, #32
 3645              	.LVL367:
 3646 0116 D5B2     		uxtb	r5, r2
 3647              	.LVL368:
 147:grbl/protocol.c ****           }
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 91


 3648              		.loc 1 147 0
 3649 0118 7854     		strb	r0, [r7, r1]
 3650 011a 85E7     		b	.L880
 3651              	.LVL369:
 3652              	.L901:
 133:grbl/protocol.c ****           // TODO: Install '%' feature
 3653              		.loc 1 133 0
 3654 011c 0424     		movs	r4, #4
 3655              	.LVL370:
 3656 011e 83E7     		b	.L880
 3657              	.LVL371:
 3658              	.L876:
  43:grbl/protocol.c ****         sys.state = STATE_ALARM; // Ensure alarm state is active.
 3659              		.loc 1 43 0
 3660 0120 FFF7FEFF 		bl	limits_get_state
 3661              	.LVL372:
 3662 0124 0028     		cmp	r0, #0
 3663 0126 3FF472AF 		beq	.L928
  44:grbl/protocol.c ****         report_feedback_message(MESSAGE_CHECK_LIMITS);
 3664              		.loc 1 44 0
 3665 012a 0123     		movs	r3, #1
 3666 012c 0A4E     		ldr	r6, .L937+4
  45:grbl/protocol.c ****       }
 3667              		.loc 1 45 0
 3668 012e 0720     		movs	r0, #7
  44:grbl/protocol.c ****         report_feedback_message(MESSAGE_CHECK_LIMITS);
 3669              		.loc 1 44 0
 3670 0130 3370     		strb	r3, [r6]
  45:grbl/protocol.c ****       }
 3671              		.loc 1 45 0
 3672 0132 FFF7FEFF 		bl	report_feedback_message
 3673              	.LVL373:
 3674 0136 6BE7     		b	.L877
 3675              	.L936:
  59:grbl/protocol.c ****       protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
 3676              		.loc 1 59 0
 3677 0138 094A     		ldr	r2, .L937+12
 3678 013a 1378     		ldrb	r3, [r2]	@ zero_extendqisi2
 3679 013c 43F02003 		orr	r3, r3, #32
 3680 0140 1370     		strb	r3, [r2]
 3681              	.LBB111:
 3682              	.LBB112:
 207:grbl/protocol.c ****   if (sys.suspend) { protocol_exec_rt_suspend(); }
 3683              		.loc 1 207 0
 3684 0142 FFF7FEFF 		bl	protocol_exec_rt_system
 3685              	.LVL374:
 208:grbl/protocol.c **** }
 3686              		.loc 1 208 0
 3687 0146 B378     		ldrb	r3, [r6, #2]	@ zero_extendqisi2
 3688 0148 002B     		cmp	r3, #0
 3689 014a D7D0     		beq	.L882
 3690 014c FFF7FEFF 		bl	protocol_exec_rt_suspend
 3691              	.LVL375:
 3692 0150 D4E7     		b	.L882
 3693              	.L938:
 3694 0152 00BF     		.align	2
 3695              	.L937:
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 92


 3696 0154 00000000 		.word	settings
 3697 0158 00000000 		.word	sys
 3698 015c 00000000 		.word	.LANCHOR0
 3699 0160 00000000 		.word	sys_rt_exec_state
 3700              	.LBE112:
 3701              	.LBE111:
 3702              		.cfi_endproc
 3703              	.LFE703:
 3705              		.section	.bss.line,"aw",%nobits
 3706              		.align	2
 3707              		.set	.LANCHOR0,. + 0
 3710              	line:
 3711 0000 00000000 		.space	80
 3711      00000000 
 3711      00000000 
 3711      00000000 
 3711      00000000 
 3712              		.text
 3713              	.Letext0:
 3714              		.file 2 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/machine/_default_types
 3715              		.file 3 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/lock.h"
 3716              		.file 4 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_types.h"
 3717              		.file 5 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/lib/gcc/arm-none-eabi/7.3.1/include/stddef.h
 3718              		.file 6 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/reent.h"
 3719              		.file 7 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/math.h"
 3720              		.file 8 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/sys/_stdint.h"
 3721              		.file 9 "Drivers/CMSIS/Include/core_cm3.h"
 3722              		.file 10 "Drivers/CMSIS/Device/ST/STM32F1xx/Include/system_stm32f1xx.h"
 3723              		.file 11 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_hal.h"
 3724              		.file 12 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_tim.h"
 3725              		.file 13 "Drivers/STM32F1xx_HAL_Driver/Inc/stm32f1xx_ll_dma.h"
 3726              		.file 14 "stm32/stm32utilities.h"
 3727              		.file 15 "/usr/local/Cellar/gcc-arm-none-eabi/20180627/arm-none-eabi/include/stdlib.h"
 3728              		.file 16 "grbl/settings.h"
 3729              		.file 17 "grbl/system.h"
 3730              		.file 18 "grbl/planner.h"
 3731              		.file 19 "grbl/gcode.h"
 3732              		.file 20 "grbl/coolant_control.h"
 3733              		.file 21 "grbl/stepper.h"
 3734              		.file 22 "grbl/report.h"
 3735              		.file 23 "grbl/nuts_bolts.h"
 3736              		.file 24 "grbl/spindle_control.h"
 3737              		.file 25 "grbl/serial.h"
 3738              		.file 26 "grbl/limits.h"
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 93


DEFINED SYMBOLS
                            *ABS*:0000000000000000 protocol.c
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:16     .text.protocol_auto_cycle_start:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:24     .text.protocol_auto_cycle_start:0000000000000000 protocol_auto_cycle_start
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:60     .text.protocol_exec_rt_system:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:68     .text.protocol_exec_rt_system:0000000000000000 protocol_exec_rt_system
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:619    .text.protocol_exec_rt_system:00000000000002bc $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:627    .text.protocol_exec_rt_system:00000000000002d4 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:783    .text.protocol_exec_rt_suspend:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:790    .text.protocol_exec_rt_suspend:0000000000000000 protocol_exec_rt_suspend
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:1307   .text.protocol_exec_rt_suspend:0000000000000310 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:1320   .text.protocol_exec_rt_suspend:000000000000032c $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:1841   .text.protocol_exec_rt_suspend:0000000000000628 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:1847   .text.protocol_execute_realtime:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:1855   .text.protocol_execute_realtime:0000000000000000 protocol_execute_realtime
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:2399   .text.protocol_execute_realtime:00000000000002b0 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:2408   .text.protocol_execute_realtime:00000000000002c8 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:2582   .text.protocol_buffer_synchronize:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:2590   .text.protocol_buffer_synchronize:0000000000000000 protocol_buffer_synchronize
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3162   .text.protocol_buffer_synchronize:0000000000000308 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3171   .text.protocol_buffer_synchronize:0000000000000320 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3371   .text.protocol_main_loop:0000000000000000 $t
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3379   .text.protocol_main_loop:0000000000000000 protocol_main_loop
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3696   .text.protocol_main_loop:0000000000000154 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3706   .bss.line:0000000000000000 $d
/var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s:3710   .bss.line:0000000000000000 line

UNDEFINED SYMBOLS
plan_get_current_block
system_set_exec_state_flag
report_feedback_message
system_clear_exec_state_flag
system_clear_exec_accessory_overrides
st_prep_buffer
report_alarm_message
system_clear_exec_alarm
coolant_set_state
system_clear_exec_motion_overrides
plan_update_velocity_profile_parameters
plan_cycle_reinitialize
report_realtime_status
plan_reset
st_reset
gc_sync_position
plan_sync_position
sys_rt_exec_alarm
sys
sys_rt_exec_state
sys_rt_exec_motion_override
sys_rt_exec_accessory_override
gc_state
st_update_plan_block_parameters
st_wake_up
delay_sec
spindle_set_state
settings
system_check_safety_door_ajar
ARM GAS  /var/folders/m1/3lv6xmzs0mlckxs4mx90nfb40000gn/T//ccxUcui9.s 			page 94


system_set_exec_accessory_override_flag
st_go_idle
serial_read
report_status_message
gc_execute_line
system_execute_line
system_execute_startup
limits_get_state
